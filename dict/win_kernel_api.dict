ACPI_OP_REGION_CALLBACK() -> VOID #PASSIVE_LEVEL
ACPI_OP_REGION_HANDLER(ULONG AccessType, PVOID OperationRegionObject, ULONG Address, ULONG Size, PULONG Data, ULONG_PTR Context, PACPI_OP_REGION_CALLBACK CompletionHandler, PVOID CompletionContext) -> NTSTATUS #PASSIVE_LEVEL
BatteryClassInitializeDevice(PBATTERY_MINIPORT_INFO inMiniportInfo, PVOID out*ClassData) -> NTSTATUS #PASSIVE_LEVEL
BatteryClassIoctl(PVOID inClassData, PIRP ioIrp) -> NTSTATUS #PASSIVE_LEVEL
BatteryClassStatusNotify(PVOID inClassData) -> NTSTATUS #DISPATCH_LEVEL
BatteryClassUnload(PVOID inClassData) -> NTSTATUS #PASSIVE_LEVEL
ClassAcquireChildLock(PFUNCTIONAL_DEVICE_EXTENSION inFdoExtension) -> SCSIPORT_VOID #PASSIVE_LEVEL
ClassClaimDevice(PDEVICE_OBJECT inLowerDeviceObject, BOOLEAN inRelease) -> SCSIPORT_NTSTATUS #PASSIVE_LEVEL
ClassCleanupMediaChangeDetection(PFUNCTIONAL_DEVICE_EXTENSION inFdoExtension) #PASSIVE_LEVEL
ClassCreateDeviceObject(PDRIVER_OBJECT inDriverObject, PCCHAR inObjectNameBuffer, PDEVICE_OBJECT inLowerDeviceObject, BOOLEAN inIsFdo, PDEVICE_OBJECT *outDeviceObject) #PASSIVE_LEVEL
ClassDeleteSrbLookasideList(PCOMMON_DEVICE_EXTENSION ioCommonExtension) -> SCSIPORT_VOID #PASSIVE_LEVEL
ClassDisableMediaChangeDetection(PFUNCTIONAL_DEVICE_EXTENSION inFdoExtension) -> SCSIPORT_VOID #PASSIVE_LEVEL
ClassEnableMediaChangeDetection(PFUNCTIONAL_DEVICE_EXTENSION inFdoExtension) -> SCSIPORT_VOID #PASSIVE_LEVEL
ClassGetDescriptor(PDEVICE_OBJECT inDeviceObject, PSTORAGE_PROPERTY_ID inPropertyId, PVOID *Descriptor) -> SCSIPORT_NTSTATUS #PASSIVE_LEVEL
ClassGetDeviceParameter(PFUNCTIONAL_DEVICE_EXTENSION inFdoExtension, PWSTR inSubkeyName, PWSTR inParameterName, PULONG ioParameterValue) -> VOID #PASSIVE_LEVEL
ClassGetDriverExtension(PDRIVER_OBJECT inDriverObject) -> SCSIPORT_PCLASS_DRIVER_EXTENSION #DISPATCH_LEVEL
ClassGetFsContext(PCOMMON_DEVICE_EXTENSION inCommonExtension, PFILE_OBJECT inFileObject) -> PFILE_OBJECT_EXTENSION #PASSIVE_LEVEL
ClassInitialize(PVOID inArgument1, PVOID inArgument2, PCLASS_INIT_DATA inInitializationData) -> SCSIPORT_ULONG #PASSIVE_LEVEL
ClassInitializeEx(PDRIVER_OBJECT inDriverObject, LPGUID inGuid, PVOID inData) -> SCSIPORT_ULONG #PASSIVE_LEVEL
ClassInitializeMediaChangeDetection(PFUNCTIONAL_DEVICE_EXTENSION inFdoExtension, PUCHAR inEventPrefix) -> SCSIPORT_VOID #PASSIVE_LEVEL
ClassInitializeSrbLookasideList(PCOMMON_DEVICE_EXTENSION ioCommonExtension, ULONG inNumberElements) -> SCSIPORT_VOID #PASSIVE_LEVEL
ClassInitializeTestUnitPolling(PFUNCTIONAL_DEVICE_EXTENSION inFdoExtension, BOOLEAN inAllowDriveToSleep) -> SCSIPORT_NTSTATUS #PASSIVE_LEVEL
ClassInvalidateBusRelations(PDEVICE_OBJECT inFdo) -> SCSIPORT_VOID #PASSIVE_LEVEL
ClassMarkChildMissing(PPHYSICAL_DEVICE_EXTENSION inPdoExtension, BOOLEAN inAcquireChildLock) -> SCSIPORT_BOOLEAN #PASSIVE_LEVEL
ClassMarkChildrenMissing(PFUNCTIONAL_DEVICE_EXTENSION inFdo) -> SCSIPORT_VOID #PASSIVE_LEVEL
ClassNotifyFailurePredicted(PFUNCTIONAL_DEVICE_EXTENSION inFdoExtension, PUCHAR Buffer, ULONG inBufferSize, BOOLEAN inLogError, ULONG inUniqueErrorValue, UCHAR inPathId, UCHAR inTargetId, UCHAR inLun) -> VOID #DISPATCH_LEVEL
ClassQueryTimeOutRegistryValue(PDEVICE_OBJECT inDeviceObject) -> SCSIPORT_ULONG #PASSIVE_LEVEL
ClassRemoveDevice(PDEVICE_OBJECT inDeviceObject, UCHAR inRemoveType) -> SCSIPORT_NTSTATUS #PASSIVE_LEVEL
ClassScanForSpecial(PFUNCTIONAL_DEVICE_EXTENSION inFdoExtension, CLASSPNP_SCAN_FOR_SPECIAL_INFO inDeviceList[], PCLASS_SCAN_FOR_SPECIAL_HANDLER inFunction) -> VOID #PASSIVE_LEVEL
ClassSendNotification(PFUNCTIONAL_DEVICE_EXTENSION inFdoExtension, const inGUID * Guid, ULONG inExtraDataSize, PVOID inExtraData) -> VOID #DISPATCH_LEVEL
ClassSetDeviceParameter(PFUNCTIONAL_DEVICE_EXTENSION inFdoExtension, PWSTR inSubkeyName, PWSTR inParameterName, ULONG inParameterValue) -> NTSTATUS #PASSIVE_LEVEL
ClassSetFailurePredictionPoll(PFUNCTIONAL_DEVICE_EXTENSION ioFdoExtension, FAILURE_PREDICTION_METHOD inFailurePredictionMethod, ULONG inPollingPeriod) -> NTSTATUS #PASSIVE_LEVEL
ClassSetMediaChangeState(PFUNCTIONAL_DEVICE_EXTENSION inFdoExtension, MEDIA_CHANGE_DETECTION_STATE inState, BOOLEAN inWait) -> SCSIPORT_VOID #PASSIVE_LEVEL
ClassUpdateInformationInRegistry(PDEVICE_OBJECT inFdo, PCHAR inDeviceName, ULONG inDeviceNumber, PINQUIRYDATA inInquiryData, ULONG inInquiryDataLength) -> SCSIPORT_VOID #PASSIVE_LEVEL
ClassWmiFireEvent(PDEVICE_OBJECT inDeviceObject, LPGUID inGuid, ULONG inInstanceIndex, ULONG inEventDataSize, VOID EventData) -> SCSIPORT_NTSTATUS #DISPATCH_LEVEL
CmCallbackGetKeyObjectID(PLARGE_INTEGER inCookie, 	 PVOID	 inObject, PULONG_PTR outObjectID, PCUNICODE_STRING *ObjectName) -> NTSTATUS #APC_LEVEL
CmGetBoundTransaction(PLARGE_INTEGER inCookie, -> PVOID #APC_LEVEL
CmGetCallbackVersion(PULONG outMajor, PULONG outMinor) -> VOID #APC_LEVEL
CmRegisterCallback(PEX_CALLBACK_FUNCTION inFunction, PVOID inContext, PLARGE_INTEGER outCookie) -> NTSTATUS #APC_LEVEL
CmRegisterCallbackEx(PEX_CALLBACK_FUNCTION inFunction, PCUNICODE_STRING inAltitude, PVOID inDriver, #PDRIVER_OBJECT PVOID 	inContext, PLARGE_INTEGER 	 outCookie, PVOID			 Reserved) -> NTSTATUS //APC_LEVEL
CmSetCallbackObjectContext(PVOID	 ioObject, PLARGE_INTEGER inCookie, PVOID inNewContext, PVOID out*OldContext) -> NTSTATUS #APC_LEVEL
DRIVER_NOTIFICATION_CALLBACK_ROUTINE(PVOID inNotificationStructure, PVOID Context) -> NTSTATUS #PASSIVE_LEVEL
DeRegisterOpRegionHandler(PDEVICE_OBJECT inDeviceObject, PVOID inOperationRegionObject) -> NTSTATUS #PASSIVE_LEVEL
DrmAddContentHandlers(ULONG inContentId, PVOID* paHandlers, ULONG inNumHandlers) -> NTSTATUS #PASSIVE_LEVEL
DrmCreateContentMixed(PULONG inpaContentId, ULONG incContentId, PULONG outpMixedContentId) -> NTSTATUS #PASSIVE_LEVEL
DrmDestroyContent(ULONG inContentId) -> NTSTATUS #PASSIVE_LEVEL
DrmForwardContentToFileObject(ULONG inContentId, PFILE_OBJECT inFileObject) -> NTSTATUS #PASSIVE_LEVEL
DrmForwardContentToInterface(ULONG inContentId, PUNKNOWN inpUnknown, -> NTSTATUS #PASSIVE_LEVEL
DrmGetContentRights(ULONG inContentId, PDRMRIGHTS outDrmRights) -> NTSTATUS #PASSIVE_LEVEL
EmClientQueryRuleState(LPCGUID inRuleId, PEM_RULE_STATE outState) -> NTSTATUS #APC_LEVEL
EmClientRuleDeregisterNotification(PVOID inNotificationHandle) -> VOID #APC_LEVEL
EmClientRuleEvaluate(LPCGUID inRuleId, EM_ENTRY_DATA **InputEntries, ULONG inNumberOfEntries, PEM_RULE_STATE outState) -> NTSTATUS #APC_LEVEL
EmClientRuleRegisterNotification(PDRIVER_OBJECT inDriverObject, PEM_CLIENT_NOTIFICATION_REGISTRATION RuleNotificationsRegistration, ULONG inNumberOfNotificatoinRegistration, PVOID out*NotificationHandle) -> NTSTATUS #APC_LEVEL
EmProviderDeregister(PVOID inProviderHandle) -> VOID #APC_LEVEL
EmProviderDeregisterEntry(PVOID inEntryHandle) -> VOID #APC_LEVEL
EmProviderRegister(PDRIVER_OBJECT inDriverObject, PEM_ENTRY_REGISTRATION inEntryRegistration, ULONG inNumberOfEntry, PEM_CALLBACK_REGISTRATION inCallbackRegistration, ULONG inNumberOfCallback, PVOID out*ProviderHandle) -> NTSTATUS #APC_LEVEL
EmProviderRegisterEntry(PVOID inProviderHandle, LPCGUID inEntryId, PEM_ENTRY_DATA inEntryData, PVOID out*EntryHandle) -> NTSTATUS #APC_LEVEL
EtwActivityIdControl(ULONG inControlCode, LPGUID ActivityId) -> NTSTATUS #APC_LEVEL
EtwEventEnabled(REGHANDLE inRegHandle, PCEVENT_DESCRIPTOR inEventDescriptor) -> BOOLEAN #HIGH_LEVEL
EtwProviderEnabled(REGHANDLE inRegHandle, UCHAR inLevel, ULONGLONG inKeyword) -> BOOLEAN #HIGH_LEVEL
EtwRegister(LPCGUID inProviderId, PETWENABLECALLBACK inEnableCallback, PVOID inCallbackContext, PREGHANDLE outRegHandle) -> NTSTATUS #PASSIVE_LEVEL
EtwUnregister(REGHANDLE inRegHandle) -> NTSTATUS #PASSIVE_LEVEL
EtwWrite(REGHANDLE inRegHandle, PCEVENT_DESCRIPTOR inEventDescriptor, LPCGUID inActivityId, ULONG inUserDataCount, PEVENT_DATA_DESCRIPTOR inUserData) -> NTSTATUS #HIGH_LEVEL
EtwWriteEx(REGHANDLE inRegHandle, PCEVENT_DESCRIPTOR inEventDescriptor, ULONG64 inFilter, ULONG inFlags, LPCGUID inActivityId, LPCGUID inRelatedActivityId, ULONG inUserDataCount, PEVENT_DATA_DESCRIPTOR inUserData) -> NTSTATUS #HIGH_LEVEL
EtwWriteString(REGHANDLE inRegHandle, UCHAR inLevel, ULONGLONG inKeyword, LPCGUID inActivityId, PCWSTR inString) -> NTSTATUS #HIGH_LEVEL
EtwWriteTransfer(REGHANDLE inRegHandle, PCEVENT_DESCRIPTOR inEventDescriptor, LPCGUID inActivityId, LPCGUID inRelatedActivityId, ULONG inUserDataCount, PEVENT_DATA_DESCRIPTOR inUserData) -> NTSTATUS #HIGH_LEVEL
ExAcquireFastMutexUnsafe(PFAST_MUTEX ioFastMutex) -> FASTCALL #APC_LEVEL
ExAcquireResourceExclusiveLite(PERESOURCE ioResource, BOOLEAN inWait) #APC_LEVEL
ExAcquireResourceSharedLite(PERESOURCE ioResource, BOOLEAN inWait) #APC_LEVEL
ExAcquireSharedStarveExclusive(PERESOURCE ioResource, BOOLEAN inWait) #APC_LEVEL
ExAcquireSharedWaitForExclusive(PERESOURCE ioResource, BOOLEAN inWait) #APC_LEVEL
ExAdjustLookasideDepth(VOID) -> VOID #DISPATCH_LEVEL
ExAllocateCacheAwareRundownProtection(POOL_TYPE inPoolType, ULONG inPoolTag) -> PEX_RUNDOWN_REF_CACHE_AWARE #APC_LEVEL
ExAllocateFromPagedLookasideList(PPAGED_LOOKASIDE_LIST ioLookaside) -> PVOID #APC_LEVEL
ExAllocatePool(POOL_TYPE inPoolType, SIZE_T inNumberOfBytes) -> PVOID # APC_LEVEL
ExAllocatePoolWithQuota(POOL_TYPE inPoolType, SIZE_T inNumberOfBytes) -> PVOID # APC_LEVEL
ExAllocatePoolWithQuotaTag(POOL_TYPE inPoolType, SIZE_T inNumberOfBytes, ULONG inTag) -> PVOID # DISPATCH_LEVEL
ExAllocatePoolWithTag(POOL_TYPE inPoolType, SIZE_T inNumberOfBytes, ULONG inTag) -> PVOID # DISPATCH_LEVEL
ExAllocatePoolWithTagPriority(POOL_TYPE inPoolType, SIZE_T inNumberOfBytes, ULONG inTag, EX_POOL_PRIORITY inPriority) -> PVOID # DISPATCH_LEVEL
ExConvertExclusiveToSharedLite(PERESOURCE ioResource) -> VOID #DISPATCH_LEVEL
ExCreateCallback(PCALLBACK_OBJECT *CallbackObject, POBJECT_ATTRIBUTES inObjectAttributes, BOOLEAN inCreate, BOOLEAN inAllowMultipleCallbacks) -> NTSTATUS #APC_LEVEL
ExDeleteLookasideListEx(PLOOKASIDE_LIST_EX ioLookaside) -> VOID #DISPATCH_LEVEL
ExDeleteNPagedLookasideList(PNPAGED_LOOKASIDE_LIST ioLookaside) -> VOID #DISPATCH_LEVEL
ExDeletePagedLookasideList(PPAGED_LOOKASIDE_LIST ioLookaside) -> VOID #APC_LEVEL
ExDeleteResourceLite(PERESOURCE ioResource) -> NTSTATUS #DISPATCH_LEVEL
ExDisableResourceBoostLite(PERESOURCE inResource) -> VOID #DISPATCH_LEVEL
ExEnterCriticalRegionAndAcquireResourceExclusive(PERESOURCE ioResource) -> PVOID #APC_LEVEL
ExEnterCriticalRegionAndAcquireResourceShared(PERESOURCE ioResource) -> PVOID #APC_LEVEL
ExEnterCriticalRegionAndAcquireSharedWaitForExclusive(PERESOURCE ioResource) -> PVOID #APC_LEVEL
ExFlushLookasideListEx(PLOOKASIDE_LIST_EX ioLookaside) -> VOID #DISPATCH_LEVEL
ExFreeCacheAwareRundownProtection(PEX_RUNDOWN_REF_CACHE_AWARE ioRunRefCacheAware) -> VOID #APC_LEVEL
ExFreePool(inPVOID P) -> VOID #DISPATCH_LEVEL
ExFreePoolWithTag(inPVOID P, ULONG inTag) -> VOID #DISPATCH_LEVEL
ExFreeToPagedLookasideList(PPAGED_LOOKASIDE_LIST ioLookaside, PVOID inEntry) -> VOID #APC_LEVEL
ExGetExclusiveWaiterCount(PERESOURCE inResource) -> ULONG #DISPATCH_LEVEL
ExGetPreviousMode(VOID) -> KPROCESSOR_MODE #DISPATCH_LEVEL
ExGetSharedWaiterCount(PERESOURCE inResource) -> ULONG #DISPATCH_LEVEL
ExInitializeLookasideListEx(PLOOKASIDE_LIST_EX outLookaside, PALLOCATE_FUNCTION_EX inAllocate, PFREE_FUNCTION_EX inFree, POOL_TYPE inPoolType, ULONG inFlags, SIZE_T inSize, ULONG inTag, USHORT inDepth) -> NTSTATUS #DISPATCH_LEVEL
ExInitializeNPagedLookasideList(PNPAGED_LOOKASIDE_LIST outLookaside, PALLOCATE_FUNCTION inAllocate, PFREE_FUNCTION inFree, ULONG inFlags, SIZE_T inSize, ULONG inTag, USHORT inDepth) -> VOID #DISPATCH_LEVEL
ExInitializePagedLookasideList(PPAGED_LOOKASIDE_LIST outLookaside, PALLOCATE_FUNCTION inAllocate, PFREE_FUNCTION inFree, ULONG inFlags, SIZE_T inSize, ULONG inTag, USHORT inDepth) -> VOID #APC_LEVEL
ExInitializeResourceLite(PERESOURCE outResource) -> NTSTATUS #DISPATCH_LEVEL
ExInitializeRundownProtectionCacheAware(PEX_RUNDOWN_REF_CACHE_AWARE outRunRefCacheAware, SIZE_T inRunRefSize) -> VOID #APC_LEVEL
ExInterlockedExtendZone(PZONE_HEADER ioZone, PVOID ioSegment, ULONG inSegmentSize, PKSPIN_LOCK ioLock) -> NTSTATUS #DISPATCH_LEVEL
ExIsProcessorFeaturePresent(ULONG inProcessorFeature) -> BOOLEAN #PASSIVE_LEVEL
ExIsResourceAcquiredExclusiveLite(PERESOURCE inResource) -> BOOLEAN #DISPATCH_LEVEL
ExIsResourceAcquiredSharedLite(PERESOURCE inResource) -> ULONG #DISPATCH_LEVEL
ExNotifyCallback(PVOID inCallbackObject, PVOID inArgument1, PVOID inArgument2) -> VOID #DISPATCH_LEVEL
ExQueryPoolBlockSize(PVOID inPoolBlock, PBOOLEAN outQuotaCharged) -> SIZE_T #DISPATCH_LEVEL
ExQueueWorkItem(PWORK_QUEUE_ITEM ioWorkItem, WORK_QUEUE_TYPE inQueueType) -> VOID #DISPATCH_LEVEL
ExRaiseAccessViolation(VOID) -> VOID #PASSIVE_LEVEL
ExRaiseDatatypeMisalignment(VOID) -> VOID #PASSIVE_LEVEL
ExRaiseStatus(NTSTATUS inStatus) -> VOID #APC_LEVEL
ExRegisterCallback(PCALLBACK_OBJECT ioCallbackObject, PCALLBACK_FUNCTION inCallbackFunction, PVOID inCallbackContext) -> PVOID #APC_LEVEL
ExReinitializeResourceLite(PERESOURCE ioResource) -> NTSTATUS #DISPATCH_LEVEL
ExReleaseFastMutexUnsafe(PFAST_MUTEX ioFastMutex) -> FASTCALL #APC_LEVEL
ExReleaseResourceAndLeaveCriticalRegion(PERESOURCE ioResource) -> FASTCALL #DISPATCH_LEVEL
ExReleaseResourceForThreadLite(PERESOURCE ioResource, ERESOURCE_THREAD inResourceThreadId) -> VOID #DISPATCH_LEVEL
ExReleaseResourceLite(PERESOURCE ioResource) -> FASTCALL #DISPATCH_LEVEL
ExSetResourceOwnerPointer(PERESOURCE ioResource, PVOID inOwnerPointer) -> VOID #DISPATCH_LEVEL
ExSetResourceOwnerPointerEx(PERESOURCE ioResource, PVOID inOwnerPointer, ULONG inFlags) -> VOID #DISPATCH_LEVEL
ExSetTimerResolution(ULONG inDesiredTime, BOOLEAN inSetResolution) -> ULONG #APC_LEVEL
ExSizeOfRundownProtectionCacheAware(VOID) -> SIZE_T #APC_LEVEL
ExUnregisterCallback(PVOID ioCallbackRegistration) -> VOID #APC_LEVEL
ExUuidCreate(UUID out*Uuid) -> NTSTATUS #PASSIVE_LEVEL
FltAcknowledgeEcp(PFLT_FILTER inFilter, PVOID inEcpContext) -> VOID #APC_LEVEL
FltAcquirePushLockExclusive(PEX_PUSH_LOCK ioPushLock) -> VOID #APC_LEVEL
FltAcquirePushLockShared(PEX_PUSH_LOCK ioPushLock) -> VOID #APC_LEVEL
FltAcquireResourceExclusive(PERESOURCE ioResource) -> VOID #APC_LEVEL
FltAcquireResourceShared(PERESOURCE ioResource) -> VOID #APC_LEVEL
FltAdjustDeviceStackSizeForIoRedirection(PFLT_INSTANCE inSourceInstance, PFLT_INSTANCE inTargetInstance, PBOOLEAN outSourceDeviceStackSizeModified) -> NTSTATUS #DISPATCH_LEVEL
FltAllocateCallbackData(PFLT_INSTANCE inInstance, PFILE_OBJECT inFileObject, PFLT_CALLBACK_DATA *RetNewCallbackData) -> NTSTATUS #APC_LEVEL
FltAllocateCallbackDataEx(PFLT_INSTANCE inInstance, PFILE_OBJECT inFileObject, FLT_ALLOCATE_CALLBACK_DATA_FLAGS inFlags, PFLT_CALLBACK_DATA *RetNewCallbackData) -> NTSTATUS #APC_LEVEL
FltAllocateContext(PFLT_FILTER inFilter, FLT_CONTEXT_TYPE inContextType, SIZE_T inContextSize, POOL_TYPE inPoolType, PFLT_CONTEXT *ReturnedContext) -> NTSTATUS #APC_LEVEL
FltAllocateDeferredIoWorkItem(VOID) -> PFLT_DEFERRED_IO_WORKITEM #DISPATCH_LEVEL
FltAllocateExtraCreateParameter(PFLT_FILTER inFilter, LPCGUID inEcpType, ULONG inSizeOfContext, FSRTL_ALLOCATE_ECP_FLAGS inFlags, PFSRTL_EXTRA_CREATE_PARAMETER_CLEANUP_CALLBACK inCleanupCallback, ULONG inPoolTag, PVOID *EcpContext) -> NTSTATUS #APC_LEVEL
FltAllocateExtraCreateParameterFromLookasideList(PFLT_FILTER inFilter, LPCGUID inEcpType, ULONG inSizeOfContext, FSRTL_ALLOCATE_ECP_FLAGS inFlags, PFSRTL_EXTRA_CREATE_PARAMETER_CLEANUP_CALLBACK inCleanupCallback, PVOID ioLookasideList, PVOID *EcpContext) -> NTSTATUS #APC_LEVEL
FltAllocateExtraCreateParameterList(PFLT_FILTER inFilter, FSRTL_ALLOCATE_ECPLIST_FLAGS inFlags, PECP_LIST *EcpList) -> NTSTATUS #APC_LEVEL
FltAllocateFileLock(PFLT_COMPLETE_LOCK_CALLBACK_DATA_ROUTINE inCompleteLockCallbackDataRoutine, PUNLOCK_ROUTINE inUnlockRoutine) -> PFILE_LOCK #APC_LEVEL
FltAllocateGenericWorkItem(VOID) -> PFLT_GENERIC_WORKITEM #DISPATCH_LEVEL
FltAllocatePoolAlignedWithTag(PFLT_INSTANCE inInstance, POOL_TYPE inPoolType, SIZE_T inNumberOfBytes, ULONG inTag) -> PVOID # APC_LEVEL
FltApplyPriorityInfoThread(PIO_PRIORITY_INFO inInputPriorityInfo, PIO_PRIORITY_INFO outOutputPriorityInfo, PETHREAD inThread) -> NTSTATUS #DISPATCH_LEVEL
FltAttachVolume(PFLT_FILTER ioFilter, PFLT_VOLUME ioVolume, PCUNICODE_STRING inInstanceName, PFLT_INSTANCE *RetInstance) -> NTSTATUS #APC_LEVEL
FltAttachVolumeAtAltitude(PFLT_FILTER ioFilter, PFLT_VOLUME ioVolume, PCUNICODE_STRING inAltitude, PCUNICODE_STRING inInstanceName, PFLT_INSTANCE *RetInstance) -> NTSTATUS #APC_LEVEL
FltBuildDefaultSecurityDescriptor(PSECURITY_DESCRIPTOR *SecurityDescriptor, ACCESS_MASK inDesiredAccess) -> NTSTATUS #APC_LEVEL
FltCancelFileOpen(PFLT_INSTANCE inInstance, PFILE_OBJECT inFileObject) -> VOID #PASSIVE_LEVEL
FltCancelIo(PFLT_CALLBACK_DATA inCallbackData) -> BOOLEAN #DISPATCH_LEVEL
FltCancellableWaitForMultipleObjects(ULONG inCount, PVOID ObjectArray[], WAIT_TYPE inWaitType, PLARGE_INTEGER inTimeout, PKWAIT_BLOCK inWaitBlockArray, PFLT_CALLBACK_DATA inCallbackData) -> NTSTATUS # APC_LEVEL
FltCancellableWaitForSingleObject(PVOID inObject, PLARGE_INTEGER inTimeout, PFLT_CALLBACK_DATA inCallbackData) -> NTSTATUS # APC_LEVEL
FltCheckAndGrowNameControl(PFLT_NAME_CONTROL ioNameCtrl, USHORT inNewSize) -> NTSTATUS #APC_LEVEL
FltCheckLockForReadAccess(PFILE_LOCK inFileLock, PFLT_CALLBACK_DATA inCallbackData) -> BOOLEAN #APC_LEVEL
FltCheckLockForWriteAccess(PFILE_LOCK inFileLock, PFLT_CALLBACK_DATA inCallbackData) -> BOOLEAN #APC_LEVEL
FltCheckOplock(POPLOCK inOplock, PFLT_CALLBACK_DATA inCallbackData, PVOID inContext, PFLTOPLOCK_WAIT_COMPLETE_ROUTINE inWaitCompletionRoutine, PFLTOPLOCK_PREPOST_CALLBACKDATA_ROUTINE inPrePostCallbackDataRoutine) -> FLT_PREOP_CALLBACK_STATUS #APC_LEVEL
FltCheckOplockEx(POPLOCK inOplock, PFLT_CALLBACK_DATA inCallbackData, ULONG inFlags, PVOID inContext, PFLTOPLOCK_WAIT_COMPLETE_ROUTINE inWaitCompletionRoutine, PFLTOPLOCK_PREPOST_CALLBACKDATA_ROUTINE inPrePostCallbackDataRoutine) -> FLT_PREOP_CALLBACK_STATUS #APC_LEVEL
FltClearCancelCompletion(PFLT_CALLBACK_DATA inCallbackData) -> NTSTATUS #DISPATCH_LEVEL
FltClose(HANDLE inFileHandle) -> NTSTATUS #PASSIVE_LEVEL
FltCloseClientPort(PFLT_FILTER inFilter, PFLT_PORT *ClientPort) -> VOID #PASSIVE_LEVEL
FltCloseCommunicationPort(PFLT_PORT inServerPort) -> VOID #PASSIVE_LEVEL
FltCommitComplete(PFLT_INSTANCE inInstance, PKTRANSACTION inTransaction, PFLT_CONTEXT inTransactionContext) -> NTSTATUS #PASSIVE_LEVEL
FltCommitFinalizeComplete(PFLT_INSTANCE inInstance, PKTRANSACTION inTransaction, PFLT_CONTEXT inTransactionContext) -> NTSTATUS #APC_LEVEL
FltCompletePendedPostOperation(PFLT_CALLBACK_DATA inCallbackData) -> VOID #DISPATCH_LEVEL
FltCompletePendedPreOperation(PFLT_CALLBACK_DATA inCallbackData, FLT_PREOP_CALLBACK_STATUS inCallbackStatus, PVOID inContext) -> VOID # APC_LEVEL
FltCreateCommunicationPort(PFLT_FILTER inFilter, PFLT_PORT *ServerPort, POBJECT_ATTRIBUTES inObjectAttributes, PVOID inServerPortCookie, PFLT_CONNECT_NOTIFY inConnectNotifyCallback, PFLT_DISCONNECT_NOTIFY inDisconnectNotifyCallback, PFLT_MESSAGE_NOTIFY inMessageNotifyCallback, LONG inMaxConnections) -> NTSTATUS #PASSIVE_LEVEL
FltCreateFile(PFLT_FILTER inFilter, PFLT_INSTANCE inInstance, PHANDLE outFileHandle, ACCESS_MASK inDesiredAccess, POBJECT_ATTRIBUTES inObjectAttributes, PIO_STATUS_BLOCK outIoStatusBlock, PLARGE_INTEGER inAllocationSize, ULONG inFileAttributes, ULONG inShareAccess, ULONG inCreateDisposition, ULONG inCreateOptions, VOID inEaBuffer, ULONG inEaLength, ULONG inFlags) -> NTSTATUS #PASSIVE_LEVEL
FltCreateFileEx(PFLT_FILTER inFilter, PFLT_INSTANCE inInstance, PHANDLE outFileHandle, PFILE_OBJECT *FileObject, ACCESS_MASK inDesiredAccess, POBJECT_ATTRIBUTES inObjectAttributes, PIO_STATUS_BLOCK outIoStatusBlock, PLARGE_INTEGER inAllocationSize, ULONG inFileAttributes, ULONG inShareAccess, ULONG inCreateDisposition, ULONG inCreateOptions, PVOID inEaBuffer, ULONG inEaLength, ULONG inFlags) -> NTSTATUS #PASSIVE_LEVEL
FltCreateFileEx2(PFLT_FILTER inFilter, PFLT_INSTANCE inInstance, PHANDLE outFileHandle, PFILE_OBJECT *FileObject, ACCESS_MASK inDesiredAccess, POBJECT_ATTRIBUTES inObjectAttributes, PIO_STATUS_BLOCK outIoStatusBlock, PLARGE_INTEGER inAllocationSize, ULONG inFileAttributes, ULONG inShareAccess, ULONG inCreateDisposition, ULONG inCreateOptions, PVOID inEaBuffer, ULONG inEaLength, ULONG inFlags, PIO_DRIVER_CREATE_CONTEXT inDriverContext) -> NTSTATUS #PASSIVE_LEVEL
FltCreateSystemVolumeInformationFolder(PFLT_INSTANCE inInstance) -> NTSTATUS #PASSIVE_LEVEL
FltCurrentBatchOplock(POPLOCK inOplock) -> BOOLEAN #APC_LEVEL
FltCurrentOplock(POPLOCK inOplock) -> BOOLEAN #APC_LEVEL
FltCurrentOplockH(POPLOCK inOplock) -> BOOLEAN #APC_LEVEL
FltDeleteContext(PFLT_CONTEXT inContext) -> VOID #APC_LEVEL
FltDeleteExtraCreateParameterLookasideList(PFLT_FILTER inFilter, PVOID ioLookaside, FSRTL_ECP_LOOKASIDE_FLAGS inFlags) -> VOID #APC_LEVEL
FltDeleteFileContext(PFLT_INSTANCE inInstance, PFILE_OBJECT inFileObject, PFLT_CONTEXT *OldContext) -> NTSTATUS #APC_LEVEL
FltDeleteInstanceContext(PFLT_INSTANCE inInstance, PFLT_CONTEXT *OldContext) -> NTSTATUS #APC_LEVEL
FltDeletePushLock(PEX_PUSH_LOCK inPushLock) -> VOID #APC_LEVEL
FltDeleteStreamContext(PFLT_INSTANCE inInstance, PFILE_OBJECT inFileObject, PFLT_CONTEXT *OldContext) -> NTSTATUS #APC_LEVEL
FltDeleteStreamHandleContext(PFLT_INSTANCE inInstance, PFILE_OBJECT inFileObject, PFLT_CONTEXT *OldContext) -> NTSTATUS #APC_LEVEL
FltDeleteTransactionContext(PFLT_INSTANCE inInstance, PKTRANSACTION inTransaction, PFLT_CONTEXT *OldContext) -> NTSTATUS #APC_LEVEL
FltDeleteVolumeContext(PFLT_FILTER inFilter, PFLT_VOLUME inVolume, PFLT_CONTEXT *OldContext) -> NTSTATUS #APC_LEVEL
FltDetachVolume(PFLT_FILTER ioFilter, PFLT_VOLUME ioVolume, PCUNICODE_STRING inInstanceName) -> NTSTATUS #APC_LEVEL
FltDeviceIoControlFile(PFLT_INSTANCE inInstance, PFILE_OBJECT inFileObject, ULONG inIoControlCode, PVOID inInputBuffer, ULONG inInputBufferLength, PVOID outOutputBuffer, ULONG inOutputBufferLength, PULONG outLengthReturned) -> NTSTATUS #PASSIVE_LEVEL
FltEnlistInTransaction(PFLT_INSTANCE inInstance, PKTRANSACTION inTransaction, PFLT_CONTEXT inTransactionContext, NOTIFICATION_MASK inNotificationMask) -> NTSTATUS #APC_LEVEL
FltEnumerateFilterInformation(ULONG inIndex, FILTER_INFORMATION_CLASS inInformationClass, PVOID outBuffer, ULONG inBufferSize, PULONG outBytesReturned) -> NTSTATUS #APC_LEVEL
FltEnumerateFilters(PFLT_FILTER *outFilterList, ULONG inFilterListSize, PULONG outNumberFiltersReturned) -> NTSTATUS #APC_LEVEL
FltEnumerateInstanceInformationByFilter(PFLT_FILTER inFilter, ULONG inIndex, INSTANCE_INFORMATION_CLASS inInformationClass, PVOID outBuffer, ULONG inBufferSize, PULONG outBytesReturned) -> NTSTATUS #APC_LEVEL
FltEnumerateInstanceInformationByVolume(PFLT_VOLUME inVolume, ULONG inIndex, INSTANCE_INFORMATION_CLASS inInformationClass, PVOID outBuffer, ULONG inBufferSize, PULONG outBytesReturned) -> NTSTATUS #APC_LEVEL
FltEnumerateInstances(PFLT_VOLUME inVolume, PFLT_FILTER inFilter, PFLT_INSTANCE out*InstanceList, ULONG inInstanceListSize, PULONG outNumberInstancesReturned) -> NTSTATUS #APC_LEVEL
FltEnumerateVolumeInformation(PFLT_FILTER inFilter, ULONG inIndex, FILTER_VOLUME_INFORMATION_CLASS inInformationClass, PVOID outBuffer, ULONG inBufferSize, PULONG outBytesReturned) -> NTSTATUS #APC_LEVEL
FltEnumerateVolumes(PFLT_FILTER inFilter, PFLT_VOLUME out*VolumeList, ULONG inVolumeListSize, PULONG outNumberVolumesReturned) -> NTSTATUS #APC_LEVEL
FltFindExtraCreateParameter(PFLT_FILTER inFilter, PECP_LIST inEcpList, LPCGUID inEcpType, PVOID *EcpContext, ULONG out*EcpContextSize) -> NTSTATUS #APC_LEVEL
FltFlushBuffers(PFLT_INSTANCE inInstance, PFILE_OBJECT inFileObject) -> NTSTATUS #PASSIVE_LEVEL
FltFreeCallbackData(PFLT_CALLBACK_DATA inCallbackData) -> VOID #DISPATCH_LEVEL
FltFreeDeferredIoWorkItem(PFLT_DEFERRED_IO_WORKITEM inFltWorkItem) -> VOID #DISPATCH_LEVEL
FltFreeExtraCreateParameter(PFLT_FILTER inFilter, PVOID inEcpContext) -> VOID #APC_LEVEL
FltFreeExtraCreateParameterList(PFLT_FILTER inFilter, PECP_LIST inEcpList) -> VOID #APC_LEVEL
FltFreeFileLock(PFILE_LOCK inFileLock) -> VOID #APC_LEVEL
FltFreeGenericWorkItem(PFLT_GENERIC_WORKITEM inFltWorkItem) -> VOID #DISPATCH_LEVEL
FltFreePoolAlignedWithTag(PFLT_INSTANCE inInstance, PVOID inBuffer, ULONG inTag) -> VOID #DISPATCH_LEVEL
FltFreeSecurityDescriptor(PSECURITY_DESCRIPTOR inSecurityDescriptor) -> VOID #APC_LEVEL
FltFsControlFile(PFLT_INSTANCE inInstance, PFILE_OBJECT inFileObject, ULONG inFsControlCode, PVOID inInputBuffer, ULONG inInputBufferLength, PVOID outOutputBuffer, ULONG inOutputBufferLength, PULONG outLengthReturned) -> NTSTATUS #PASSIVE_LEVEL
FltGetBottomInstance(PFLT_VOLUME inVolume, PFLT_INSTANCE *Instance) -> NTSTATUS #APC_LEVEL
FltGetContexts(PCFLT_RELATED_OBJECTS inFltObjects, FLT_CONTEXT_TYPE inDesiredContexts, PFLT_RELATED_CONTEXTS outContexts) -> VOID #APC_LEVEL
FltGetDestinationFileNameInformation(PFLT_INSTANCE inInstance, PFILE_OBJECT inFileObject, HANDLE inRootDirectory, PWSTR FileName, ULONG inFileNameLength, FLT_FILE_NAME_OPTIONS inNameOptions, PFLT_FILE_NAME_INFORMATION *RetFileNameInformation) -> NTSTATUS #APC_LEVEL
FltGetDeviceObject(PFLT_VOLUME inVolume, PDEVICE_OBJECT *DeviceObject) -> NTSTATUS #DISPATCH_LEVEL
FltGetDiskDeviceObject(PFLT_VOLUME inVolume, PDEVICE_OBJECT *DiskDeviceObject) -> NTSTATUS #DISPATCH_LEVEL
FltGetEcpListFromCallbackData(PFLT_FILTER inFilter, PFLT_CALLBACK_DATA inCallbackData, PECP_LIST *EcpList) -> NTSTATUS #APC_LEVEL
FltGetFileContext(PFLT_INSTANCE inInstance, PFILE_OBJECT inFileObject, PFLT_CONTEXT *Context) -> NTSTATUS #APC_LEVEL
FltGetFileNameInformation(PFLT_CALLBACK_DATA inCallbackData, FLT_FILE_NAME_OPTIONS inNameOptions, PFLT_FILE_NAME_INFORMATION *FileNameInformation) -> NTSTATUS #APC_LEVEL
FltGetFileNameInformationUnsafe(PFILE_OBJECT inFileObject, PFLT_INSTANCE inInstance, FLT_FILE_NAME_OPTIONS inNameOptions, PFLT_FILE_NAME_INFORMATION *FileNameInformation) -> NTSTATUS #APC_LEVEL
FltGetFileSystemType(PVOID inFltObject, PFLT_FILESYSTEM_TYPE outFileSystemType) -> NTSTATUS #APC_LEVEL
FltGetFilterFromInstance(PFLT_INSTANCE inInstance, PFLT_FILTER *RetFilter) -> NTSTATUS #APC_LEVEL
FltGetFilterFromName(PCUNICODE_STRING inFilterName, PFLT_FILTER *RetFilter) -> NTSTATUS #APC_LEVEL
FltGetFilterInformation(PFLT_FILTER inFilter, FILTER_INFORMATION_CLASS inInformationClass, PVOID outBuffer, ULONG inBufferSize, PULONG outBytesReturned) -> NTSTATUS #APC_LEVEL
FltGetInstanceContext(PFLT_INSTANCE inInstance, PFLT_CONTEXT *Context) -> NTSTATUS #APC_LEVEL
FltGetInstanceInformation(PFLT_INSTANCE inInstance, INSTANCE_INFORMATION_CLASS inInformationClass, PVOID outBuffer, ULONG inBufferSize, PULONG outBytesReturned) -> NTSTATUS #APC_LEVEL
FltGetIoPriorityHint(PFLT_CALLBACK_DATA inData) -> IO_PRIORITY_HINT #DISPATCH_LEVEL
FltGetIoPriorityHintFromCallbackData(PFLT_CALLBACK_DATA inData) -> IO_PRIORITY_HINT #DISPATCH_LEVEL
FltGetIoPriorityHintFromFileObject(PFILE_OBJECT inFileObject) -> IO_PRIORITY_HINT #DISPATCH_LEVEL
FltGetIoPriorityHintFromThread(PETHREAD inThread) -> IO_PRIORITY_HINT #DISPATCH_LEVEL
FltGetLowerInstance(PFLT_INSTANCE inCurrentInstance, PFLT_INSTANCE *LowerInstance) -> NTSTATUS #APC_LEVEL
FltGetNewSystemBufferAddress(PFLT_CALLBACK_DATA inCallbackData) -> PVOID #DPC_LEVEL
FltGetNextExtraCreateParameter(PFLT_FILTER inFilter, PECP_LIST inEcpList, PVOID inCurrentEcpContext, LPGUID outNextEcpType, PVOID *NextEcpContext, ULONG out*NextEcpContextSize) -> NTSTATUS #APC_LEVEL
FltGetRequestorProcess(PFLT_CALLBACK_DATA inCallbackData) -> PEPROCESS #DISPATCH_LEVEL
FltGetRequestorProcessId(PFLT_CALLBACK_DATA inCallbackData) -> ULONG #DISPATCH_LEVEL
FltGetRequestorProcessIdEx(PFLT_CALLBACK_DATA inCallbackData) -> HANDLE #DISPATCH_LEVEL
FltGetRequestorSessionId(PFLT_CALLBACK_DATA inCallbackData, PULONG outSessionId ) -> NTSTATUS #APC_LEVEL
FltGetRoutineAddress(PCSTR inFltMgrRoutineName) -> PVOID #APC_LEVEL
FltGetStreamContext(PFLT_INSTANCE inInstance, PFILE_OBJECT inFileObject, PFLT_CONTEXT *Context) -> NTSTATUS #APC_LEVEL
FltGetStreamHandleContext(PFLT_INSTANCE inInstance, PFILE_OBJECT inFileObject, PFLT_CONTEXT *Context) -> NTSTATUS #APC_LEVEL
FltGetTopInstance(PFLT_VOLUME inVolume, PFLT_INSTANCE *Instance) -> NTSTATUS #APC_LEVEL
FltGetTransactionContext(PFLT_INSTANCE inInstance, PKTRANSACTION inTransaction, PFLT_CONTEXT *Context) -> NTSTATUS #APC_LEVEL
FltGetTunneledName(PFLT_CALLBACK_DATA inCallbackData, PFLT_FILE_NAME_INFORMATION inFileNameInformation, PFLT_FILE_NAME_INFORMATION *RetTunneledFileNameInformation) -> NTSTATUS #APC_LEVEL
FltGetUpperInstance(PFLT_INSTANCE inCurrentInstance, PFLT_INSTANCE *UpperInstance) -> NTSTATUS #APC_LEVEL
FltGetVolumeContext(PFLT_FILTER inFilter, PFLT_VOLUME inVolume, PFLT_CONTEXT *Context) -> NTSTATUS #APC_LEVEL
FltGetVolumeFromDeviceObject(PFLT_FILTER inFilter, PDEVICE_OBJECT inDeviceObject, PFLT_VOLUME *RetVolume) -> NTSTATUS #APC_LEVEL
FltGetVolumeFromFileObject(PFLT_FILTER inFilter, PFILE_OBJECT inFileObject, PFLT_VOLUME *RetVolume) -> NTSTATUS #APC_LEVEL
FltGetVolumeFromInstance(PFLT_INSTANCE inInstance, PFLT_VOLUME *RetVolume) -> NTSTATUS #APC_LEVEL
FltGetVolumeFromName(PFLT_FILTER inFilter, PCUNICODE_STRING inVolumeName, PFLT_VOLUME *RetVolume) -> NTSTATUS #PASSIVE_LEVEL
FltGetVolumeGuidName(PFLT_VOLUME inVolume, PUNICODE_STRING outVolumeGuidName, PULONG outBufferSizeNeeded) -> NTSTATUS #PASSIVE_LEVEL
FltGetVolumeInformation(PFLT_VOLUME inVolume, FILTER_VOLUME_INFORMATION_CLASS inInformationClass, PVOID outBuffer, ULONG inBufferSize, PULONG outBytesReturned) -> NTSTATUS #APC_LEVEL
FltGetVolumeInstanceFromName(PFLT_FILTER inFilter, PFLT_VOLUME inVolume, PCUNICODE_STRING inInstanceName, PFLT_INSTANCE *RetInstance) -> NTSTATUS #APC_LEVEL
FltGetVolumeName(PFLT_VOLUME inVolume, PUNICODE_STRING VolumeName, PULONG outBufferSizeNeeded) -> NTSTATUS #APC_LEVEL
FltGetVolumeProperties(PFLT_VOLUME inVolume, PFLT_VOLUME_PROPERTIES outVolumeProperties, ULONG inVolumePropertiesLength, PULONG outLengthReturned) -> NTSTATUS #APC_LEVEL
FltInitExtraCreateParameterLookasideList(PFLT_FILTER inFilter, PVOID ioLookaside, FSRTL_ECP_LOOKASIDE_FLAGS inFlags, SIZE_T inSize, ULONG inTag) -> VOID #APC_LEVEL
FltInitializeOplock(POPLOCK outOplock) -> VOID #APC_LEVEL
FltInitializePushLock(PEX_PUSH_LOCK outPushLock) -> VOID #APC_LEVEL
FltInsertExtraCreateParameter(PFLT_FILTER inFilter, PECP_LIST ioEcpList, PVOID ioEcpContext) -> NTSTATUS #APC_LEVEL
FltIs32bitProcess(PFLT_CALLBACK_DATA inCallbackData) -> BOOLEAN #DISPATCH_LEVEL
FltIsDirectory(PFILE_OBJECT inFileObject, PFLT_INSTANCE inInstance, PBOOLEAN outIsDirectory) -> NTSTATUS #APC_LEVEL
FltIsEcpAcknowledged(PFLT_FILTER inFilter, PVOID inEcpContext) -> BOOLEAN #APC_LEVEL
FltIsEcpFromUserMode(PFLT_FILTER inFilter, PVOID inEcpContext) -> BOOLEAN #APC_LEVEL
FltIsFltMgrVolumeDeviceObject(PDEVICE_OBJECT inDeviceObject) -> BOOLEAN #APC_LEVEL
FltIsIoRedirectionAllowed(PFLT_INSTANCE inSourceInstance, PFLT_INSTANCE inTargetInstance, PBOOLEAN outRedirectionAllowed ) -> NTSTATUS #DISPATCH_LEVEL
FltIsIoRedirectionAllowedForOperation(PFLT_CALLBACK_DATA inData, PFLT_INSTANCE inTargetInstance, PBOOLEAN outRedirectionAllowedThisIo, PBOOLEAN outRedirectionAllowedAllIo ) -> NTSTATUS #DISPATCH_LEVEL
FltIsVolumeSnapshot(PVOID inFltObject, PBOOLEAN outIsSnapshotVolume) -> NTSTATUS #PASSIVE_LEVEL
FltIsVolumeWritable(PVOID inFltObject, PBOOLEAN outIsWritable) -> NTSTATUS #PASSIVE_LEVEL
FltLoadFilter(PCUNICODE_STRING inFilterName) -> NTSTATUS #PASSIVE_LEVEL
FltLockUserBuffer(PFLT_CALLBACK_DATA inCallbackData) -> NTSTATUS #APC_LEVEL
FltNotifyFilterChangeDirectory(PNOTIFY_SYNC ioNotifySync, PLIST_ENTRY ioNotifyList, PVOID inFsContext, PSTRING inFullDirectoryName, BOOLEAN inWatchTree, BOOLEAN inIgnoreBuffer, ULONG inCompletionFilter, PFLT_CALLBACK_DATA inNotifyCallbackData, PCHECK_FOR_TRAVERSE_ACCESS inTraverseCallback, PSECURITY_SUBJECT_CONTEXT inSubjectContext, PFILTER_REPORT_CHANGE inFilterCallback) -> VOID #APC_LEVEL
FltObjectDereference(PVOID ioFltObject) -> VOID #DISPATCH_LEVEL
FltObjectReference(PVOID ioFltObject) -> NTSTATUS #DISPATCH_LEVEL
FltOpenVolume(PFLT_INSTANCE inInstance, PHANDLE outVolumeHandle, PFILE_OBJECT *VolumeFileObject) -> NTSTATUS #PASSIVE_LEVEL
FltOplockBreakH(POPLOCK inOplock, PFLT_CALLBACK_DATA inCallbackData, ULONG inFlags, PVOID inContext, PFLTOPLOCK_WAIT_COMPLETE_ROUTINE inWaitCompletionRoutine, PFLTOPLOCK_PREPOST_CALLBACKDATA_ROUTINE inPrePostCallbackDataRoutine) -> FLT_PREOP_CALLBACK_STATUS #APC_LEVEL
FltOplockBreakToNone(POPLOCK inOplock, PFLT_CALLBACK_DATA inCallbackData, PVOID inContext, PFLTOPLOCK_WAIT_COMPLETE_ROUTINE inWaitCompletionRoutine, PFLTOPLOCK_PREPOST_CALLBACKDATA_ROUTINE inPrePostCallbackDataRoutine) -> FLT_PREOP_CALLBACK_STATUS #APC_LEVEL
FltOplockBreakToNoneEx(POPLOCK inOplock, PFLT_CALLBACK_DATA inCallbackData, ULONG inFlags, PVOID inContext, PFLTOPLOCK_WAIT_COMPLETE_ROUTINE inWaitCompletionRoutine, PFLTOPLOCK_PREPOST_CALLBACKDATA_ROUTINE inPrePostCallbackDataRoutine) -> FLT_PREOP_CALLBACK_STATUS #APC_LEVEL
FltOplockFsctrl(POPLOCK inOplock, PFLT_CALLBACK_DATA inCallbackData, ULONG inOpenCount) -> FLT_PREOP_CALLBACK_STATUS #APC_LEVEL
FltOplockFsctrlEx(POPLOCK inOplock, PFLT_CALLBACK_DATA inCallbackData, ULONG inOpenCount, ULONG inFlags) -> FLT_PREOP_CALLBACK_STATUS #APC_LEVEL
FltOplockIsFastIoPossible(POPLOCK inOplock) -> BOOLEAN #APC_LEVEL
FltOplockIsSharedRequest(PFLT_CALLBACK_DATA inCallbackData) -> BOOLEAN #APC_LEVEL
FltParseFileName(PCUNICODE_STRING inFileName, PUNICODE_STRING Extension, PUNICODE_STRING Stream, PUNICODE_STRING FinalComponent) -> NTSTATUS #APC_LEVEL
FltParseFileNameInformation(PFLT_FILE_NAME_INFORMATION ioFileNameInformation) -> NTSTATUS #APC_LEVEL
FltPerformAsynchronousIo(PFLT_CALLBACK_DATA ioCallbackData, PFLT_COMPLETED_ASYNC_IO_CALLBACK inCallbackRoutine, PVOID inCallbackContext) -> NTSTATUS # PASSIVE_LEVEL
FltPerformSynchronousIo(PFLT_CALLBACK_DATA ioCallbackData) -> VOID # PASSIVE_LEVEL
FltPrePrepareComplete(PFLT_INSTANCE inInstance, PKTRANSACTION inTransaction, PFLT_CONTEXT inTransactionContext) -> NTSTATUS #APC_LEVEL
FltPrepareComplete(PFLT_INSTANCE inInstance, PKTRANSACTION inTransaction, PFLT_CONTEXT inTransactionContext) -> NTSTATUS #APC_LEVEL
FltProcessFileLock(PFILE_LOCK inFileLock, PFLT_CALLBACK_DATA inCallbackData, PVOID inContext) -> FLT_PREOP_CALLBACK_STATUS #APC_LEVEL
FltPurgeFileNameInformationCache(PFLT_INSTANCE inInstance, PFILE_OBJECT inFileObject) -> NTSTATUS #APC_LEVEL
FltQueryDirectoryFile(PFLT_INSTANCE inInstance, PFILE_OBJECT inFileObject, PVOID FileInformation, ULONG inLength, FILE_INFORMATION_CLASS inFileInformationClass, BOOLEAN inReturnSingleEntry, PUNICODE_STRING inFileName, BOOLEAN inRestartScan, PULONG outLengthReturned) -> NTSTATUS #PASSIVE_LEVEL
FltQueryEaFile(PFLT_INSTANCE inInstance, PFILE_OBJECT inFileObject, PVOID ReturnedEaData, ULONG inLength, BOOLEAN inReturnSingleEntry, PVOID inEaList, ULONG inEaListLength, PULONG inEaIndex, BOOLEAN inRestartScan, PULONG outLengthReturned) -> NTSTATUS #PASSIVE_LEVEL
FltQueryInformationFile(PFLT_INSTANCE inInstance, PFILE_OBJECT inFileObject, PVOID FileInformation, ULONG inLength, FILE_INFORMATION_CLASS inFileInformationClass, PULONG outLengthReturned) -> NTSTATUS #PASSIVE_LEVEL
FltQuerySecurityObject(PFLT_INSTANCE inInstance, PFILE_OBJECT inFileObject, SECURITY_INFORMATION inSecurityInformation, PSECURITY_DESCRIPTOR ioSecurityDescriptor, ULONG inLength, PULONG outLengthNeeded) -> NTSTATUS #PASSIVE_LEVEL
FltQueryVolumeInformation(PFLT_INSTANCE inInstance, PIO_STATUS_BLOCK outIosb, PVOID FsInformation, ULONG inLength, FS_INFORMATION_CLASS inFsInformationClass) -> NTSTATUS #PASSIVE_LEVEL
FltQueryVolumeInformationFile(PFLT_INSTANCE inInstance, PFILE_OBJECT inFileObject, PVOID FsInformation, ULONG inLength, FS_INFORMATION_CLASS inFsInformationClass, PULONG outLengthReturned) -> NTSTATUS #PASSIVE_LEVEL
FltQueueDeferredIoWorkItem(PFLT_DEFERRED_IO_WORKITEM inFltWorkItem, PFLT_CALLBACK_DATA inData, PFLT_DEFERRED_IO_WORKITEM_ROUTINE inWorkerRoutine, WORK_QUEUE_TYPE inQueueType, PVOID inContext) -> NTSTATUS #DISPATCH_LEVEL
FltQueueGenericWorkItem(PFLT_GENERIC_WORKITEM inFltWorkItem, PVOID inFltObject, PFLT_GENERIC_WORKITEM_ROUTINE inWorkerRoutine, WORK_QUEUE_TYPE inQueueType, PVOID inContext) -> NTSTATUS #DISPATCH_LEVEL
FltReadFile(PFLT_INSTANCE inInitiatingInstance, PFILE_OBJECT inFileObject, PLARGE_INTEGER inByteOffset, ULONG inLength, PVOID Buffer, FLT_IO_OPERATION_FLAGS inFlags, PULONG outBytesRead, PFLT_COMPLETED_ASYNC_IO_CALLBACK inCallbackRoutine, PVOID inCallbackContext) -> NTSTATUS # APC_LEVEL
FltReadFile(PFLT_INSTANCE inInitiatingInstance, PFILE_OBJECT inFileObject, PLARGE_INTEGER inByteOffset, ULONG inLength, PVOID Buffer, FLT_IO_OPERATION_FLAGS inFlags, PULONG outBytesRead, PFLT_COMPLETED_ASYNC_IO_CALLBACK inCallbackRoutine, PVOID inCallbackContext) -> NTSTATUS #PASSIVE_LEVEL
FltReferenceContext(PFLT_CONTEXT inContext) -> VOID #DISPATCH_LEVEL
FltReferenceFileNameInformation(PFLT_FILE_NAME_INFORMATION inFileNameInformation) -> VOID #APC_LEVEL
FltRegisterFilter(PDRIVER_OBJECT inDriver, CONST inFLT_REGISTRATION *Registration, PFLT_FILTER *RetFilter) -> NTSTATUS #APC_LEVEL
FltReissueSynchronousIo(PFLT_INSTANCE inInitiatingInstance, PFLT_CALLBACK_DATA inCallbackData) -> VOID # APC_LEVEL
FltReissueSynchronousIo(PFLT_INSTANCE inInitiatingInstance, PFLT_CALLBACK_DATA inCallbackData) -> VOID #PASSIVE_LEVEL
FltReleaseContext(PFLT_CONTEXT inContext) -> VOID #DISPATCH_LEVEL
FltReleaseContexts(PFLT_RELATED_CONTEXTS inContexts) -> VOID #APC_LEVEL
FltReleaseFileNameInformation(PFLT_FILE_NAME_INFORMATION inFileNameInformation) -> VOID #APC_LEVEL
FltReleasePushLock(PEX_PUSH_LOCK ioPushLock) -> VOID #APC_LEVEL
FltReleaseResource(PERESOURCE ioResource) -> VOID #DISPATCH_LEVEL
FltRemoveExtraCreateParameter(PFLT_FILTER inFilter, PECP_LIST ioEcpList, LPCGUID inEcpType, PVOID *EcpContext, ULONG out*EcpContextSize) -> NTSTATUS #APC_LEVEL
FltRequestOperationStatusCallback(PFLT_CALLBACK_DATA inData, PFLT_GET_OPERATION_STATUS_CALLBACK inCallbackRoutine, PVOID inRequesterContext) -> NTSTATUS #DISPATCH_LEVEL
FltRetrieveIoPriorityInfo(PFLT_CALLBACK_DATA inData, PFILE_OBJECT inFileObject, PETHREAD inThread, PIO_PRIORITY_INFO ioPriorityInfo) -> NTSTATUS #DISPATCH_LEVEL
FltReuseCallbackData(PFLT_CALLBACK_DATA ioCallbackData) -> VOID #APC_LEVEL
FltRollbackComplete(PFLT_INSTANCE inInstance, PKTRANSACTION inTransaction, PFLT_CONTEXT inTransactionContext) -> NTSTATUS #PASSIVE_LEVEL
FltRollbackEnlistment(PFLT_INSTANCE inInstance, PKTRANSACTION inTransaction, PFLT_CONTEXT inTransactionContext) -> NTSTATUS #APC_LEVEL
FltSendMessage(PFLT_FILTER inFilter, PFLT_PORT *ClientPort, PVOID SenderBuffer, ULONG inSenderBufferLength, PVOID outReplyBuffer, PULONG ReplyLength, PLARGE_INTEGER inTimeout) -> NTSTATUS #APC_LEVEL
FltSetCancelCompletion(PFLT_CALLBACK_DATA inCallbackData, PFLT_COMPLETE_CANCELED_CALLBACK inCanceledCallback) -> NTSTATUS #DISPATCH_LEVEL
FltSetEaFile(PFLT_INSTANCE inInstance, PFILE_OBJECT inFileObject, PVOID EaBuffer, ULONG inLength) -> NTSTATUS #PASSIVE_LEVEL
FltSetEcpListIntoCallbackData(PFLT_FILTER inFilter, PFLT_CALLBACK_DATA inCallbackData, PECP_LIST inEcpList) -> NTSTATUS #APC_LEVEL
FltSetFileContext(PFLT_INSTANCE inInstance, PFILE_OBJECT inFileObject, FLT_SET_CONTEXT_OPERATION inOperation, PFLT_CONTEXT inNewContext, PFLT_CONTEXT *OldContext) -> NTSTATUS #APC_LEVEL
FltSetInformationFile(PFLT_INSTANCE inInstance, PFILE_OBJECT inFileObject, PVOID FileInformation, ULONG inLength, FILE_INFORMATION_CLASS inFileInformationClass) -> NTSTATUS #PASSIVE_LEVEL
FltSetInstanceContext(PFLT_INSTANCE inInstance, FLT_SET_CONTEXT_OPERATION inOperation, PFLT_CONTEXT inNewContext, PFLT_CONTEXT *OldContext) -> NTSTATUS #APC_LEVEL
FltSetIoPriorityHintIntoCallbackData(PFLT_CALLBACK_DATA inData, IO_PRIORITY_HINT inPriorityHint) -> NTSTATUS #DISPATCH_LEVEL
FltSetIoPriorityHintIntoFileObject(PFILE_OBJECT inFileObject, IO_PRIORITY_HINT inPriorityHint) -> NTSTATUS #DISPATCH_LEVEL
FltSetIoPriorityHintIntoThread(PETHREAD inThread, IO_PRIORITY_HINT inPriorityHint) -> NTSTATUS #DISPATCH_LEVEL
FltSetSecurityObject(PFLT_INSTANCE inInstance, PFILE_OBJECT inFileObject, SECURITY_INFORMATION inSecurityInformation, PSECURITY_DESCRIPTOR inSecurityDescriptor) -> NTSTATUS #PASSIVE_LEVEL
FltSetStreamContext(PFLT_INSTANCE inInstance, PFILE_OBJECT inFileObject, FLT_SET_CONTEXT_OPERATION inOperation, PFLT_CONTEXT inNewContext, PFLT_CONTEXT *OldContext) -> NTSTATUS #APC_LEVEL
FltSetStreamHandleContext(PFLT_INSTANCE inInstance, PFILE_OBJECT inFileObject, FLT_SET_CONTEXT_OPERATION inOperation, PFLT_CONTEXT inNewContext, PFLT_CONTEXT *OldContext) -> NTSTATUS #APC_LEVEL
FltSetTransactionContext(PFLT_INSTANCE inInstance, PKTRANSACTION inTransaction, FLT_SET_CONTEXT_OPERATION inOperation, PFLT_CONTEXT inNewContext, PFLT_CONTEXT *OldContext) -> NTSTATUS #APC_LEVEL
FltSetVolumeContext(PFLT_VOLUME inVolume, FLT_SET_CONTEXT_OPERATION inOperation, PFLT_CONTEXT inNewContext, PFLT_CONTEXT *OldContext) -> NTSTATUS #APC_LEVEL
FltSetVolumeInformation(PFLT_INSTANCE inInstance, PIO_STATUS_BLOCK outIosb, PVOID FsInformation, ULONG inLength, FS_INFORMATION_CLASS inFsInformationClass) -> NTSTATUS #PASSIVE_LEVEL
FltStartFiltering(PFLT_FILTER inFilter) -> NTSTATUS #APC_LEVEL
FltSupportsFileContexts(PFILE_OBJECT inFileObject) -> BOOLEAN #APC_LEVEL
FltSupportsFileContextsEx(PFILE_OBJECT inFileObject, PFLT_INSTANCE inInstance) -> BOOLEAN #APC_LEVEL
FltSupportsStreamContexts(PFILE_OBJECT inFileObject) -> BOOLEAN #APC_LEVEL
FltSupportsStreamHandleContexts(PFILE_OBJECT inFileObject) -> BOOLEAN #APC_LEVEL
FltTagFile(PFLT_INSTANCE inInitiatingInstance, PFILE_OBJECT inFileObject, ULONG inFileTag, inGUID *Guid, PVOID DataBuffer, USHORT inDataBufferLength) -> NTSTATUS #PASSIVE_LEVEL
FltUninitializeOplock(POPLOCK inOplock) -> VOID #APC_LEVEL
FltUnloadFilter(PCUNICODE_STRING inFilterName) -> NTSTATUS #PASSIVE_LEVEL
FltUnregisterFilter(PFLT_FILTER inFilter) -> VOID #APC_LEVEL
FltUntagFile(PFLT_INSTANCE inInitiatingInstance, PFILE_OBJECT inFileObject, ULONG inFileTag, inGUID *Guid) -> NTSTATUS #PASSIVE_LEVEL
FltWriteFile(PFLT_INSTANCE inInitiatingInstance, PFILE_OBJECT inFileObject, PLARGE_INTEGER inByteOffset, ULONG inLength, PVOID Buffer, FLT_IO_OPERATION_FLAGS inFlags, PULONG outBytesWritten, PFLT_COMPLETED_ASYNC_IO_CALLBACK inCallbackRoutine, PVOID inCallbackContext) -> NTSTATUS # APC_LEVEL
FltWriteFile(PFLT_INSTANCE inInitiatingInstance, PFILE_OBJECT inFileObject, PLARGE_INTEGER inByteOffset, ULONG inLength, PVOID Buffer, FLT_IO_OPERATION_FLAGS inFlags, PULONG outBytesWritten, PFLT_COMPLETED_ASYNC_IO_CALLBACK inCallbackRoutine, PVOID inCallbackContext) -> NTSTATUS #PASSIVE_LEVEL
FreeIprBuff(inIPRcvBuf *pRcvBuf) -> ) FreeIprBuff #DISPATCH_LEVEL
FsRtlAcknowledgeEcp(PVOID inEcpContext) -> VOID #APC_LEVEL
FsRtlAcquireFileExclusive(PFILE_OBJECT inFileObject) -> VOID #PASSIVE_LEVEL
FsRtlAddBaseMcbEntry(PBASE_MCB inMcb, LONGLONG inVbn, LONGLONG inLbn, LONGLONG inSectorCount) -> BOOLEAN #APC_LEVEL
FsRtlAddBaseMcbEntryEx(PBASE_MCB inMcb, LONGLONG inVbn, LONGLONG inLbn, LONGLONG inSectorCount) -> NTSTATUS #APC_LEVEL
FsRtlAddLargeMcbEntry(PLARGE_MCB inMcb, LONGLONG inVbn, LONGLONG inLbn, LONGLONG inSectorCount) -> BOOLEAN #APC_LEVEL
FsRtlAddMcbEntry(PMCB inMcb, VBN inVbn, LBN inLbn, ULONG inSectorCount) -> BOOLEAN #APC_LEVEL
FsRtlAddToTunnelCache(inTUNNEL *Cache, ULONGLONG inDirectoryKey, inUNICODE_STRING *ShortName, inUNICODE_STRING *LongName, BOOLEAN inKeyByShortName, ULONG inDataLength, VOID *Data) -> VOID #APC_LEVEL
FsRtlAllocateExtraCreateParameter(LPCGUID inEcpType, ULONG inSizeOfContext, FSRTL_ALLOCATE_ECP_FLAGS inFlags, PFSRTL_EXTRA_CREATE_PARAMETER_CLEANUP_CALLBACK inCleanupCallback, ULONG inPoolTag, PVOID *EcpContext) -> NTSTATUS #APC_LEVEL
FsRtlAllocateExtraCreateParameterFromLookasideList(LPCGUID inEcpType, ULONG inSizeOfContext, FSRTL_ALLOCATE_ECP_FLAGS inFlags, PFSRTL_EXTRA_CREATE_PARAMETER_CLEANUP_CALLBACK inCleanupCallback, PVOID ioLookasideList, PVOID *EcpContext) -> NTSTATUS #APC_LEVEL
FsRtlAllocateExtraCreateParameterList(FSRTL_ALLOCATE_ECPLIST_FLAGS inFlags, PECP_LIST *EcpList) -> NTSTATUS #APC_LEVEL
FsRtlAllocateFileLock(PCOMPLETE_LOCK_IRP_ROUTINE inCompleteLockIrpRoutine, PUNLOCK_ROUTINE inUnlockRoutine) -> PFILE_LOCK #APC_LEVEL
FsRtlAllocateResource(VOID) -> The #APC_LEVEL
FsRtlAreNamesEqual(PCUNICODE_STRING inConstantNameA, PCUNICODE_STRING inConstantNameB, BOOLEAN inIgnoreCase, PCWCH inUpcaseTable) -> BOOLEAN #PASSIVE_LEVEL
FsRtlAreThereCurrentOrInProgressFileLocks(PFILE_LOCK inFileLock) -> BOOLEAN #APC_LEVEL
FsRtlAreVolumeStartupApplicationsComplete(VOID) -> BOOLEAN #APC_LEVEL
FsRtlBalanceReads(PDEVICE_OBJECT inTargetDevice) -> NTSTATUS #PASSIVE_LEVEL
FsRtlCancellableWaitForMultipleObjects(ULONG inCount, PVOID ObjectArray[], WAIT_TYPE inWaitType, PLARGE_INTEGER inTimeout, PKWAIT_BLOCK inWaitBlockArray, PIRP inIrp) -> NTSTATUS # APC_LEVEL
FsRtlCancellableWaitForSingleObject(PVOID inObject, PLARGE_INTEGER inTimeout, PIRP inIrp) -> NTSTATUS # APC_LEVEL
FsRtlChangeBackingFileObject(PFILE_OBJECT inCurrentFileObject, PFILE_OBJECT inNewFileObject, FSRTL_CHANGE_BACKING_TYPE inChangeBackingType, ULONG inFlags #reserved, must be zero) -> NTSTATUS //PASSIVE_LEVEL
FsRtlCheckLockForReadAccess(PFILE_LOCK inFileLock, PIRP inIrp) -> BOOLEAN #APC_LEVEL
FsRtlCheckLockForWriteAccess(PFILE_LOCK inFileLock, PIRP inIrp) -> BOOLEAN #APC_LEVEL
FsRtlCheckOplock(POPLOCK inOplock, PIRP inIrp, PVOID inContext, POPLOCK_WAIT_COMPLETE_ROUTINE inCompletionRoutine, POPLOCK_FS_PREPOST_IRP inPostIrpRoutine) -> NTSTATUS #APC_LEVEL
FsRtlCheckOplockEx(POPLOCK inOplock, PIRP inIrp, ULONG inFlags, PVOID inContext, POPLOCK_WAIT_COMPLETE_ROUTINE inCompletionRoutine, POPLOCK_FS_PREPOST_IRP inPostIrpRoutine) -> NTSTATUS #APC_LEVEL
FsRtlCopyRead(PFILE_OBJECT inFileObject, PLARGE_INTEGER inFileOffset, ULONG inLength, BOOLEAN inWait, ULONG inLockKey, PVOID Buffer, PIO_STATUS_BLOCK outIoStatus, PDEVICE_OBJECT inDeviceObject) -> BOOLEAN #PASSIVE_LEVEL
FsRtlCopyWrite(PFILE_OBJECT inFileObject, PLARGE_INTEGER inFileOffset, ULONG inLength, BOOLEAN inWait, ULONG inLockKey, PVOID Buffer, PIO_STATUS_BLOCK outIoStatus, PDEVICE_OBJECT inDeviceObject) -> BOOLEAN #PASSIVE_LEVEL
FsRtlCreateSectionForDataScan(PHANDLE outSectionHandle, PVOID *SectionObject, PLARGE_INTEGER outSectionFileSize, PFILE_OBJECT inFileObject, ACCESS_MASK inDesiredAccess, POBJECT_ATTRIBUTES inObjectAttributes, PLARGE_INTEGER inMaximumSize, ULONG inSectionPageProtection, ULONG inAllocationAttributes, ULONG inFlags) -> NTSTATUS #APC_LEVEL
FsRtlCurrentBatchOplock(POPLOCK inOplock) -> BOOLEAN #APC_LEVEL
FsRtlCurrentOplock(POPLOCK inOplock) -> BOOLEAN #APC_LEVEL
FsRtlCurrentOplockH(POPLOCK inOplock) -> BOOLEAN #APC_LEVEL
FsRtlDeleteExtraCreateParameterLookasideList(PVOID ioLookaside, FSRTL_ECP_LOOKASIDE_FLAGS inFlags) -> VOID # APC_LEVEL
FsRtlDeleteKeyFromTunnelCache(inTUNNEL *Cache, ULONGLONG inDirectoryKey) -> VOID #APC_LEVEL
FsRtlDeleteTunnelCache(inTUNNEL *Cache) -> VOID #APC_LEVEL
FsRtlDeregisterUncProvider(HANDLE inHandle) -> VOID #PASSIVE_LEVEL
FsRtlDissectDbcs(ANSI_STRING inPath, PANSI_STRING outFirstName, PANSI_STRING outRemainingName) -> VOID #APC_LEVEL
FsRtlDissectName(UNICODE_STRING inPath, PUNICODE_STRING outFirstName, PUNICODE_STRING outRemainingName) -> VOID #PASSIVE_LEVEL
FsRtlDoesDbcsContainWildCards(PANSI_STRING inName) -> BOOLEAN #APC_LEVEL
FsRtlDoesNameContainWildCards(PUNICODE_STRING inName) -> BOOLEAN #PASSIVE_LEVEL
FsRtlFastCheckLockForRead(PFILE_LOCK inFileLock, PLARGE_INTEGER inStartingByte, PLARGE_INTEGER inLength, ULONG inKey, PFILE_OBJECT inFileObject, PVOID inProcessId) -> BOOLEAN #APC_LEVEL
FsRtlFastCheckLockForWrite(PFILE_LOCK inFileLock, PLARGE_INTEGER inStartingByte, PLARGE_INTEGER inLength, ULONG inKey, PVOID inFileObject, PVOID inProcessId) -> BOOLEAN #APC_LEVEL
FsRtlFastUnlockAll(PFILE_LOCK inFileLock, PFILE_OBJECT inFileObject, PEPROCESS inProcessId, PVOID inContext) -> NTSTATUS #APC_LEVEL
FsRtlFastUnlockAllByKey(PFILE_LOCK inFileLock, PFILE_OBJECT inFileObject, PEPROCESS inProcessId, ULONG inKey, PVOID inContext) -> NTSTATUS #APC_LEVEL
FsRtlFastUnlockSingle(PFILE_LOCK inFileLock, PFILE_OBJECT inFileObject, LARGE_INTEGER inUNALIGNED *FileOffset, PLARGE_INTEGER inLength, PEPROCESS inProcessId, ULONG inKey, PVOID inContext, BOOLEAN inAlreadySynchronized) -> NTSTATUS #APC_LEVEL
FsRtlFindExtraCreateParameter(PECP_LIST inEcpList, LPCGUID inEcpType, PVOID *EcpContext, ULONG out*EcpContextSize) -> NTSTATUS #APC_LEVEL
FsRtlFindInTunnelCache(inTUNNEL *Cache, ULONGLONG inDirectoryKey, inUNICODE_STRING *Name, UNICODE_STRING out*ShortName, UNICODE_STRING out*LongName, ioULONG *DataLength, VOID *Data) -> BOOLEAN #APC_LEVEL
FsRtlFreeExtraCreateParameter(PVOID inEcpContext) -> VOID #APC_LEVEL
FsRtlFreeExtraCreateParameterList(PECP_LIST inEcpList) -> VOID #APC_LEVEL
FsRtlFreeFileLock(PFILE_LOCK inFileLock) -> VOID #APC_LEVEL
FsRtlGetEcpListFromIrp(PIRP inIrp, PECP_LIST *EcpList) -> NTSTATUS #APC_LEVEL
FsRtlGetFileSize(PFILE_OBJECT inFileObject, PLARGE_INTEGER outFileSize) -> NTSTATUS #PASSIVE_LEVEL
FsRtlGetNextBaseMcbEntry(PBASE_MCB inMcb, ULONG inRunIndex, PLONGLONG outVbn, PLONGLONG outLbn, PLONGLONG outSectorCount) -> BOOLEAN #APC_LEVEL
FsRtlGetNextExtraCreateParameter(PECP_LIST inEcpList, PVOID inCurrentEcpContext, LPGUID outNextEcpType, PVOID *NextEcpContext, ULONG out*NextEcpContextSize) -> NTSTATUS #APC_LEVEL
FsRtlGetNextFileLock(PFILE_LOCK inFileLock, BOOLEAN inRestart) -> PFILE_LOCK_INFO #APC_LEVEL
FsRtlGetNextLargeMcbEntry(PLARGE_MCB inMcb, ULONG inRunIndex, PLONGLONG outVbn, PLONGLONG outLbn, PLONGLONG outSectorCount) -> BOOLEAN #APC_LEVEL
FsRtlGetNextMcbEntry(PMCB inMcb, ULONG inRunIndex, PVBN outVbn, PLBN outLbn, PULONG outSectorCount) -> BOOLEAN #APC_LEVEL
FsRtlInitExtraCreateParameterLookasideList(PVOID ioLookaside, FSRTL_ECP_LOOKASIDE_FLAGS inFlags, SIZE_T inSize, ULONG inTag) -> VOID # APC_LEVEL
FsRtlInitializeBaseMcb(PBASE_MCB inMcb, POOL_TYPE inPoolType) -> VOID #APC_LEVEL
FsRtlInitializeBaseMcbEx(PBASE_MCB inMcb, POOL_TYPE inPoolType, USHORT inFlags) -> BOOLEAN #APC_LEVEL
FsRtlInitializeFileLock(PFILE_LOCK inFileLock, PCOMPLETE_LOCK_IRP_ROUTINE inCompleteLockIrpRoutine, PUNLOCK_ROUTINE inUnlockRoutine) -> VOID #APC_LEVEL
FsRtlInitializeLargeMcb(PLARGE_MCB inMcb, POOL_TYPE inPoolType) -> VOID #APC_LEVEL
FsRtlInitializeMcb(PMCB inMcb, POOL_TYPE inPoolType) -> VOID #APC_LEVEL
FsRtlInitializeOplock(POPLOCK ioOplock) -> VOID #APC_LEVEL
FsRtlInitializeTunnelCache(inTUNNEL *Cache) -> VOID #APC_LEVEL
FsRtlInsertExtraCreateParameter(PECP_LIST ioEcpList, PVOID ioEcpContext) -> NTSTATUS #APC_LEVEL
FsRtlInsertPerFileContext(PVOID* inPerFileContextPointer, PFSRTL_PER_FILE_CONTEXT inPtr) -> NTSTATUS #APC_LEVEL
FsRtlInsertPerFileObjectContext(PFILE_OBJECT inFileObject, PFSRTL_PER_FILEOBJECT_CONTEXT inPtr) -> NTSTATUS #APC_LEVEL
FsRtlInsertPerStreamContext(PFSRTL_ADVANCED_FCB_HEADER inPerStreamContext, PFSRTL_PER_STREAM_CONTEXT inPtr) -> NTSTATUS #APC_LEVEL
FsRtlIsDbcsInExpression(PANSI_STRING inExpression, PANSI_STRING inName) -> BOOLEAN #APC_LEVEL
FsRtlIsEcpAcknowledged(PVOID inEcpContext) -> BOOLEAN #APC_LEVEL
FsRtlIsEcpFromUserMode(PVOID inEcpContext) -> BOOLEAN #APC_LEVEL
FsRtlIsFatDbcsLegal(ANSI_STRING inDbcsName, BOOLEAN inWildCardsPermissible, BOOLEAN inPathNamePermissible, BOOLEAN inLeadingBackslashPermissible) -> BOOLEAN #APC_LEVEL
FsRtlIsHpfsDbcsLegal(ANSI_STRING inDbcsName, BOOLEAN inWildCardsPermissible, BOOLEAN inPathNamePermissible, BOOLEAN inLeadingBackslashPermissible) -> BOOLEAN #APC_LEVEL
FsRtlIsNameInExpression(PUNICODE_STRING inExpression, PUNICODE_STRING inName, BOOLEAN inIgnoreCase, PWCH inUpcaseTable) -> BOOLEAN #PASSIVE_LEVEL
FsRtlIsPagingFile(PFILE_OBJECT inFileObject) -> LOGICAL #APC_LEVEL
FsRtlLogCcFlushError(PUNICODE_STRING inFileName, PDEVICE_OBJECT inDeviceObject, PSECTION_OBJECT_POINTERS inSectionObjectPointer, NTSTATUS inFlushError, ULONG inFlags) -> NTSTATUS #APC_LEVEL
FsRtlLookupBaseMcbEntry(PBASE_MCB inMcb, LONGLONG inVbn, PLONGLONG outLbn, PLONGLONG outSectorCountFromLbn, PLONGLONG outStartingLbn, PLONGLONG outSectorCountFromStartingLbn, PULONG outIndex) -> BOOLEAN #APC_LEVEL
FsRtlLookupLargeMcbEntry(PLARGE_MCB inMcb, LONGLONG inVbn, PLONGLONG outLbn, PLONGLONG outSectorCountFromLbn, PLONGLONG outStartingLbn, PLONGLONG outSectorCountFromStartingLbn, PULONG outIndex) -> BOOLEAN #APC_LEVEL
FsRtlLookupLastBaseMcbEntry(PBASE_MCB inMcb, PLONGLONG outVbn, PLONGLONG outLbn) -> BOOLEAN #APC_LEVEL
FsRtlLookupLastBaseMcbEntryAndIndex(PBASE_MCB inOpaqueMcb, PLONGLONG ioLargeVbn, PLONGLONG ioLargeLbn, PULONG ioIndex) -> BOOLEAN #APC_LEVEL
FsRtlLookupLastLargeMcbEntry(PLARGE_MCB inMcb, PLONGLONG outVbn, PLONGLONG outLbn) -> BOOLEAN #APC_LEVEL
FsRtlLookupLastLargeMcbEntryAndIndex(PLARGE_MCB inOpaqueMcb, PLONGLONG outLargeVbn, PLONGLONG outLargeLbn, PULONG outIndex) -> BOOLEAN #APC_LEVEL
FsRtlLookupLastMcbEntry(PMCB inMcb, PVBN outVbn, PLBN outLbn) -> BOOLEAN #APC_LEVEL
FsRtlLookupMcbEntry(PMCB inMcb, VBN inVbn, PLBN outLbn, PULONG outSectorCount, PULONG outIndex) -> BOOLEAN #APC_LEVEL
FsRtlLookupPerFileContext(PVOID* inPerFileContextPointer, PVOID inOwnerId, PVOID inInstanceId) -> PFSRTL_PER_FILE_CONTEXT #APC_LEVEL
FsRtlLookupPerFileObjectContext(PFILE_OBJECT inFileObject, PVOID inOwnerId, PVOID inInstanceId) -> PFSRTL_PER_FILEOBJECT_CONTEXT #APC_LEVEL
FsRtlLookupPerStreamContextInternal(PFSRTL_ADVANCED_FCB_HEADER inStreamContext, PVOID inOwnerId, PVOID inInstanceId) -> PFSRTL_PER_STREAM_CONTEXT #APC_LEVEL
FsRtlMdlReadCompleteDev(PFILE_OBJECT inFileObject, PMDL inMdlChain, PDEVICE_OBJECT inDeviceObject) -> BOOLEAN #PASSIVE_LEVEL
FsRtlMdlReadDev(PFILE_OBJECT inFileObject, PLARGE_INTEGER inFileOffset, ULONG inLength, ULONG inLockKey, PMDL *MdlChain, PIO_STATUS_BLOCK outIoStatus, PDEVICE_OBJECT inDeviceObject) -> BOOLEAN #APC_LEVEL
FsRtlMdlWriteCompleteDev(PFILE_OBJECT inFileObject, PLARGE_INTEGER inFileOffset, PMDL inMdlChain, PDEVICE_OBJECT inDeviceObject) -> BOOLEAN #PASSIVE_LEVEL
FsRtlMupGetProviderIdFromName(PUNICODE_STRING inpProviderName, PULONG32 outpProviderId) -> NTSTATUS #APC_LEVEL
FsRtlMupGetProviderInfoFromFileObject(PFILE_OBJECT inpFileObject, ULONG inLevel, PVOID pBuffer, PULONG iopBufferSize) -> NTSTATUS #APC_LEVEL
FsRtlNotifyCleanup(PNOTIFY_SYNC inNotifySync, PLIST_ENTRY inNotifyList, PVOID inFsContext) -> VOID #APC_LEVEL
FsRtlNotifyCleanupAll(PNOTIFY_SYNC inNotifySync, PLIST_ENTRY inNotifyList) -> VOID #APC_LEVEL
FsRtlNotifyFilterChangeDirectory(PNOTIFY_SYNC inNotifySync, PLIST_ENTRY inNotifyList, PVOID inFsContext, PSTRING inFullDirectoryName, BOOLEAN inWatchTree, BOOLEAN inIgnoreBuffer, ULONG inCompletionFilter, PIRP inNotifyIrp, PCHECK_FOR_TRAVERSE_ACCESS inTraverseCallback, PSECURITY_SUBJECT_CONTEXT inSubjectContext, PFILTER_REPORT_CHANGE inFilterCallback) -> VOID #PASSIVE_LEVEL
FsRtlNotifyFilterReportChange(PNOTIFY_SYNC inNotifySync, PLIST_ENTRY inNotifyList, PSTRING inFullTargetName, USHORT inTargetNameOffset, PSTRING inStreamName, PSTRING inNormalizedParentName, ULONG inFilterMatch, ULONG inAction, PVOID inTargetContext, PVOID inFilterContext) -> VOID #PASSIVE_LEVEL
FsRtlNotifyFullChangeDirectory(PNOTIFY_SYNC inNotifySync, PLIST_ENTRY inNotifyList, PVOID inFsContext, PSTRING inFullDirectoryName, BOOLEAN inWatchTree, BOOLEAN inIgnoreBuffer, ULONG inCompletionFilter, PIRP inNotifyIrp, PCHECK_FOR_TRAVERSE_ACCESS inTraverseCallback, PSECURITY_SUBJECT_CONTEXT inSubjectContext) -> VOID #PASSIVE_LEVEL
FsRtlNotifyFullReportChange(PNOTIFY_SYNC inNotifySync, PLIST_ENTRY inNotifyList, PSTRING inFullTargetName, USHORT inTargetNameOffset, PSTRING inStreamName, PSTRING inNormalizedParentName, ULONG inFilterMatch, ULONG inAction, PVOID inTargetContext) -> VOID #PASSIVE_LEVEL
FsRtlNotifyInitializeSync(inPNOTIFY_SYNC *NotifySync) -> VOID #APC_LEVEL
FsRtlNotifyUninitializeSync(inPNOTIFY_SYNC *NotifySync) -> VOID #APC_LEVEL
FsRtlNotifyVolumeEvent(PFILE_OBJECT inFileObject, ULONG inEventCode) -> NTSTATUS #APC_LEVEL
FsRtlNotifyVolumeEventEx(PFILE_OBJECT inFileObject, ULONG inEventCode, PTARGET_DEVICE_CUSTOM_NOTIFICATION inEvent) -> NTSTATUS #DISPATCH_LEVEL
FsRtlNumberOfRunsInBaseMcb(PBASE_MCB inMcb) -> ULONG #APC_LEVEL
FsRtlNumberOfRunsInLargeMcb(PLARGE_MCB inMcb) -> ULONG #APC_LEVEL
FsRtlNumberOfRunsInMcb(PMCB inMcb) -> ULONG #APC_LEVEL
FsRtlOplockBreakH(POPLOCK inOplock, PIRP inIrp, ULONG inFlags, PVOID inContext, POPLOCK_WAIT_COMPLETE_ROUTINE inCompletionRoutine, POPLOCK_FS_PREPOST_IRP inPostIrpRoutine) -> NTSTATUS #APC_LEVEL
FsRtlOplockBreakToNone(POPLOCK ioOplock, PIO_STACK_LOCATION inIrpSp, PIRP inIrp, PVOID inContext, POPLOCK_WAIT_COMPLETE_ROUTINE inCompletionRoutine, POPLOCK_FS_PREPOST_IRP inPostIrpRoutine) -> NTSTATUS #APC_LEVEL
FsRtlOplockBreakToNoneEx(POPLOCK ioOplock, PIRP inIrp, ULONG inFlags, PVOID inContext, POPLOCK_WAIT_COMPLETE_ROUTINE inCompletionRoutine, POPLOCK_FS_PREPOST_IRP inPostIrpRoutine) -> NTSTATUS #APC_LEVEL
FsRtlOplockFsctrl(POPLOCK inOplock, PIRP inIrp, ULONG inOpenCount) -> NTSTATUS #APC_LEVEL
FsRtlOplockFsctrlEx(POPLOCK inOplock, PIRP inIrp, ULONG inOpenCount, ULONG inFlags) -> NTSTATUS #APC_LEVEL
FsRtlOplockIsFastIoPossible(POPLOCK inOplock) -> BOOLEAN #APC_LEVEL
FsRtlOplockIsSharedRequest(PIRP inIrp) -> BOOLEAN #APC_LEVEL
FsRtlOplockKeysEqual(PFILE_OBJECT inFo1, PFILE_OBJECT inFo2) -> BOOLEAN #APC_LEVEL
FsRtlPostPagingFileStackOverflow(PVOID inContext, PKEVENT inEvent, PFSRTL_STACK_OVERFLOW_ROUTINE inStackOverflowRoutine) -> VOID #DISPATCH_LEVEL
FsRtlPostStackOverflow(PVOID inContext, PKEVENT inEvent, PFSRTL_STACK_OVERFLOW_ROUTINE inStackOverflowRoutine) -> VOID #DISPATCH_LEVEL
FsRtlPrepareMdlWriteDev(PFILE_OBJECT inFileObject, PLARGE_INTEGER inFileOffset, ULONG inLength, ULONG inLockKey, PMDL *MdlChain, PIO_STATUS_BLOCK outIoStatus, PDEVICE_OBJECT inDeviceObject) -> BOOLEAN #APC_LEVEL
FsRtlPrivateLock(PFILE_LOCK inFileLock, PFILE_OBJECT inFileObject, PLARGE_INTEGER inFileOffset, PLARGE_INTEGER inLength, PEPROCESS inProcessId, ULONG inKey, BOOLEAN inFailImmediately, BOOLEAN inExclusiveLock, PIO_STATUS_BLOCK outIosb, PIRP inIrp, PVOID inContext, BOOLEAN inAlreadySynchronized) -> BOOLEAN #APC_LEVEL
FsRtlProcessFileLock(PFILE_LOCK inFileLock, PIRP inIrp, PVOID inContext) -> NTSTATUS #APC_LEVEL
FsRtlRegisterUncProvider(PHANDLE outMupHandle, PUNICODE_STRING inRedirectorDeviceName, BOOLEAN inMailslotsSupported) -> NTSTATUS #PASSIVE_LEVEL
FsRtlRegisterUncProviderEx(PHANDLE outMupHandle, PUNICODE_STRING inRedirDevName, PDEVICE_OBJECT inDeviceObject, ULONG inFlags) -> NTSTATUS #PASSIVE_LEVEL
FsRtlReleaseFile(PFILE_OBJECT inFileObject) -> VOID #APC_LEVEL
FsRtlRemoveBaseMcbEntry(PBASE_MCB inMcb, LONGLONG inVbn, LONGLONG inSectorCount) -> BOOLEAN #APC_LEVEL
FsRtlRemoveDotsFromPath( PWSTR OriginalString, USHORT inPathLength, USHORT out*NewLength) -> NTSTATUS #PASSIVE_LEVEL
FsRtlRemoveExtraCreateParameter(PECP_LIST ioEcpList, LPCGUID inEcpType, PVOID *EcpContext, ULONG out*EcpContextSize) -> NTSTATUS #APC_LEVEL
FsRtlRemoveLargeMcbEntry(PLARGE_MCB inMcb, LONGLONG inVbn, LONGLONG inSectorCount) -> VOID #APC_LEVEL
FsRtlRemoveMcbEntry(PMCB inMcb, VBN inVbn, ULONG inSectorCount) -> VOID #APC_LEVEL
FsRtlRemovePerFileContext(PVOID* inPerFileContextPointer, PVOID inOwnerId, PVOID inInstanceId) -> PFSRTL_PER_FILE_CONTEXT #APC_LEVEL
FsRtlRemovePerFileObjectContext(PFILE_OBJECT inFileObject, PVOID inOwnerId, PVOID inInstanceId) -> PFSRTL_PER_FILEOBJECT_CONTEXT #APC_LEVEL
FsRtlRemovePerStreamContext(PFSRTL_ADVANCED_FCB_HEADER inStreamContext, PVOID inOwnerId, PVOID inInstanceId) -> PFSRTL_PER_STREAM_CONTEXT #APC_LEVEL
FsRtlResetBaseMcb(PBASE_MCB inMcb) -> VOID #APC_LEVEL
FsRtlResetLargeMcb(PLARGE_MCB inMcb, BOOLEAN inSelfSynchronized) -> VOID #APC_LEVEL
FsRtlSetEcpListIntoIrp(PIRP ioIrp, PECP_LIST inEcpList) -> NTSTATUS #APC_LEVEL
FsRtlSplitBaseMcb(PBASE_MCB inMcb, LONGLONG inVbn, LONGLONG inAmount) -> BOOLEAN #APC_LEVEL
FsRtlSplitLargeMcb(PLARGE_MCB inMcb, LONGLONG inVbn, LONGLONG inAmount) -> BOOLEAN #APC_LEVEL
FsRtlTeardownPerFileContexts(PVOID* inPerFileContextPointer) -> VOID #APC_LEVEL
FsRtlTeardownPerStreamContexts(PFSRTL_ADVANCED_FCB_HEADER inAdvancedHeader) -> VOID #APC_LEVEL
FsRtlTruncateBaseMcb(PBASE_MCB inMcb, LONGLONG inVbn) -> VOID #APC_LEVEL
FsRtlTruncateLargeMcb(PLARGE_MCB inMcb, LONGLONG inVbn) -> VOID #APC_LEVEL
FsRtlTruncateMcb(PMCB inMcb, VBN inVbn) -> VOID #APC_LEVEL
FsRtlUninitializeBaseMcb(PBASE_MCB inMcb) -> VOID #APC_LEVEL
FsRtlUninitializeFileLock(PFILE_LOCK inFileLock) -> VOID #APC_LEVEL
FsRtlUninitializeLargeMcb(PLARGE_MCB inMcb) -> VOID #APC_LEVEL
FsRtlUninitializeMcb(PMCB inMcb) -> VOID #APC_LEVEL
FsRtlUninitializeOplock(POPLOCK ioOplock) -> VOID #APC_LEVEL
FsRtlValidateReparsePointBuffer(ULONG inBufferLength, PREPARSE_DATA_BUFFER ReparseBuffer) -> NTSTATUS #PASSIVE_LEVEL
HalExamineMBR(PDEVICE_OBJECT inDeviceObject, ULONG inSectorSize, ULONG inMBRTypeIdentifier, PVOID out*Buffer) -> FASTCALL #PASSIVE_LEVEL
HalGetAdapter(PDEVICE_DESCRIPTION inDeviceDescription, PULONG outNumberOfMapRegisters) -> PADAPTER_OBJECT #PASSIVE_LEVEL
HalGetInterruptVector(INTERFACE_TYPE inInterfaceType, ULONG inBusNumber, ULONG inBusInterruptLevel, ULONG inBusInterruptVector, PKIRQL outIrql, PKAFFINITY outAffinity) -> ULONG #PASSIVE_LEVEL
HidRegisterMinidriver(PHID_MINIDRIVER_REGISTRATION inMinidriverRegistration) -> NTSTATUS #APC_LEVEL
IPAllocBuff(ioIPRcvBuf *pRcvBuf, UINT inSize) -> ) IPAllocBuff #DISPATCH_LEVEL
IPFreeBuff(inIPRcvBuf *pRcvBuf) -> ) IPFreeBuff #DISPATCH_LEVEL
IPPacketFirewallPtrType(VOID io**pData, UINT inRecvInterfaceIndex, ioUINT *pSendInterfaceIndex, ioUCHAR *pDestinationType, VOID *pContext, UINT inContextLength, IPRcvBuf out**ppRcvBuf) -> FORWARD_ACTION #DISPATCH_LEVEL
IPv6DisableFirewallHook(IPv6FirewallDeregistrationCompleteProc inCompletionRoutine) -> ) IPv6DisableFirewallHook #DISPATCH_LEVEL
IPv6EnableFirewallHook(IPv6FirewallHookProc inFirewallHookFunction) -> ) IPv6EnableFirewallHook #DISPATCH_LEVEL
IPv6FirewallHookProcType(const inIPv6Addr *SourceAddress, const inIPv6Addr *DestinationAddress, uint inPayloadLength, uchar inHeaderType, const inuchar *HeaderData, const invoid *PacketContext, uint inDataLength, uint inInterfaceIndex, IPv6Direction inDirection, BOOLEAN inIsLoopBack) -> IPv6Action #DISPATCH_LEVEL
IPv6GetBestRouteInfo(const inIPv6Addr *Addr, ulong inScopeId, ulong inIndex, IP6RouteEntry out*Ire) -> ) IPv6GetBestRouteInfo #DISPATCH_LEVEL
IPv6ObtainPacketData(const invoid *PacketContext, uint inDataLength, uint inAlignment) -> ) IPv6ObtainPacketData #DISPATCH_LEVEL
IoAcquireCancelSpinLock(PKIRQL outIrql) -> VOID #DISPATCH_LEVEL
IoAcquireRemoveLockEx(PIO_REMOVE_LOCK inRemoveLock, PVOID inTag, # Optional PCSTR inFile, ULONG inLine, ULONG inRemlockSize // are we checked or free) -> NTSTATUS //DISPATCH_LEVEL
IoAllocateAdapterChannel(PADAPTER_OBJECT inAdapterObject, PDEVICE_OBJECT inDeviceObject, ULONG inNumberOfMapRegisters, PDRIVER_CONTROL inExecutionRoutine, PVOID inContext) -> NTSTATUS #DISPATCH_LEVEL
IoAllocateController(PCONTROLLER_OBJECT inControllerObject, PDEVICE_OBJECT inDeviceObject, PDRIVER_CONTROL inExecutionRoutine, PVOID inContext) -> VOID #DISPATCH_LEVEL
IoAllocateDriverObjectExtension(PDRIVER_OBJECT inDriverObject, PVOID inClientIdentificationAddress, ULONG inDriverObjectExtensionSize, # When successful, this always allocates already-aliased memory. PVOID *DriverObjectExtension) -> ) VOID //DISPATCH_LEVEL
IoAllocateErrorLogEntry(PVOID inIoObject, UCHAR inEntrySize) -> PVOID #DISPATCH_LEVEL
IoAllocateIrp(CCHAR inStackSize, BOOLEAN inChargeQuota) -> PIRP #DISPATCH_LEVEL
IoAllocateMdl(PVOID inVirtualAddress, ULONG inLength, BOOLEAN inSecondaryBuffer, BOOLEAN inChargeQuota, PIRP Irp) -> PMDL #DISPATCH_LEVEL
IoAllocateWorkItem(PDEVICE_OBJECT inDeviceObject) -> PIO_WORKITEM #DISPATCH_LEVEL
IoAttachDevice(PDEVICE_OBJECT inSourceDevice, PUNICODE_STRING inTargetDevice, PDEVICE_OBJECT out*AttachedDevice) -> ) PIO_WORKITEM #APC_LEVEL
IoAttachDeviceToDeviceStack(PDEVICE_OBJECT inSourceDevice, PDEVICE_OBJECT inTargetDevice) -> DISPATCH_LEVEL #DISPATCH_LEVEL
IoBuildAsynchronousFsdRequest(ULONG inMajorFunction, PDEVICE_OBJECT inDeviceObject, PVOID Buffer, ULONG inLength, PLARGE_INTEGER inStartingOffset, PIO_STATUS_BLOCK inIoStatusBlock) -> PIRP #DISPATCH_LEVEL
IoBuildDeviceIoControlRequest(ULONG inIoControlCode, PDEVICE_OBJECT inDeviceObject, PVOID inInputBuffer, ULONG inInputBufferLength, PVOID outOutputBuffer, ULONG inOutputBufferLength, BOOLEAN inInternalDeviceIoControl, PKEVENT inEvent, PIO_STATUS_BLOCK outIoStatusBlock) -> PIRP #PASSIVE_LEVEL
IoBuildPartialMdl(PMDL inSourceMdl, PMDL ioTargetMdl, PVOID inVirtualAddress, ULONG inLength) -> VOID #DISPATCH_LEVEL
IoBuildSynchronousFsdRequest(ULONG inMajorFunction, PDEVICE_OBJECT inDeviceObject, PVOID Buffer, ULONG inLength, PLARGE_INTEGER inStartingOffset, PKEVENT inEvent, PIO_STATUS_BLOCK outIoStatusBlock) -> PIRP #PASSIVE_LEVEL
IoCancelIrp(PIRP inIrp) -> BOOLEAN #DISPATCH_LEVEL
IoCheckShareAccess(ACCESS_MASK inDesiredAccess, ULONG inDesiredShareAccess, PFILE_OBJECT ioFileObject, PSHARE_ACCESS ioShareAccess, BOOLEAN inUpdate) -> NTSTATUS #PASSIVE_LEVEL
IoConnectInterrupt(PKINTERRUPT out*InterruptObject, PKSERVICE_ROUTINE inServiceRoutine, PVOID inServiceContext, PKSPIN_LOCK inSpinLock, ULONG inVector, KIRQL inIrql, KIRQL inSynchronizeIrql, KINTERRUPT_MODE inInterruptMode, BOOLEAN inShareVector, KAFFINITY inProcessorEnableMask, BOOLEAN inFloatingSave) -> NTSTATUS #PASSIVE_LEVEL
IoCreateController(ULONG inSize) -> PCONTROLLER_OBJECT #PASSIVE_LEVEL
IoCreateDevice(PDRIVER_OBJECT inDriverObject, ULONG inDeviceExtensionSize, PUNICODE_STRING inDeviceName, DEVICE_TYPE inDeviceType, ULONG inDeviceCharacteristics, BOOLEAN inExclusive, PDEVICE_OBJECT out*DeviceObject) -> ) PCONTROLLER_OBJECT #APC_LEVEL
IoCreateFile(PHANDLE outFileHandle, ACCESS_MASK inDesiredAccess, POBJECT_ATTRIBUTES inObjectAttributes, PIO_STATUS_BLOCK outIoStatusBlock, PLARGE_INTEGER inAllocationSize, ULONG inFileAttributes, ULONG inShareAccess, ULONG inDisposition, ULONG inCreateOptions, PVOID inEaBuffer, ULONG inEaLength, CREATE_FILE_TYPE inCreateFileType, PVOID inInternalParameters, ULONG inOptions) -> NTSTATUS #PASSIVE_LEVEL
IoCreateNotificationEvent(PUNICODE_STRING inEventName, PHANDLE outEventHandle) -> PKEVENT #PASSIVE_LEVEL
IoCreateSymbolicLink(PUNICODE_STRING inSymbolicLinkName, PUNICODE_STRING inDeviceName) -> NTSTATUS #PASSIVE_LEVEL
IoCreateSynchronizationEvent(PUNICODE_STRING inEventName, PHANDLE outEventHandle) -> PKEVENT #PASSIVE_LEVEL
IoCreateUnprotectedSymbolicLink(PUNICODE_STRING inSymbolicLinkName, PUNICODE_STRING inDeviceName) -> NTSTATUS #PASSIVE_LEVEL
IoDeleteController(PCONTROLLER_OBJECT inControllerObject) -> VOID #PASSIVE_LEVEL
IoDeleteDevice(PDEVICE_OBJECT inDeviceObject) -> VOID #APC_LEVEL
IoDeleteSymbolicLink(PUNICODE_STRING inSymbolicLinkName) -> NTSTATUS #PASSIVE_LEVEL
IoDetachDevice(PDEVICE_OBJECT ioTargetDevice) -> VOID #PASSIVE_LEVEL
IoDisconnectInterrupt(PKINTERRUPT inInterruptObject) -> VOID #PASSIVE_LEVEL
IoFreeController(PCONTROLLER_OBJECT inControllerObject) -> VOID #DISPATCH_LEVEL
IoFreeIrp(PIRP inIrp) -> VOID #DISPATCH_LEVEL
IoFreeMdl(PMDL Mdl) -> VOID #DISPATCH_LEVEL
IoGetAttachedDeviceReference(# wdm PDEVICE_OBJECT inDeviceObject // wdm) -> )               IoGetAttachedDeviceReference //DISPATCH_LEVEL
IoGetAttachedDeviceReference(PDEVICE_OBJECT inDeviceObject ) -> )               IoGetAttachedDeviceReference #DISPATCH_LEVEL
IoGetDeviceInterfaceAlias(PUNICODE_STRING inSymbolicLinkName, CONST inGUID *AliasInterfaceClassGuid, PUNICODE_STRING outAliasSymbolicLinkName) -> NTSTATUS #PASSIVE_LEVEL
IoGetDeviceInterfaces(CONST inGUID *InterfaceClassGuid, PDEVICE_OBJECT inPhysicalDeviceObject, ULONG inFlags, -> NTSTATUS #PASSIVE_LEVEL
IoGetDeviceNumaNode(PDEVICE_OBJECT inPdo, PUSHORT outNodeNumber) -> NTSTATUS #PASSIVE_LEVEL
IoGetDeviceObjectPointer(PUNICODE_STRING inObjectName, ACCESS_MASK inDesiredAccess, PFILE_OBJECT out*FileObject, PDEVICE_OBJECT out*DeviceObject) -> NTSTATUS #PASSIVE_LEVEL
IoGetDeviceProperty(PDEVICE_OBJECT inDeviceObject, DEVICE_REGISTRY_PROPERTY inDeviceProperty, ULONG inBufferLength, PVOID outPropertyBuffer, PULONG outResultLength) -> NTSTATUS #PASSIVE_LEVEL
IoGetDevicePropertyData(PDEVICE_OBJECT inPdo, CONST inDEVPROPKEY *PropertyKey, LCID inLcid, ULONG Flags, ULONG inSize, PVOID outData, PULONG outRequiredSize, PDEVPROPTYPE outType) -> NTSTATUS #PASSIVE_LEVEL
IoGetDeviceToVerify(PETHREAD inThread) -> PDEVICE_OBJECT #PASSIVE_LEVEL
IoGetDmaAdapter(PDEVICE_OBJECT inPhysicalDeviceObject, # required for PnP drivers struct in_DEVICE_DESCRIPTION *DeviceDescription, PULONG outNumberOfMapRegisters) -> (" //PASSIVE_LEVEL
IoGetDriverObjectExtension(PDRIVER_OBJECT inDriverObject, PVOID inClientIdentificationAddress) -> PVOID #DISPATCH_LEVEL
IoGetFileObjectGenericMapping(VOID) -> PGENERIC_MAPPING #PASSIVE_LEVEL
IoGetInitialStack(VOID) -> PVOID #APC_LEVEL
IoGetRemainingStackSize(VOID) -> ULONG_PTR #APC_LEVEL
IoGetStackLimits(PULONG_PTR outLowLimit, PULONG_PTR outHighLimit) -> VOID #APC_LEVEL
IoInitializeIrp(PIRP ioIrp, USHORT inPacketSize, CCHAR inStackSize) -> VOID #DISPATCH_LEVEL
IoInitializeRemoveLockEx(PIO_REMOVE_LOCK inLock, ULONG inAllocateTag, # Used only on checked kernels ULONG inMaxLockedMinutes, // Used only on checked kernels ULONG inHighWatermark, // Used only on checked kernels ULONG inRemlockSize // are we checked or free) -> VOID //PASSIVE_LEVEL
IoInitializeTimer(PDEVICE_OBJECT inDeviceObject, PIO_TIMER_ROUTINE inTimerRoutine, PVOID inContext) -> NTSTATUS #PASSIVE_LEVEL
IoInvalidateDeviceRelations(PDEVICE_OBJECT inDeviceObject, DEVICE_RELATION_TYPE inType) -> VOID #DISPATCH_LEVEL
IoInvalidateDeviceState(PDEVICE_OBJECT inPhysicalDeviceObject) -> VOID #DISPATCH_LEVEL
IoIs32bitProcess(PIRP inIrp) -> BOOLEAN #DISPATCH_LEVEL
IoIsWdmVersionAvailable(UCHAR MajorVersion, UCHAR inMinorVersion) -> BOOLEAN #PASSIVE_LEVEL
IoMakeAssociatedIrp(PIRP inIrp, CCHAR inStackSize) -> PIRP #DISPATCH_LEVEL
IoOpenDeviceInterfaceRegistryKey(PUNICODE_STRING inSymbolicLinkName, ACCESS_MASK inDesiredAccess, PHANDLE outDeviceInterfaceKey) -> NTSTATUS #PASSIVE_LEVEL
IoOpenDeviceRegistryKey(PDEVICE_OBJECT inDeviceObject, ULONG inDevInstKeyType, ACCESS_MASK inDesiredAccess, PHANDLE outDevInstRegKey) -> NTSTATUS #PASSIVE_LEVEL
IoQueueWorkItem(PIO_WORKITEM inIoWorkItem, PIO_WORKITEM_ROUTINE inWorkerRoutine, WORK_QUEUE_TYPE inQueueType, PVOID inContext) -> Use #DISPATCH_LEVEL
IoQueueWorkItemEx(PIO_WORKITEM inIoWorkItem, PIO_WORKITEM_ROUTINE_EX inWorkerRoutine, WORK_QUEUE_TYPE inQueueType, PVOID inContext) -> VOID #DISPATCH_LEVEL
IoRaiseHardError(PIRP inIrp, PVPB inVpb, PDEVICE_OBJECT inRealDeviceObject) -> VOID #APC_LEVEL
IoRaiseInformationalHardError(NTSTATUS inErrorStatus, PUNICODE_STRING inString, PKTHREAD inThread) -> BOOLEAN #APC_LEVEL
IoReadPartitionTable(PDEVICE_OBJECT inDeviceObject, ULONG inSectorSize, BOOLEAN inReturnRecognizedPartitions, struct out_DRIVE_LAYOUT_INFORMATION **PartitionBuffer) -> FASTCALL #PASSIVE_LEVEL
IoReadPartitionTableEx(PDEVICE_OBJECT inDeviceObject, struct out_DRIVE_LAYOUT_INFORMATION_EX** DriveLayout) -> NTSTATUS #PASSIVE_LEVEL
IoRegisterBootDriverReinitialization(PDRIVER_OBJECT inDriverObject, PDRIVER_REINITIALIZE inDriverReinitializationRoutine, PVOID inContext) -> VOID #PASSIVE_LEVEL
IoRegisterDeviceInterface(PDEVICE_OBJECT inPhysicalDeviceObject, CONST inGUID *InterfaceClassGuid, PUNICODE_STRING inReferenceString, PUNICODE_STRING outSymbolicLinkName) -> NTSTATUS #PASSIVE_LEVEL
IoRegisterDriverReinitialization(PDRIVER_OBJECT inDriverObject, PDRIVER_REINITIALIZE inDriverReinitializationRoutine, PVOID inContext) -> VOID #PASSIVE_LEVEL
IoRegisterFileSystem(PDEVICE_OBJECT inDeviceObject) -> VOID #APC_LEVEL
IoRegisterLastChanceShutdownNotification(PDEVICE_OBJECT inDeviceObject) -> NTSTATUS #PASSIVE_LEVEL
IoRegisterPlugPlayNotification(IO_NOTIFICATION_EVENT_CATEGORY inEventCategory, ULONG inEventCategoryFlags, PVOID inEventCategoryData, PDRIVER_OBJECT inDriverObject, PDRIVER_NOTIFICATION_CALLBACK_ROUTINE inCallbackRoutine, PVOID Context, -> NTSTATUS #PASSIVE_LEVEL
IoRegisterShutdownNotification(PDEVICE_OBJECT inDeviceObject) -> NTSTATUS #PASSIVE_LEVEL
IoReleaseCancelSpinLock(KIRQL inIrql) -> VOID #DISPATCH_LEVEL
IoReleaseRemoveLockAndWaitEx(PIO_REMOVE_LOCK inRemoveLock, PVOID inTag, ULONG inRemlockSize # are we checked or free) -> VOID //PASSIVE_LEVEL
IoRemoveShareAccess(PFILE_OBJECT inFileObject, PSHARE_ACCESS ioShareAccess) -> VOID #PASSIVE_LEVEL
IoReplacePartitionUnit(PDEVICE_OBJECT inTargetPdo, PDEVICE_OBJECT inSparePdo, ULONG inFlags) -> NTSTATUS #PASSIVE_LEVEL
IoReportDetectedDevice(PDRIVER_OBJECT inDriverObject, INTERFACE_TYPE inLegacyBusType, ULONG inBusNumber, ULONG inSlotNumber, PCM_RESOURCE_LIST inResourceList, PIO_RESOURCE_REQUIREMENTS_LIST inResourceRequirements, BOOLEAN inResourceAssigned, PDEVICE_OBJECT *DeviceObject) -> NTSTATUS #PASSIVE_LEVEL
IoReportTargetDeviceChange(PDEVICE_OBJECT inPhysicalDeviceObject, PVOID inNotificationStructure # always begins with a PLUGPLAY_NOTIFICATION_HEADER) -> NTSTATUS //PASSIVE_LEVEL
IoReportTargetDeviceChangeAsynchronous(PDEVICE_OBJECT inPhysicalDeviceObject, PVOID inNotificationStructure, # always begins with a PLUGPLAY_NOTIFICATION_HEADER PDEVICE_CHANGE_COMPLETE_CALLBACK inCallback, PVOID Context) -> NTSTATUS //DISPATCH_LEVEL
IoRequestDeviceEject(PDEVICE_OBJECT inPhysicalDeviceObject) -> VOID #DISPATCH_LEVEL
IoRequestDeviceEjectEx(PDEVICE_OBJECT inPhysicalDeviceObject, PIO_DEVICE_EJECT_CALLBACK inCallback, PVOID inContext, PDRIVER_OBJECT inDriverObject) -> NTSTATUS #DISPATCH_LEVEL
IoReuseIrp(PIRP ioIrp, NTSTATUS inIostatus) -> VOID #DISPATCH_LEVEL
IoSetCompletionRoutine(PIRP inIrp, PIO_COMPLETION_ROUTINE inCompletionRoutine, PVOID inContext, BOOLEAN inInvokeOnSuccess, BOOLEAN inInvokeOnError, BOOLEAN inInvokeOnCancel) -> VOID #DISPATCH_LEVEL
IoSetCompletionRoutineEx(PDEVICE_OBJECT inDeviceObject, PIRP inIrp, PIO_COMPLETION_ROUTINE inCompletionRoutine, PVOID inContext, BOOLEAN inInvokeOnSuccess, BOOLEAN inInvokeOnError, BOOLEAN inInvokeOnCancel) -> NTSTATUS #DISPATCH_LEVEL
IoSetDeviceInterfaceState(PUNICODE_STRING inSymbolicLinkName, BOOLEAN inEnable) -> NTSTATUS #PASSIVE_LEVEL
IoSetDevicePropertyData(PDEVICE_OBJECT inPdo, CONST inDEVPROPKEY *PropertyKey, LCID inLcid, ULONG inFlags, DEVPROPTYPE inType, ULONG inSize, PVOID inData) -> NTSTATUS #PASSIVE_LEVEL
IoSetHardErrorOrVerifyDevice(PIRP inIrp, PDEVICE_OBJECT inDeviceObject) -> VOID #DISPATCH_LEVEL
IoSetPartitionInformation(PDEVICE_OBJECT inDeviceObject, ULONG inSectorSize, ULONG inPartitionNumber, ULONG inPartitionType) -> FASTCALL #PASSIVE_LEVEL
IoSetPartitionInformationEx(PDEVICE_OBJECT inDeviceObject, ULONG inPartitionNumber, struct in_SET_PARTITION_INFORMATION_EX* PartitionInfo) -> NTSTATUS #PASSIVE_LEVEL
IoSetThreadHardErrorMode(BOOLEAN inEnableHardErrors) -> BOOLEAN #DISPATCH_LEVEL
IoStartNextPacket(PDEVICE_OBJECT inDeviceObject, BOOLEAN inCancelable) -> VOID #DISPATCH_LEVEL
IoStartNextPacketByKey(PDEVICE_OBJECT inDeviceObject, BOOLEAN inCancelable, ULONG inKey) -> VOID #DISPATCH_LEVEL
IoStartPacket(PDEVICE_OBJECT inDeviceObject, PIRP inIrp, PULONG inKey, PDRIVER_CANCEL inCancelFunction) -> VOID #DISPATCH_LEVEL
IoStartTimer(PDEVICE_OBJECT inDeviceObject) -> VOID #DISPATCH_LEVEL
IoStopTimer(PDEVICE_OBJECT inDeviceObject) -> VOID #DISPATCH_LEVEL
IoUnregisterPlugPlayNotification(PVOID inNotificationEntry) -> NTSTATUS #PASSIVE_LEVEL
IoUnregisterPlugPlayNotificationEx(PVOID inNotificationEntry) -> NTSTATUS #PASSIVE_LEVEL
IoUnregisterShutdownNotification(PDEVICE_OBJECT inDeviceObject) -> VOID #PASSIVE_LEVEL
IoUpdateShareAccess(PFILE_OBJECT inFileObject, PSHARE_ACCESS ioShareAccess) -> VOID #PASSIVE_LEVEL
IoWMIAllocateInstanceIds(inGUID *Guid, ULONG inInstanceCount, ULONG out*FirstInstanceId) -> NTSTATUS #PASSIVE_LEVEL
IoWMIRegistrationControl(PDEVICE_OBJECT inDeviceObject, ULONG inAction) -> NTSTATUS #PASSIVE_LEVEL
IoWMIWriteEvent(PVOID ioWnodeEventItem) -> ) NTSTATUS #APC_LEVEL
IoWriteErrorLogEntry(# wdm PVOID inElEntry // wdm) -> wdm //DISPATCH_LEVEL
IoWriteErrorLogEntry(PVOID inElEntry ) -> wdm #DISPATCH_LEVEL
IoWritePartitionTable(PDEVICE_OBJECT inDeviceObject, ULONG inSectorSize, ULONG inSectorsPerTrack, ULONG inNumberOfHeads, struct in_DRIVE_LAYOUT_INFORMATION *PartitionBuffer) -> FASTCALL #PASSIVE_LEVEL
IoWritePartitionTableEx(PDEVICE_OBJECT inDeviceObject, struct _DRIVE_LAYOUT_INFORMATION_EX* DriveLayout) -> NTSTATUS #PASSIVE_LEVEL
IofCallDriver(PDEVICE_OBJECT inDeviceObject, PIRP ioIrp) -> FASTCALL #DISPATCH_LEVEL
IofCompleteRequest(PIRP inIrp, CCHAR inPriorityBoost) -> FASTCALL #DISPATCH_LEVEL
KDEFERRED_ROUTINE(struct in_KDPC *Dpc, PVOID inDeferredContext, PVOID inSystemArgument1, PVOID inSystemArgument2) -> VOID #DISPATCH_LEVEL
KKERNEL_ROUTINE(struct in_KAPC *Apc, PKNORMAL_ROUTINE *NormalRoutine, PVOID *NormalContext, PVOID *SystemArgument1, PVOID *SystemArgument2) -> VOID #APC_LEVEL
KNORMAL_ROUTINE(PVOID inNormalContext, PVOID inSystemArgument1, PVOID inSystemArgument2) -> VOID #PASSIVE_LEVEL
KRUNDOWN_ROUTINE(struct in_KAPC *Apc) -> VOID #PASSIVE_LEVEL
KeAcquireGuardedMutex(PKGUARDED_MUTEX ioMutex) -> FASTCALL #APC_LEVEL
KeAcquireGuardedMutexUnsafe(PKGUARDED_MUTEX ioFastMutex) -> FASTCALL #APC_LEVEL
KeAcquireInStackQueuedSpinLock(PKSPIN_LOCK ioSpinLock, PKLOCK_QUEUE_HANDLE outLockHandle) -> FASTCALL #DISPATCH_LEVEL
KeAcquireInStackQueuedSpinLockForDpc(PKSPIN_LOCK ioSpinLock, PKLOCK_QUEUE_HANDLE outLockHandle) -> FASTCALL #DISPATCH_LEVEL
KeAcquireInterruptSpinLock(PKINTERRUPT ioInterrupt) -> KIRQL #HIGH_LEVEL
KeAcquireSpinLockForDpc(PKSPIN_LOCK ioSpinLock) -> FASTCALL #DISPATCH_LEVEL
KeAcquireSpinLockRaiseToDpc(PKSPIN_LOCK ioSpinLock) -> KIRQL #DISPATCH_LEVEL
KeAreAllApcsDisabled(VOID) -> BOOLEAN #APC_LEVEL
KeAreApcsDisabled(VOID) -> BOOLEAN #APC_LEVEL
KeAttachProcess(PRKPROCESS ioProcess) -> VOID #APC_LEVEL
KeCancelTimer(ioPKTIMER) -> BOOLEAN #DISPATCH_LEVEL
KeClearEvent(PRKEVENT ioEvent) -> VOID #DISPATCH_LEVEL
KeDelayExecutionThread(KPROCESSOR_MODE inWaitMode, BOOLEAN inAlertable, PLARGE_INTEGER inInterval) -> NTSTATUS #APC_LEVEL
KeDeregisterNmiCallback(PVOID inHandle) -> NTSTATUS #APC_LEVEL
KeDeregisterProcessorChangeCallback(PVOID inCallbackHandle) -> VOID #APC_LEVEL
KeDetachProcess(VOID) -> VOID #APC_LEVEL
KeEnterCriticalRegion(VOID) -> VOID #APC_LEVEL
KeEnterGuardedRegion(VOID) -> VOID #APC_LEVEL
KeExpandKernelStackAndCallout(PEXPAND_STACK_CALLOUT inCallout, PVOID inParameter, SIZE_T inSize) -> NTSTATUS #DISPATCH_LEVEL
KeFlushIoBuffers(PMDL inMdl, BOOLEAN inReadOperation, BOOLEAN inDmaOperation) -> VOID #DISPATCH_LEVEL
KeFlushQueuedDpcs(VOID) -> VOID #APC_LEVEL
KeGetCurrentIrql(VOID) -> KIRQL #HIGH_LEVEL
KeInitializeDeviceQueue(PKDEVICE_QUEUE outDeviceQueue) -> VOID #DISPATCH_LEVEL
KeInitializeGuardedMutex(PKGUARDED_MUTEX outMutex) -> FASTCALL #APC_LEVEL
KeInitializeSemaphore(PRKSEMAPHORE outSemaphore, LONG inCount, LONG inLimit) -> VOID #PASSIVE_LEVEL
KeInitializeTimer(PKTIMER outTimer) -> VOID #DISPATCH_LEVEL
KeInitializeTimerEx(PKTIMER outTimer, TIMER_TYPE inType) -> VOID #DISPATCH_LEVEL
KeInsertHeadQueue(PRKQUEUE ioQueue, PLIST_ENTRY ioEntry) -> LONG #DISPATCH_LEVEL
KeInsertQueue(PRKQUEUE ioQueue, PLIST_ENTRY ioEntry) -> LONG #DISPATCH_LEVEL
KeInvalidateAllCaches(VOID) -> BOOLEAN #DISPATCH_LEVEL
KeInvalidateRangeAllCaches(PVOID inBaseAddress, ULONG inLength) -> FASTCALL #DISPATCH_LEVEL
KeIpiGenericCall(PKIPI_BROADCAST_WORKER inBroadcastFunction, ULONG_PTR inContext) -> ULONG_PTR #IPI_LEVEL
KeLeaveCriticalRegion(VOID) -> VOID #APC_LEVEL
KeLeaveGuardedRegion(VOID) -> VOID #APC_LEVEL
KeLowerIrql(KIRQL inNewIrql) -> VOID #HIGH_LEVEL
KePulseEvent(PRKEVENT ioEvent, KPRIORITY inIncrement, BOOLEAN inWait) -> LONG #DISPATCH_LEVEL
KeQueryHardwareCounterConfiguration(PHARDWARE_COUNTER CounterArray, ULONG inMaximumCount, PULONG outCount) -> NTSTATUS #APC_LEVEL
KeQueryLogicalProcessorRelationship(PPROCESSOR_NUMBER inProcessorNumber, LOGICAL_PROCESSOR_RELATIONSHIP inRelationshipType, PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX outInformation, PULONG ioLength) -> NTSTATUS #DISPATCH_LEVEL
KeQueryOwnerMutant(PKMUTANT inMutant, PCLIENT_ID outClientId) -> VOID #DISPATCH_LEVEL
KeQueryPriorityThread(PKTHREAD inThread) -> KPRIORITY #PASSIVE_LEVEL
KeQueryRuntimeThread(PKTHREAD inThread, PULONG outUserTime) -> ULONG #PASSIVE_LEVEL
KeQueryTotalCycleTimeProcess(PKPROCESS ioProcess, PULONG64 outCycleTimeStamp) -> ULONG64 #DISPATCH_LEVEL
KeQueryTotalCycleTimeThread(PKTHREAD ioThread, PULONG64 outCycleTimeStamp) -> ULONG64 #APC_LEVEL
KeRaiseIrql(KIRQL inNewIrql, PKIRQL outOldIrql) -> VOID #HIGH_LEVEL
KeRaiseIrqlToDpcLevel(VOID) -> KIRQL #DISPATCH_LEVEL
KeRaiseIrqlToDpcLevel(VOID) -> KIRQL #DISPATCH_LEVEL
KeReadStateEvent(PRKEVENT inEvent) -> LONG #DISPATCH_LEVEL
KeReadStateMutant(PRKMUTANT inMutant) -> LONG #DISPATCH_LEVEL
KeReadStateMutex(PRKMUTEX inMutex) -> LONG #DISPATCH_LEVEL
KeReadStateQueue(PRKQUEUE inQueue) -> LONG #DISPATCH_LEVEL
KeReadStateSemaphore(PRKSEMAPHORE inSemaphore) -> LONG #DISPATCH_LEVEL
KeReadStateTimer(PKTIMER inTimer) -> BOOLEAN #DISPATCH_LEVEL
KeRegisterNmiCallback(PNMI_CALLBACK inCallbackRoutine, PVOID inContext) -> PVOID #APC_LEVEL
KeRegisterProcessorChangeCallback(PPROCESSOR_CALLBACK_FUNCTION inCallbackFunction, PVOID inCallbackContext, ULONG inFlags) -> PVOID #APC_LEVEL
KeReleaseGuardedMutex(PKGUARDED_MUTEX ioMutex) -> FASTCALL #APC_LEVEL
KeReleaseGuardedMutexUnsafe(ioPKGUARDED_MUTEX ioFastMutex) -> FASTCALL #APC_LEVEL
KeReleaseMutant(PRKMUTANT ioMutant, KPRIORITY inIncrement, BOOLEAN inAbandoned, BOOLEAN inWait) -> LONG # APC_LEVEL
KeReleaseMutex(PRKMUTEX ioMutex, BOOLEAN inWait) -> LONG # APC_LEVEL
KeReleaseSemaphore(PRKSEMAPHORE ioSemaphore, KPRIORITY inIncrement, LONG inAdjustment, BOOLEAN inWait) -> LONG # APC_LEVEL
KeRemoveEntryDeviceQueue(PKDEVICE_QUEUE ioDeviceQueue, PKDEVICE_QUEUE_ENTRY ioDeviceQueueEntry) -> BOOLEAN #DISPATCH_LEVEL
KeRemoveQueue(PRKQUEUE ioQueue, KPROCESSOR_MODE inWaitMode, PLARGE_INTEGER inTimeout) -> PLIST_ENTRY # DISPATCH_LEVEL
KeRemoveQueueDpc(PRKDPC ioDpc) -> BOOLEAN #HIGH_LEVEL
KeRemoveQueueEx(PKQUEUE ioQueue, KPROCESSOR_MODE inWaitMode, BOOLEAN inAlertable, PLARGE_INTEGER inTimeout, PLIST_ENTRY *EntryArray, ULONG inCount) -> ULONG # DISPATCH_LEVEL
KeResetEvent(PRKEVENT ioEvent) -> LONG #DISPATCH_LEVEL
KeRevertToUserAffinityThread(VOID) -> VOID #APC_LEVEL
KeRevertToUserAffinityThreadEx(KAFFINITY inAffinity) -> VOID #APC_LEVEL
KeRevertToUserGroupAffinityThread(PGROUP_AFFINITY inPreviousAffinity) -> VOID #APC_LEVEL
KeRundownQueue(PRKQUEUE ioQueue) -> PLIST_ENTRY #DISPATCH_LEVEL
KeSaveExtendedProcessorState(ULONG64 inMask, PXSTATE_SAVE outXStateSave) -> ) PLIST_ENTRY #DISPATCH_LEVEL
KeSaveFloatingPointState(PKFLOATING_SAVE outFloatSave) -> DISPATCH_LEVEL #DISPATCH_LEVEL
KeSetBasePriorityThread(PKTHREAD ioThread, LONG inIncrement) -> LONG #DISPATCH_LEVEL
KeSetCoalescableTimer(PKTIMER ioTimer, LARGE_INTEGER inDueTime, ULONG inPeriod, ULONG inTolerableDelay, PKDPC inDpc) -> BOOLEAN #DISPATCH_LEVEL
KeSetEvent(PRKEVENT ioEvent, KPRIORITY inIncrement, BOOLEAN inWait) -> LONG # APC_LEVEL
KeSetHardwareCounterConfiguration(HARDWARE_COUNTER CounterArray, ULONG inCount) -> NTSTATUS #APC_LEVEL
KeSetIdealProcessorThread(PKTHREAD ioThread, UCHAR inProcessor) -> UCHAR #DISPATCH_LEVEL
KeSetKernelStackSwapEnable(BOOLEAN inEnable) -> BOOLEAN #APC_LEVEL
KeSetPriorityThread(PKTHREAD ioThread, KPRIORITY inPriority) -> KPRIORITY #DISPATCH_LEVEL
KeSetSystemAffinityThread(KAFFINITY inAffinity) -> VOID #APC_LEVEL
KeSetSystemAffinityThreadEx(KAFFINITY inAffinity) -> KAFFINITY #APC_LEVEL
KeSetSystemGroupAffinityThread(PGROUP_AFFINITY inAffinity, PGROUP_AFFINITY outPreviousAffinity) -> VOID #APC_LEVEL
KeSetTimer(PKTIMER ioTimer, LARGE_INTEGER inDueTime, PKDPC inDpc) -> BOOLEAN #DISPATCH_LEVEL
KeSetTimerEx(PKTIMER ioTimer, LARGE_INTEGER inDueTime, LONG inPeriod, PKDPC inDpc) -> BOOLEAN #DISPATCH_LEVEL
KeStackAttachProcess(PRKPROCESS ioPROCESS, PRKAPC_STATE outApcState) -> VOID #APC_LEVEL
KeSynchronizeExecution(PKINTERRUPT ioInterrupt, PKSYNCHRONIZE_ROUTINE inSynchronizeRoutine, PVOID inSynchronizeContext) -> BOOLEAN #HIGH_LEVEL
KeTryToAcquireGuardedMutex(PKGUARDED_MUTEX ioMutex) -> ) BOOLEAN #APC_LEVEL
KeUnstackDetachProcess(PRKAPC_STATE inApcState) -> VOID #APC_LEVEL
KeWaitForMultipleObjects(ULONG inCount, PVOID Object[], WAIT_TYPE inWaitType, KWAIT_REASON inWaitReason, KPROCESSOR_MODE inWaitMode, BOOLEAN inAlertable, PLARGE_INTEGER inTimeout, PKWAIT_BLOCK outWaitBlockArray) -> NTSTATUS # DISPATCH_LEVEL
KeWaitForSingleObject(PVOID inObject, KWAIT_REASON inWaitReason, KPROCESSOR_MODE inWaitMode, BOOLEAN inAlertable, PLARGE_INTEGER inTimeout) -> NTSTATUS # DISPATCH_LEVEL
KfAcquireSpinLock(PKSPIN_LOCK ioSpinLock) -> FASTCALL #DISPATCH_LEVEL
KfLowerIrql(KIRQL inNewIrql) -> FASTCALL #HIGH_LEVEL
KfRaiseIrql(KIRQL inNewIrql) -> FASTCALL #HIGH_LEVEL
KsCreateBusEnumObject(PWSTR inBusIdentifier, PDEVICE_OBJECT inBusDeviceObject, PDEVICE_OBJECT inPhysicalDeviceObject, PDEVICE_OBJECT inPnpDeviceObject, REFGUID inInterfaceGuid, PWSTR inServiceRelativePath) -> NTSTATUS #PASSIVE_LEVEL
KsGetBusEnumParentFDOFromChildPDO(PDEVICE_OBJECT inDeviceObject, PDEVICE_OBJECT out*FunctionalDeviceObject) -> NTSTATUS #PASSIVE_LEVEL
KsGetBusEnumPnpDeviceObject(PDEVICE_OBJECT inDeviceObject, PDEVICE_OBJECT out*PnpDeviceObject) -> NTSTATUS #PASSIVE_LEVEL
KsInstallBusEnumInterface(PIRP inIrp) -> NTSTATUS #PASSIVE_LEVEL
KsIsBusEnumChildDevice(PDEVICE_OBJECT inDeviceObject, PBOOLEAN outChildDevice) -> NTSTATUS #PASSIVE_LEVEL
KsRemoveBusEnumInterface(PIRP inIrp) -> NTSTATUS #PASSIVE_LEVEL
KsServiceBusEnumCreateRequest(PDEVICE_OBJECT inDeviceObject, PIRP ioIrp) -> NTSTATUS #PASSIVE_LEVEL
KsServiceBusEnumPnpRequest(PDEVICE_OBJECT inDeviceObject, PIRP ioIrp) -> NTSTATUS #PASSIVE_LEVEL
KsiDefaultClockAddMarkEvent(PIRP inIrp, PKSEVENT_TIME_INTERVAL inEventTime, PKSEVENT_ENTRY inEventEntry) -> NTSTATUS #PASSIVE_LEVEL
KsiPropertyDefaultClockGetCorrelatedPhysicalTime(PIRP inIrp, PKSPROPERTY inProperty, PKSCORRELATED_TIME outTime) -> NTSTATUS #PASSIVE_LEVEL
KsiPropertyDefaultClockGetCorrelatedTime(PIRP inIrp, PKSPROPERTY inProperty, PKSCORRELATED_TIME outTime) -> NTSTATUS #PASSIVE_LEVEL
KsiPropertyDefaultClockGetFunctionTable(PIRP inIrp, PKSPROPERTY inProperty, PKSCLOCK_FUNCTIONTABLE outFunctionTable) -> NTSTATUS #PASSIVE_LEVEL
KsiPropertyDefaultClockGetPhysicalTime(PIRP inIrp, PKSPROPERTY inProperty, PLONGLONG outTime) -> NTSTATUS #PASSIVE_LEVEL
KsiPropertyDefaultClockGetResolution(PIRP inIrp, PKSPROPERTY inProperty, PKSRESOLUTION outResolution) -> NTSTATUS #PASSIVE_LEVEL
KsiPropertyDefaultClockGetState(PIRP inIrp, PKSPROPERTY inProperty, PKSSTATE outState) -> NTSTATUS #PASSIVE_LEVEL
KsiPropertyDefaultClockGetTime(PIRP inIrp, PKSPROPERTY inProperty, PLONGLONG outTime) -> NTSTATUS #PASSIVE_LEVEL
KsiQueryObjectCreateItemsPresent(KSDEVICE_HEADER inHeader) -> BOOLEAN #PASSIVE_LEVEL
LookupRouteInformation(VOID* inRouteLookupData, VOIDout* RouteEntry OPTIONAL, IPROUTEINFOCLASS inRouteInfoClass OPTIONAL, VOIDout* RouteInformation OPTIONAL, UINTout* RouteInfoLength OPTIONAL) -> ) LookupRouteInformation #DISPATCH_LEVEL
LsaLogonUser(HANDLE inLsaHandle, PLSA_STRING inOriginName, SECURITY_LOGON_TYPE inLogonType, ULONG inAuthenticationPackage, PVOID AuthenticationInformation, ULONG inAuthenticationInformationLength, PTOKEN_GROUPS inLocalGroups, PTOKEN_SOURCE inSourceContext, PVOID out*ProfileBuffer, PULONG outProfileBufferLength, PLUID outLogonId, PHANDLE outToken, PQUOTA_LIMITS outQuotas, PNTSTATUS outSubStatus) -> NTSTATUS #PASSIVE_LEVEL
LsaRegisterLogonProcess(PLSA_STRING inLogonProcessName, PHANDLE outLsaHandle, PLSA_OPERATIONAL_MODE outSecurityMode) -> NTSTATUS #PASSIVE_LEVEL
MmAddPhysicalMemory(PPHYSICAL_ADDRESS inStartAddress, PLARGE_INTEGER ioNumberOfBytes) -> NTSTATUS #PASSIVE_LEVEL
MmAddVerifierThunks(PVOID ThunkBuffer, ULONG inThunkBufferSize) -> NTSTATUS #APC_LEVEL
MmAdvanceMdl(PMDLX ioMdl, ULONG inNumberOfBytes) -> NTSTATUS #DISPATCH_LEVEL
MmAllocateContiguousMemory(SIZE_T inNumberOfBytes, PHYSICAL_ADDRESS inHighestAcceptableAddress) -> PVOID #DISPATCH_LEVEL
MmAllocateContiguousMemorySpecifyCache(SIZE_T inNumberOfBytes, PHYSICAL_ADDRESS inLowestAcceptableAddress, PHYSICAL_ADDRESS inHighestAcceptableAddress, PHYSICAL_ADDRESS inBoundaryAddressMultiple, MEMORY_CACHING_TYPE inCacheType) -> PVOID #DISPATCH_LEVEL
MmAllocateContiguousMemorySpecifyCacheNode(SIZE_T inNumberOfBytes, PHYSICAL_ADDRESS inLowestAcceptableAddress, PHYSICAL_ADDRESS inHighestAcceptableAddress, PHYSICAL_ADDRESS inBoundaryAddressMultiple, MEMORY_CACHING_TYPE inCacheType, NODE_REQUIREMENT inPreferredNode) -> PVOID #DISPATCH_LEVEL
MmAllocateMappingAddress(SIZE_T inNumberOfBytes, ULONG inPoolTag) -> PVOID #APC_LEVEL
MmAllocateNonCachedMemory(SIZE_T inNumberOfBytes) -> PVOID #APC_LEVEL
MmAllocatePagesForMdl(PHYSICAL_ADDRESS inLowAddress, PHYSICAL_ADDRESS inHighAddress, PHYSICAL_ADDRESS inSkipBytes, SIZE_T inTotalBytes) -> PMDL #DISPATCH_LEVEL
MmAllocatePagesForMdlEx(PHYSICAL_ADDRESS inLowAddress, PHYSICAL_ADDRESS inHighAddress, PHYSICAL_ADDRESS inSkipBytes, SIZE_T inTotalBytes, MEMORY_CACHING_TYPE inCacheType, ULONG inFlags) -> PMDL #DISPATCH_LEVEL
MmBuildMdlForNonPagedPool(PMDLX ioMemoryDescriptorList) -> VOID #DISPATCH_LEVEL
MmCanFileBeTruncated(PSECTION_OBJECT_POINTERS inSectionPointer, PLARGE_INTEGER inNewFileSize) -> BOOLEAN #APC_LEVEL
MmCreateMirror(VOID) -> NTSTATUS #PASSIVE_LEVEL
MmDoesFileHaveUserWritableReferences(PSECTION_OBJECT_POINTERS inSectionPointer) -> ULONG #APC_LEVEL
MmFlushImageSection(PSECTION_OBJECT_POINTERS inSectionObjectPointer, MMFLUSH_TYPE inFlushType) -> BOOLEAN #APC_LEVEL
MmForceSectionClosed(PSECTION_OBJECT_POINTERS inSectionObjectPointer, BOOLEAN inDelayClose) -> BOOLEAN #APC_LEVEL
MmFreeContiguousMemory(PVOID inBaseAddress) -> VOID #DISPATCH_LEVEL
MmFreeContiguousMemorySpecifyCache(PVOID BaseAddress, SIZE_T inNumberOfBytes, MEMORY_CACHING_TYPE inCacheType) -> VOID #DISPATCH_LEVEL
MmFreeMappingAddress(PVOID inBaseAddress, ULONG inPoolTag) -> VOID #APC_LEVEL
MmFreeNonCachedMemory(PVOID BaseAddress, SIZE_T inNumberOfBytes) -> VOID #APC_LEVEL
MmFreePagesFromMdl(PMDLX inMemoryDescriptorList) -> VOID #DISPATCH_LEVEL
MmGetPhysicalMemoryRanges(VOID) -> PPHYSICAL_MEMORY_RANGE #PASSIVE_LEVEL
MmGetSystemRoutineAddress(PUNICODE_STRING inSystemRoutineName) -> PVOID #PASSIVE_LEVEL
MmIsAddressValid(PVOID inVirtualAddress) -> BOOLEAN #DISPATCH_LEVEL
MmIsDriverVerifyingByAddress(PVOID inAddressWithinSection) -> LOGICAL #APC_LEVEL
MmIsIoSpaceActive(PHYSICAL_ADDRESS inStartAddress, SIZE_T inNumberOfBytes) -> LOGICAL #DISPATCH_LEVEL
MmIsVerifierEnabled(PULONG outVerifierFlags) -> NTSTATUS #APC_LEVEL
MmLockPagableDataSection(PVOID inAddressWithinSection) -> PVOID #APC_LEVEL
MmLockPagableSectionByHandle(PVOID inImageSectionHandle) -> VOID #APC_LEVEL
MmMapIoSpace(PHYSICAL_ADDRESS inPhysicalAddress, SIZE_T inNumberOfBytes, MEMORY_CACHING_TYPE inCacheType) -> PVOID #DISPATCH_LEVEL
MmMapLockedPages(PMDL inMemoryDescriptorList, KPROCESSOR_MODE inAccessMode) -> PVOID # APC_LEVEL
MmMapLockedPagesSpecifyCache(PMDLX inMemoryDescriptorList, KPROCESSOR_MODE inAccessMode, MEMORY_CACHING_TYPE inCacheType, PVOID inBaseAddress, ULONG inBugCheckOnFailure, MM_PAGE_PRIORITY inPriority) -> PVOID # APC_LEVEL
MmMapLockedPagesWithReservedMapping(PVOID inMappingAddress, ULONG inPoolTag, PMDLX inMemoryDescriptorList, MEMORY_CACHING_TYPE inCacheType) -> PVOID #DISPATCH_LEVEL
MmMapUserAddressesToPage(PVOID BaseAddress, SIZE_T inNumberOfBytes, PVOID inPageAddress) -> NTSTATUS #APC_LEVEL
MmMapVideoDisplay(PHYSICAL_ADDRESS inPhysicalAddress, SIZE_T inNumberOfBytes, MEMORY_CACHING_TYPE inCacheType) -> PVOID #APC_LEVEL
MmMapViewInSessionSpace(PVOID inSection, PVOID *MappedBase, PSIZE_T ioViewSize) -> NTSTATUS #APC_LEVEL
MmMapViewInSystemSpace(PVOID inSection, PVOID *MappedBase, PSIZE_T ioViewSize) -> NTSTATUS #APC_LEVEL
MmPageEntireDriver(PVOID inAddressWithinSection) -> PVOID #APC_LEVEL
MmPrefetchPages(ULONG inNumberOfLists, PREAD_LIST *ReadLists) -> NTSTATUS #PASSIVE_LEVEL
MmProbeAndLockPages(PMDLX ioMemoryDescriptorList, KPROCESSOR_MODE inAccessMode, LOCK_OPERATION inOperation) -> VOID #DISPATCH_LEVEL
MmProbeAndLockProcessPages(PMDL ioMemoryDescriptorList, PEPROCESS inProcess, KPROCESSOR_MODE inAccessMode, LOCK_OPERATION inOperation) -> VOID #APC_LEVEL
MmProtectMdlSystemAddress(PMDLX inMemoryDescriptorList, ULONG inNewProtect) -> NTSTATUS #DISPATCH_LEVEL
MmRemovePhysicalMemory(PPHYSICAL_ADDRESS inStartAddress, PLARGE_INTEGER ioNumberOfBytes) -> NTSTATUS #PASSIVE_LEVEL
MmResetDriverPaging(PVOID inAddressWithinSection) -> VOID #APC_LEVEL
MmRotatePhysicalView(PVOID inVirtualAddress, PSIZE_T ioNumberOfBytes, PMDLX inNewMdl, MM_ROTATE_DIRECTION inDirection, PMM_ROTATE_COPY_CALLBACK_FUNCTION inCopyFunction, PVOID inContext) -> NTSTATUS #APC_LEVEL
MmSecureVirtualMemory(PVOID Address, SIZE_T inSize, ULONG inProbeMode) -> : MmSecureVirtualMemory #APC_LEVEL
MmSetAddressRangeModified(PVOID Address, SIZE_T inLength) -> BOOLEAN #APC_LEVEL
MmUnlockPagableImageSection(PVOID inImageSectionHandle) -> VOID #DISPATCH_LEVEL
MmUnlockPages(PMDLX ioMemoryDescriptorList) -> VOID #DISPATCH_LEVEL
MmUnmapIoSpace(PVOID BaseAddress, SIZE_T inNumberOfBytes) -> VOID #DISPATCH_LEVEL
MmUnmapLockedPages(PVOID inBaseAddress, PMDL inMemoryDescriptorList) -> VOID #DISPATCH_LEVEL
MmUnmapReservedMapping(PVOID inBaseAddress, ULONG inPoolTag, PMDLX inMemoryDescriptorList) -> VOID #DISPATCH_LEVEL
MmUnmapVideoDisplay(PVOID BaseAddress, SIZE_T inNumberOfBytes) -> VOID #APC_LEVEL
MmUnmapViewInSessionSpace(PVOID inMappedBase) -> NTSTATUS #APC_LEVEL
MmUnmapViewInSystemSpace(PVOID inMappedBase) -> NTSTATUS #APC_LEVEL
MmUnsecureVirtualMemory(HANDLE inSecureHandle) -> VOID #APC_LEVEL
NdisAcquireReadWriteLock(PNDIS_RW_LOCK ioLock, BOOLEAN infWrite,# TRUE -> Write, FALSE -> Read -> VOID //outDISPATCH_LEVEL
NdisAdjustNetBufferCurrentMdl(PNET_BUFFER inNetBuffer) -> VOID #DISPATCH_LEVEL
NdisAdvanceNetBufferDataStart(PNET_BUFFER inNetBuffer, ULONG inDataOffsetDelta, BOOLEAN inFreeMdl, NET_BUFFER_FREE_MDL_HANDLER inFreeMdlHandler) -> VOID #DISPATCH_LEVEL
NdisAdvanceNetBufferListDataStart(PNET_BUFFER_LIST inNetBufferList, ULONG inDataOffsetDelta, BOOLEAN inFreeMdl, NET_BUFFER_FREE_MDL_HANDLER inFreeMdlMdlHandler) -> VOID #DISPATCH_LEVEL
NdisAllocateBuffer(PNDIS_STATUS outStatus, PNDIS_BUFFER out* Buffer, NDIS_HANDLE inPoolHandle, PVOID VirtualAddress, UINT inLength) -> VOID #DISPATCH_LEVEL
NdisAllocateBufferPool(PNDIS_STATUS outStatus, PNDIS_HANDLE outPoolHandle, UINT inNumberOfDescriptors) -> VOID #DISPATCH_LEVEL
NdisAllocateCloneNetBufferList(PNET_BUFFER_LIST inOriginalNetBufferList, NDIS_HANDLE inNetBufferListPoolHandle, NDIS_HANDLE inNetBufferPoolHandle, ULONG inAllocateCloneFlags) -> PNET_BUFFER_LIST #DISPATCH_LEVEL
NdisAllocateFragmentNetBufferList(PNET_BUFFER_LIST inOriginalNetBufferList, NDIS_HANDLE inNetBufferListPool, NDIS_HANDLE inNetBufferPool, ULONG inStartOffset, ULONG inMaximumLength, ULONG inDataOffsetDelta, ULONG inDataBackFill, ULONG inAllocateFragmentFlags) -> PNET_BUFFER_LIST #DISPATCH_LEVEL
NdisAllocateIoWorkItem(NDIS_HANDLE inNdisObjectHandle) -> NDIS_HANDLE #DISPATCH_LEVEL
NdisAllocateMdl(NDIS_HANDLE inNdisHandle, PVOID VirtualAddress, UINT inLength) -> PMDL #DISPATCH_LEVEL
NdisAllocateMemory(PVOID * VirtualAddress, UINT inLength, UINT inMemoryFlags, NDIS_PHYSICAL_ADDRESS inHighestAcceptableAddress) -> NDIS_STATUS #DISPATCH_LEVEL
NdisAllocateMemoryWithTag(PVOID * VirtualAddress, UINT inLength, ULONG inTag) -> NDIS_STATUS #DISPATCH_LEVEL
NdisAllocateMemoryWithTagPriority(NDIS_HANDLE inNdisHandle, UINT inLength, ULONG inTag, EX_POOL_PRIORITY inPriority) -> PVOID #DISPATCH_LEVEL
NdisAllocateNetBuffer(NDIS_HANDLE inPoolHandle, PMDL inMdlChain, ULONG inDataOffset, SIZE_T inDataLength) -> PNET_BUFFER #DISPATCH_LEVEL
NdisAllocateNetBufferAndNetBufferList(NDIS_HANDLE inPoolHandle, USHORT inContextSize, USHORT inContextBackFill, PMDL inMdlChain, ULONG inDataOffset, SIZE_T inDataLength) -> PNET_BUFFER_LIST #DISPATCH_LEVEL
NdisAllocateNetBufferList(NDIS_HANDLE inPoolHandle, USHORT inContextSize, USHORT inContextBackFill) -> PNET_BUFFER_LIST #DISPATCH_LEVEL
NdisAllocateNetBufferListContext(PNET_BUFFER_LIST inNetBufferList, USHORT inContextSize, USHORT inContextBackFill, ULONG inPoolTag) -> NDIS_STATUS #DISPATCH_LEVEL
NdisAllocateNetBufferListPool(NDIS_HANDLE inNdisHandle, PNET_BUFFER_LIST_POOL_PARAMETERS inParameters) -> NDIS_HANDLE #DISPATCH_LEVEL
NdisAllocateNetBufferMdlAndData(NDIS_HANDLE inPoolHandle) -> PNET_BUFFER #DISPATCH_LEVEL
NdisAllocateNetBufferPool(NDIS_HANDLE inNdisHandle, PNET_BUFFER_POOL_PARAMETERS inParameters) -> NDIS_HANDLE #DISPATCH_LEVEL
NdisAllocatePacket(PNDIS_STATUS outStatus, PNDIS_PACKET out* Packet, NDIS_HANDLE inPoolHandle) -> VOID #DISPATCH_LEVEL
NdisAllocatePacketPool(PNDIS_STATUS outStatus, PNDIS_HANDLE outPoolHandle, UINT inNumberOfDescriptors, UINT inProtocolReservedLength) -> VOID #DISPATCH_LEVEL
NdisAllocatePacketPoolEx(PNDIS_STATUS outStatus, PNDIS_HANDLE outPoolHandle, UINT inNumberOfDescriptors, UINT inNumberOfOverflowDescriptors, UINT inProtocolReservedLength) -> VOID #DISPATCH_LEVEL
NdisAllocateReassembledNetBufferList(PNET_BUFFER_LIST inFagmentNetBufferList, NDIS_HANDLE inNetBufferAndNetBufferListPoolHandle, ULONG inStartOffset, ULONG inDataOffsetDelta, ULONG inDataBackFill, ULONG inAllocateReassembleFlags) -> PNET_BUFFER_LIST #DISPATCH_LEVEL
NdisAllocateTimerObject(NDIS_HANDLE inNdisHandle, PNDIS_TIMER_CHARACTERISTICS inTimerCharacteristics, PNDIS_HANDLE outpTimerObject) -> NDIS_STATUS #DISPATCH_LEVEL
NdisCancelDirectOidRequest(NDIS_HANDLE inNdisBindingHandle, PVOID inRequestId) -> VOID #DISPATCH_LEVEL
NdisCancelOidRequest(NDIS_HANDLE inNdisBindingHandle, PVOID inRequestId) -> VOID #DISPATCH_LEVEL
NdisCancelSendNetBufferLists(NDIS_HANDLE inNdisBindingHandle, PVOID inCancelId) -> VOID #DISPATCH_LEVEL
NdisCancelSendPackets(NDIS_HANDLE inNdisBindingHandle, PVOID inCancelId) -> VOID #DISPATCH_LEVEL
NdisCancelTimer(PNDIS_TIMER inTimer, PBOOLEAN outTimerCancelled) -> VOID #DISPATCH_LEVEL
NdisCancelTimerObject(NDIS_HANDLE inTimerObject) -> BOOLEAN #DISPATCH_LEVEL
NdisClAddParty(NDIS_HANDLE inNdisVcHandle, NDIS_HANDLE inProtocolPartyContext, PCO_CALL_PARAMETERS ioCallParameters, PNDIS_HANDLE outNdisPartyHandle) -> NDIS_STATUS #DISPATCH_LEVEL
NdisClCloseAddressFamily(NDIS_HANDLE inNdisAfHandle) -> NDIS_STATUS #DISPATCH_LEVEL
NdisClCloseCall(NDIS_HANDLE inNdisVcHandle, NDIS_HANDLE inNdisPartyHandle, PVOID inBuffer, UINT inSize) -> NDIS_STATUS #DISPATCH_LEVEL
NdisClDeregisterSap(NDIS_HANDLE inNdisSapHandle) -> NDIS_STATUS #DISPATCH_LEVEL
NdisClDropParty(NDIS_HANDLE inNdisPartyHandle, PVOID inBuffer, UINT inSize) -> NDIS_STATUS #DISPATCH_LEVEL
NdisClGetProtocolVcContextFromTapiCallId(UNICODE_STRING inTapiCallId, PNDIS_HANDLE outProtocolVcContext) -> NDIS_STATUS #DISPATCH_LEVEL
NdisClIncomingCallComplete(NDIS_STATUS inStatus, NDIS_HANDLE inNdisVcHandle, PCO_CALL_PARAMETERS inCallParameters) -> VOID #DISPATCH_LEVEL
NdisClMakeCall(NDIS_HANDLE inNdisVcHandle, PCO_CALL_PARAMETERS ioCallParameters, NDIS_HANDLE inProtocolPartyContext, PNDIS_HANDLE outNdisPartyHandle ) -> NDIS_STATUS #DISPATCH_LEVEL
NdisClModifyCallQoS(NDIS_HANDLE inNdisVcHandle, PCO_CALL_PARAMETERS inCallParameters) -> NDIS_STATUS #DISPATCH_LEVEL
NdisClNotifyCloseAddressFamilyComplete(NDIS_HANDLE inNdisAfHandle, NDIS_STATUS inStatus) -> VOID #DISPATCH_LEVEL
NdisClRegisterSap(NDIS_HANDLE inNdisAfHandle, NDIS_HANDLE inProtocolSapContext, PCO_SAP inSap, PNDIS_HANDLE outNdisSapHandle) -> NDIS_STATUS #DISPATCH_LEVEL
NdisCmActivateVc(NDIS_HANDLE inNdisVcHandle, PCO_CALL_PARAMETERS ioCallParameters) -> NDIS_STATUS #DISPATCH_LEVEL
NdisCmAddPartyComplete(NDIS_STATUS inStatus, NDIS_HANDLE inNdisPartyHandle, NDIS_HANDLE inCallMgrPartyContext, PCO_CALL_PARAMETERS inCallParameters) -> VOID #DISPATCH_LEVEL
NdisCmCloseAddressFamilyComplete(NDIS_STATUS inStatus, NDIS_HANDLE inNdisAfHandle) -> VOID #DISPATCH_LEVEL
NdisCmCloseCallComplete(NDIS_STATUS inStatus, NDIS_HANDLE inNdisVcHandle, NDIS_HANDLE inNdisPartyHandle) -> VOID #DISPATCH_LEVEL
NdisCmDeactivateVc(NDIS_HANDLE inNdisVcHandle) -> NDIS_STATUS #DISPATCH_LEVEL
NdisCmDeregisterSapComplete(NDIS_STATUS inStatus, NDIS_HANDLE inNdisSapHandle) -> VOID #DISPATCH_LEVEL
NdisCmDispatchCallConnected(NDIS_HANDLE inNdisVcHandle) -> VOID #DISPATCH_LEVEL
NdisCmDispatchIncomingCall(NDIS_HANDLE inNdisSapHandle, NDIS_HANDLE inNdisVcHandle, PCO_CALL_PARAMETERS inCallParameters) -> NDIS_STATUS #DISPATCH_LEVEL
NdisCmDispatchIncomingCallQoSChange(NDIS_HANDLE inNdisVcHandle, PCO_CALL_PARAMETERS inCallParameters) -> VOID #DISPATCH_LEVEL
NdisCmDispatchIncomingCloseCall(NDIS_STATUS inCloseStatus, NDIS_HANDLE inNdisVcHandle, PVOID inBuffer, UINT inSize) -> VOID #DISPATCH_LEVEL
NdisCmDispatchIncomingDropParty(NDIS_STATUS inDropStatus, NDIS_HANDLE inNdisPartyHandle, PVOID inBuffer, UINT inSize) -> VOID #DISPATCH_LEVEL
NdisCmDropPartyComplete(NDIS_STATUS inStatus, NDIS_HANDLE inNdisPartyHandle) -> VOID #DISPATCH_LEVEL
NdisCmMakeCallComplete(NDIS_STATUS inStatus, NDIS_HANDLE inNdisVcHandle, NDIS_HANDLE inNdisPartyHandle, NDIS_HANDLE inCallMgrPartyContext, PCO_CALL_PARAMETERS inCallParameters) -> VOID #DISPATCH_LEVEL
NdisCmModifyCallQoSComplete(NDIS_STATUS inStatus, NDIS_HANDLE inNdisVcHandle, PCO_CALL_PARAMETERS inCallParameters) -> VOID #DISPATCH_LEVEL
NdisCmOpenAddressFamilyComplete(NDIS_STATUS inStatus, NDIS_HANDLE inNdisAfHandle, NDIS_HANDLE inCallMgrAfContext) -> VOID #DISPATCH_LEVEL
NdisCmRegisterSapComplete(NDIS_STATUS inStatus, NDIS_HANDLE inNdisSapHandle, NDIS_HANDLE inCallMgrSapContext) -> VOID #DISPATCH_LEVEL
NdisCoAssignInstanceName(NDIS_HANDLE inNdisVcHandle, PNDIS_STRING inBaseInstanceName, PNDIS_STRING outVcInstanceName) -> NDIS_STATUS #DISPATCH_LEVEL
NdisCoCreateVc(NDIS_HANDLE inNdisBindingHandle, NDIS_HANDLE inNdisAfHandle, # For CM signalling VCs NDIS_HANDLE inProtocolVcContext, PNDIS_HANDLE ioNdisVcHandle) -> NDIS_STATUS //DISPATCH_LEVEL
NdisCoDeleteVc(NDIS_HANDLE inNdisVcHandle) -> NDIS_STATUS #DISPATCH_LEVEL
NdisCoGetTapiCallId(NDIS_HANDLE inNdisVcHandle, PVAR_STRING ioTapiCallId) -> NDIS_STATUS #DISPATCH_LEVEL
NdisCoOidRequest(NDIS_HANDLE inNdisBindingHandle, NDIS_HANDLE inNdisAfHandle, NDIS_HANDLE inNdisVcHandle, NDIS_HANDLE inNdisPartyHandle, PNDIS_OID_REQUEST ioOidRequest) -> NDIS_STATUS #DISPATCH_LEVEL
NdisCoOidRequestComplete(NDIS_HANDLE inNdisAfHandle, NDIS_HANDLE inNdisVcHandle, NDIS_HANDLE inNdisPartyHandle, PNDIS_OID_REQUEST inOidRequest, NDIS_STATUS inStatus) -> VOID #DISPATCH_LEVEL
NdisCoRequest(NDIS_HANDLE inNdisBindingHandle, NDIS_HANDLE inNdisAfHandle, NDIS_HANDLE inNdisVcHandle, NDIS_HANDLE inNdisPartyHandle, PNDIS_REQUEST ioNdisRequest) -> NDIS_STATUS #DISPATCH_LEVEL
NdisCoRequestComplete(NDIS_STATUS inStatus, NDIS_HANDLE inNdisAfHandle, NDIS_HANDLE inNdisVcHandle, NDIS_HANDLE inNdisPartyHandle, PNDIS_REQUEST inNdisRequest) -> VOID #DISPATCH_LEVEL
NdisCoSendNetBufferLists(NDIS_HANDLE inNdisVcHandle, PNET_BUFFER_LIST inNetBufferLists, ULONG inSendFlags) -> VOID #DISPATCH_LEVEL
NdisCoSendPackets(NDIS_HANDLE inNdisVcHandle, PPNDIS_PACKET inPacketArray, UINT inNumberOfPackets) -> VOID #DISPATCH_LEVEL
NdisCompleteBindAdapterEx(NDIS_HANDLE inBindAdapterContext, NDIS_STATUS inStatus) -> VOID #DISPATCH_LEVEL
NdisCompleteUnbindAdapterEx(NDIS_HANDLE inUnbindContext) -> VOID #DISPATCH_LEVEL
NdisCopyBuffer(PNDIS_STATUS outStatus, PNDIS_BUFFER out* Buffer, NDIS_HANDLE inPoolHandle, PVOID inMemoryDescriptor, UINT inOffset, UINT inLength) -> VOID #DISPATCH_LEVEL
NdisCopyFromNetBufferToNetBuffer(PNET_BUFFER inDestination, ULONG inDestinationOffset, ULONG inBytesToCopy, PNET_BUFFER inSource, ULONG inSourceOffset, PULONG outBytesCopied) -> NDIS_STATUS #DISPATCH_LEVEL
NdisCopyFromPacketToPacket(PNDIS_PACKET inDestination, UINT inDestinationOffset, UINT inBytesToCopy, PNDIS_PACKET inSource, UINT inSourceOffset, PUINT outBytesCopied) -> VOID #DISPATCH_LEVEL
NdisCopyReceiveNetBufferListInfo(PNET_BUFFER_LIST inDestNetBufferList, PNET_BUFFER_LIST inSrcNetBufferList) -> VOID #DISPATCH_LEVEL
NdisCopySendNetBufferListInfo(PNET_BUFFER_LIST inDestNetBufferList, PNET_BUFFER_LIST inSrcNetBufferList) -> VOID #DISPATCH_LEVEL
NdisDeregisterProtocol(PNDIS_STATUS outStatus, NDIS_HANDLE inNdisProtocolHandle) -> VOID #DISPATCH_LEVEL
NdisDirectOidRequest(NDIS_HANDLE inNdisBindingHandle, PNDIS_OID_REQUEST inOidRequest) -> NDIS_STATUS #DISPATCH_LEVEL
NdisDprAllocatePacket(PNDIS_STATUS outStatus, PNDIS_PACKETout* Packet, NDIS_HANDLE inPoolHandle) -> VOID #DISPATCH_LEVEL
NdisDprAllocatePacketNonInterlocked(PNDIS_STATUS outStatus, PNDIS_PACKET out* Packet, NDIS_HANDLE inPoolHandle) -> VOID #DISPATCH_LEVEL
NdisDprFreePacket(PNDIS_PACKET inPacket) -> VOID #DISPATCH_LEVEL
NdisDprFreePacketNonInterlocked(PNDIS_PACKET inPacket) -> VOID #DISPATCH_LEVEL
NdisFCancelDirectOidRequest(NDIS_HANDLE inNdisFilterHandle, PVOID inRequestId) -> VOID #DISPATCH_LEVEL
NdisFCancelOidRequest(NDIS_HANDLE inNdisFilterHandle, PVOID inRequestId) -> VOID #DISPATCH_LEVEL
NdisFCancelSendNetBufferLists(NDIS_HANDLE inNdisFilterHandle, PVOID inCancelId) -> VOID #DISPATCH_LEVEL
NdisFDeregisterFilterDriver(NDIS_HANDLE inNdisFilterDriverHandle) -> VOID #PASSIVE_LEVEL
NdisFDevicePnPEventNotify(NDIS_HANDLE inNdisFilterHandle, PNET_DEVICE_PNP_EVENT inNetDevicePnPEvent) -> VOID #PASSIVE_LEVEL
NdisFDirectOidRequest(NDIS_HANDLE inNdisFilterHandle, PNDIS_OID_REQUEST inOidRequest) -> NDIS_STATUS #DISPATCH_LEVEL
NdisFDirectOidRequestComplete(NDIS_HANDLE inNdisFilterHandle, PNDIS_OID_REQUEST inOidRequest, NDIS_STATUS inStatus) -> VOID #DISPATCH_LEVEL
NdisFIndicateReceiveNetBufferLists(NDIS_HANDLE inNdisFilterHandle, PNET_BUFFER_LIST inNetBufferLists, NDIS_PORT_NUMBER inPortNumber, ULONG inNumberOfNetBufferLists, ULONG inReceiveFlags) -> VOID #DISPATCH_LEVEL
NdisFIndicateStatus(NDIS_HANDLE inNdisFilterHandle, PNDIS_STATUS_INDICATION inStatusIndication) -> VOID #DISPATCH_LEVEL
NdisFNetPnPEvent(NDIS_HANDLE inNdisFilterHandle, PNET_PNP_EVENT_NOTIFICATION inNetPnPEventNotification) -> NDIS_STATUS #PASSIVE_LEVEL
NdisFOidRequest(NDIS_HANDLE inNdisFilterHandle, PNDIS_OID_REQUEST inOidRequest) -> NDIS_STATUS #DISPATCH_LEVEL
NdisFOidRequestComplete(NDIS_HANDLE inNdisFilterHandle, PNDIS_OID_REQUEST inOidRequest, NDIS_STATUS inStatus) -> VOID #DISPATCH_LEVEL
NdisFPauseComplete(NDIS_HANDLE inNdisFilterHandle) -> VOID #DISPATCH_LEVEL
NdisFRegisterFilterDriver(PDRIVER_OBJECT inDriverObject, NDIS_HANDLE inFilterDriverContext, PNDIS_FILTER_DRIVER_CHARACTERISTICS inFilterDriverCharacteristics, PNDIS_HANDLE outNdisFilterDriverHandle) -> NDIS_STATUS #PASSIVE_LEVEL
NdisFRestartComplete(NDIS_HANDLE inNdisFilterHandle, NDIS_STATUS inStatus) -> VOID #PASSIVE_LEVEL
NdisFRestartFilter(NDIS_HANDLE inNdisFilterHandle) -> NDIS_STATUS #DISPATCH_LEVEL
NdisFReturnNetBufferLists(NDIS_HANDLE inNdisFilterHandle, PNET_BUFFER_LIST inNetBufferLists, ULONG inReturnFlags) -> VOID #DISPATCH_LEVEL
NdisFSendNetBufferLists(NDIS_HANDLE inNdisFilterHandle, PNET_BUFFER_LIST inNetBufferList, NDIS_PORT_NUMBER inPortNumber, ULONG inSendFlags) -> VOID #DISPATCH_LEVEL
NdisFSendNetBufferListsComplete(NDIS_HANDLE inNdisFilterHandle, PNET_BUFFER_LIST inNetBufferList, ULONG inSendCompleteFlags) -> VOID #DISPATCH_LEVEL
NdisFSetAttributes(NDIS_HANDLE inNdisFilterHandle, NDIS_HANDLE inFilterModuleContext, PNDIS_FILTER_ATTRIBUTES inFilterAttributes) -> NDIS_STATUS #PASSIVE_LEVEL
NdisFreeBufferPool(NDIS_HANDLE inPoolHandle) -> VOID #DISPATCH_LEVEL
NdisFreeCloneNetBufferList(PNET_BUFFER_LIST inCloneNetBufferList, ULONG inFreeCloneFlags) -> VOID #DISPATCH_LEVEL
NdisFreeFragmentNetBufferList(PNET_BUFFER_LIST inFragmentNetBufferList, ULONG inDataOffsetDelta, ULONG inFreeFragmentFlags) -> VOID #DISPATCH_LEVEL
NdisFreeIoWorkItem(NDIS_HANDLE inNdisIoWorkItemHandle) -> VOID #DISPATCH_LEVEL
NdisFreeMdl(PMDL inMdl) -> VOID #DISPATCH_LEVEL
NdisFreeMemory(PVOID VirtualAddress, UINT inLength, UINT inMemoryFlags) -> VOID # PASSIVE_LEVEL
NdisFreeNetBuffer(PNET_BUFFER inNetBuffer) -> VOID #DISPATCH_LEVEL
NdisFreeNetBufferList(PNET_BUFFER_LIST inNetBufferList) -> VOID #DISPATCH_LEVEL
NdisFreeNetBufferListContext(PNET_BUFFER_LIST inNetBufferList, USHORT inContextSize) -> VOID #DISPATCH_LEVEL
NdisFreeNetBufferListPool(NDIS_HANDLE inPoolHandle) -> VOID #DISPATCH_LEVEL
NdisFreeNetBufferPool(NDIS_HANDLE inPoolHandle) -> VOID #DISPATCH_LEVEL
NdisFreePacket(PNDIS_PACKET inPacket) -> VOID #DISPATCH_LEVEL
NdisFreePacketPool(NDIS_HANDLE inPoolHandle) -> VOID #DISPATCH_LEVEL
NdisFreeReassembledNetBufferList(PNET_BUFFER_LIST inReassembledNetBufferList, ULONG inDataOffsetDelta, ULONG inFreeReassembleFlags) -> VOID #DISPATCH_LEVEL
NdisFreeTimerObject(NDIS_HANDLE inTimerObject) -> VOID #DISPATCH_LEVEL
NdisGeneratePartialCancelId(VOID) -> UCHAR #DISPATCH_LEVEL
NdisGetCurrentProcessorCounts(PULONG outpIdleCount, PULONG outpKernelAndUser, PULONG outpIndex) -> VOID #DISPATCH_LEVEL
NdisGetDataBuffer(PNET_BUFFER inNetBuffer, ULONG inBytesNeeded, PVOID inStorage, UINT inAlignMultiple, UINT inAlignOffset) -> PVOID #DISPATCH_LEVEL
NdisGetDriverHandle(NDIS_HANDLE inNdisBindingHandle, PNDIS_HANDLE outNdisDriverHandle) -> VOID #DISPATCH_LEVEL
NdisGetNetBufferListProtocolId(PNET_BUFFER_LIST inNetBufferList) -> UCHAR #DISPATCH_LEVEL
NdisGetPoolFromNetBuffer(PNET_BUFFER inNetBuffer) -> NDIS_HANDLE #DISPATCH_LEVEL
NdisGetPoolFromNetBufferList(PNET_BUFFER_LIST inNetBufferList) -> NDIS_HANDLE #DISPATCH_LEVEL
NdisGetPoolFromPacket(PNDIS_PACKET inPacket) -> NDIS_HANDLE #DISPATCH_LEVEL
NdisGetReceivedPacket(NDIS_HANDLE inNdisBindingHandle, NDIS_HANDLE inMacContext) -> PNDIS_PACKET #DISPATCH_LEVEL
NdisGetSharedDataAlignment(VOID) -> ULONG #DISPATCH_LEVEL
NdisGetVersion(VOID) -> UINT #DISPATCH_LEVEL
NdisIMGetBindingContext(NDIS_HANDLE inNdisBindingHandle) -> NDIS_HANDLE #APC_LEVEL
NdisIMGetCurrentPacketStack(PNDIS_PACKET inPacket, BOOLEAN out* StacksRemaining) -> PNDIS_PACKET_STACK #DISPATCH_LEVEL
NdisIMGetDeviceContext(NDIS_HANDLE inMiniportAdapterHandle) -> NDIS_HANDLE #DISPATCH_LEVEL
NdisIfAddIfStackEntry(NET_IFINDEX inHigherLayerIfIndex, NET_IFINDEX inLowerLayerIfIndex) -> NDIS_STATUS #PASSIVE_LEVEL
NdisIfAllocateNetLuidIndex(NET_IFTYPE inifType, PUINT32 outpNetLuidIndex) -> NDIS_STATUS #PASSIVE_LEVEL
NdisIfDeleteIfStackEntry(NET_IFINDEX inHigherLayerIfIndex, NET_IFINDEX inLowerLayerIfIndex) -> VOID #PASSIVE_LEVEL
NdisIfDeregisterInterface(NET_IFINDEX inifIndex) -> VOID #PASSIVE_LEVEL
NdisIfDeregisterProvider(NDIS_HANDLE inNdisProviderHandle) -> VOID #PASSIVE_LEVEL
NdisIfFreeNetLuidIndex(NET_IFTYPE inifType, UINT32 inNetLuidIndex) -> NDIS_STATUS #PASSIVE_LEVEL
NdisIfGetInterfaceIndexFromNetLuid(NET_LUID inNetLuid, PNET_IFINDEX outpIfIndex) -> NDIS_STATUS #PASSIVE_LEVEL
NdisIfGetNetLuidFromInterfaceIndex(NET_IFINDEX inifIndex, PNET_LUID outpNetLuid) -> NDIS_STATUS #PASSIVE_LEVEL
NdisIfQueryBindingIfIndex(NDIS_HANDLE inNdisBindingHandle, PNET_IFINDEX outpBoundIfIndex, PNET_LUID outpBoundIfNetLuid, PNET_IFINDEX outpLowestIfIndex, PNET_LUID outpLowestIfNetLuid) -> NDIS_STATUS #PASSIVE_LEVEL
NdisIfRegisterInterface(NDIS_HANDLE inNdisProviderHandle, NET_LUID inNetLuid, NDIS_HANDLE inProviderIfContext, PNET_IF_INFORMATION inpIfInfo, PNET_IFINDEX outpfIndex) -> NDIS_STATUS #PASSIVE_LEVEL
NdisIfRegisterProvider(PNDIS_IF_PROVIDER_CHARACTERISTICS inProviderCharacteristics, NDIS_HANDLE inIfProviderContext, PNDIS_HANDLE outpNdisIfProviderHandle) -> NDIS_STATUS #PASSIVE_LEVEL
NdisInitializeEvent(PNDIS_EVENT outEvent) -> VOID #DISPATCH_LEVEL
NdisInitializeReadWriteLock(PNDIS_RW_LOCK outLock) -> VOID #DISPATCH_LEVEL
NdisInitializeTimer(PNDIS_TIMER ioTimer, PNDIS_TIMER_FUNCTION inTimerFunction, PVOID inFunctionContext) -> VOID #DISPATCH_LEVEL
NdisMAllocatePort(NDIS_HANDLE inNdisMiniportHandle, PNDIS_PORT_CHARACTERISTICS ioPortCharacteristics) -> NDIS_STATUS #DISPATCH_LEVEL
NdisMAllocateSharedMemoryAsync(NDIS_HANDLE inMiniportAdapterHandle, ULONG inLength, BOOLEAN inCached, PVOID inContext) -> NDIS_STATUS #DISPATCH_LEVEL
NdisMCancelTimer(PNDIS_MINIPORT_TIMER inTimer, PBOOLEAN outTimerCancelled) -> VOID #DISPATCH_LEVEL
NdisMCmActivateVc(NDIS_HANDLE inNdisVcHandle, PCO_CALL_PARAMETERS inCallParameters) -> NDIS_STATUS #DISPATCH_LEVEL
NdisMCmCreateVc(NDIS_HANDLE inMiniportAdapterHandle, NDIS_HANDLE inNdisAfHandle, NDIS_HANDLE inMiniportVcContext, PNDIS_HANDLE outNdisVcHandle) -> NDIS_STATUS #DISPATCH_LEVEL
NdisMCmDeactivateVc(NDIS_HANDLE inNdisVcHandle) -> NDIS_STATUS #DISPATCH_LEVEL
NdisMCmDeleteVc(NDIS_HANDLE inNdisVcHandle) -> NDIS_STATUS #DISPATCH_LEVEL
NdisMCmRequest(NDIS_HANDLE inNdisAfHandle, NDIS_HANDLE inNdisVcHandle, NDIS_HANDLE inNdisPartyHandle, PNDIS_REQUEST ioNdisRequest) -> NDIS_STATUS #DISPATCH_LEVEL
NdisMCoActivateVcComplete(NDIS_STATUS inStatus, NDIS_HANDLE inNdisVcHandle, PCO_CALL_PARAMETERS inCallParameters) -> VOID #DISPATCH_LEVEL
NdisMCoDeactivateVcComplete(NDIS_STATUS inStatus, NDIS_HANDLE inNdisVcHandle) -> VOID #DISPATCH_LEVEL
NdisMCoIndicateReceivePacket(NDIS_HANDLE inNdisVcHandle, PPNDIS_PACKET inPacketArray, UINT inNumberOfPackets) -> VOID #DISPATCH_LEVEL
NdisMCoIndicateStatus(NDIS_HANDLE inMiniportAdapterHandle, NDIS_HANDLE inNdisVcHandle, NDIS_STATUS inGeneralStatus, PVOID inStatusBuffer, ULONG inStatusBufferSize) -> VOID #DISPATCH_LEVEL
NdisMCoReceiveComplete(NDIS_HANDLE inMiniportAdapterHandle) -> VOID #DISPATCH_LEVEL
NdisMCoRequestComplete(NDIS_STATUS inStatus, NDIS_HANDLE inMiniportAdapterHandle, PNDIS_REQUEST inRequest) -> VOID #DISPATCH_LEVEL
NdisMCoSendComplete(NDIS_STATUS inStatus, NDIS_HANDLE inNdisVcHandle, PNDIS_PACKET inPacket) -> VOID #DISPATCH_LEVEL
NdisMCompleteBufferPhysicalMapping(NDIS_HANDLE inMiniportAdapterHandle, PNDIS_BUFFER inBuffer, ULONG inPhysicalMapRegister) -> VOID #DISPATCH_LEVEL
NdisMDirectOidRequestComplete(NDIS_HANDLE inMiniportAdapterHandle, PNDIS_OID_REQUEST inOidRequest, NDIS_STATUS inStatus) -> VOID #DISPATCH_LEVEL
NdisMFlushLog(NDIS_HANDLE inLogHandle) -> VOID #DISPATCH_LEVEL
NdisMFreePort(NDIS_HANDLE inNdisMiniportHandle, NDIS_PORT_NUMBER inPortNumber) -> NDIS_STATUS #DISPATCH_LEVEL
NdisMFreeSharedMemory(NDIS_HANDLE inMiniportAdapterHandle, ULONG inLength, BOOLEAN inCached, PVOID VirtualAddress, NDIS_PHYSICAL_ADDRESS inPhysicalAddress) -> VOID #DISPATCH_LEVEL
NdisMGetBusData(NDIS_HANDLE inNdisMiniportHandle, ULONG inWhichSpace, ULONG inOffset, PVOID Buffer, ULONG inLength) -> ULONG #DISPATCH_LEVEL
NdisMIndicateReceiveNetBufferLists(NDIS_HANDLE inMiniportAdapterHandle, PNET_BUFFER_LIST inNetBufferList, NDIS_PORT_NUMBER inPortNumber, ULONG inNumberOfNetBufferLists, ULONG inReceiveFlags) -> VOID #DISPATCH_LEVEL
NdisMIndicateStatus(NDIS_HANDLE inMiniportHandle, NDIS_STATUS inGeneralStatus, PVOID StatusBuffer, UINT inStatusBufferSize) -> VOID #DISPATCH_LEVEL
NdisMIndicateStatusComplete(NDIS_HANDLE inMiniportHandle) -> VOID #DISPATCH_LEVEL
NdisMIndicateStatusEx(NDIS_HANDLE inMiniportAdapterHandle, PNDIS_STATUS_INDICATION inStatusIndication) -> VOID #DISPATCH_LEVEL
NdisMInitializeTimer(OUT inPNDIS_MINIPORT_TIMER Timer, NDIS_HANDLE inMiniportAdapterHandle, PNDIS_TIMER_FUNCTION inTimerFunction, PVOID inFunctionContext) -> VOID #DISPATCH_LEVEL
NdisMOidRequestComplete(NDIS_HANDLE inMiniportAdapterHandle, PNDIS_OID_REQUEST inOidRequest, NDIS_STATUS inStatus) -> VOID #DISPATCH_LEVEL
NdisMPauseComplete(NDIS_HANDLE inMiniportAdapterHandle) -> VOID #DISPATCH_LEVEL
NdisMPromoteMiniport(NDIS_HANDLE inMiniportHandle) -> NDIS_STATUS #DISPATCH_LEVEL
NdisMQueueDpc(NDIS_HANDLE inNdisInterruptHandle, ULONG inMessageId, ULONG inTargetProcessors, PVOID inMiniportDpcContext) -> ULONG #DISPATCH_LEVEL
NdisMReadDmaCounter(NDIS_HANDLE inMiniportDmaHandle) -> ULONG #DISPATCH_LEVEL
NdisMRemoveMiniport(NDIS_HANDLE inMiniportHandle) -> NDIS_STATUS #DISPATCH_LEVEL
NdisMResetComplete(NDIS_HANDLE inMiniportAdapterHandle, NDIS_STATUS inStatus, BOOLEAN inAddressingReset) -> VOID #DISPATCH_LEVEL
NdisMSendNetBufferListsComplete(NDIS_HANDLE inMiniportAdapterHandle, PNET_BUFFER_LIST inNetBufferList, ULONG inSendCompleteFlags) -> VOID #DISPATCH_LEVEL
NdisMSetPeriodicTimer(PNDIS_MINIPORT_TIMER inTimer, UINT inMillisecondPeriod) -> VOID #DISPATCH_LEVEL
NdisMSleep(ULONG inMicrosecondsToSleep) -> VOID #APC_LEVEL
NdisMStartBufferPhysicalMapping(NDIS_HANDLE inMiniportAdapterHandle, PNDIS_BUFFER inBuffer, ULONG inPhysicalMapRegister, BOOLEAN inWriteToDevice, PNDIS_PHYSICAL_ADDRESS_UNIT outPhysicalAddressArray, PUINT outArraySize) -> VOID #DISPATCH_LEVEL
NdisMWriteLogData(NDIS_HANDLE inLogHandle, PVOID LogBuffer, UINT inLogBufferSize) -> NDIS_STATUS #DISPATCH_LEVEL
NdisMapFile(PNDIS_STATUS outStatus, PVOID out* MappedBuffer, NDIS_HANDLE inFileHandle) -> VOID #DISPATCH_LEVEL
NdisOidRequest(NDIS_HANDLE inNdisBindingHandle, PNDIS_OID_REQUEST inOidRequest) -> NDIS_STATUS #DISPATCH_LEVEL
NdisOpenConfigurationKeyByIndex(PNDIS_STATUS outStatus, NDIS_HANDLE inConfigurationHandle, ULONG inIndex, PNDIS_STRING outKeyName, PNDIS_HANDLE outKeyHandle) -> VOID #APC_LEVEL
NdisOpenConfigurationKeyByName(PNDIS_STATUS outStatus, NDIS_HANDLE inConfigurationHandle, PNDIS_STRING inSubKeyName, PNDIS_HANDLE outSubKeyHandle) -> VOID #APC_LEVEL
NdisPacketPoolUsage(NDIS_HANDLE inPoolHandle) -> UINT #DISPATCH_LEVEL
NdisPacketSize(UINT inProtocolReservedSize) -> UINT #DISPATCH_LEVEL
NdisQueryAdapterInstanceName(PNDIS_STRING outpAdapterInstanceName, NDIS_HANDLE inNdisBindingHandle) -> NDIS_STATUS #DISPATCH_LEVEL
NdisQueryNetBufferPhysicalCount(PNET_BUFFER inNetBuffer) -> ULONG #DISPATCH_LEVEL
NdisQueryPendingIOCount(PVOID inNdisBindingHandle, PULONG outIoCount) -> NDIS_STATUS #DISPATCH_LEVEL
NdisQueueIoWorkItem(NDIS_HANDLE inNdisIoWorkItemHandle, NDIS_IO_WORKITEM_ROUTINE inRoutine, PVOID inWorkItemContext) -> VOID #DISPATCH_LEVEL
NdisReadPciSlotInformation(NDIS_HANDLE inNdisAdapterHandle, ULONG inSlotNumber, ULONG inOffset, PVOID Buffer, ULONG inLength) -> ULONG #DISPATCH_LEVEL
NdisReadPcmciaAttributeMemory(NDIS_HANDLE inNdisAdapterHandle, ULONG inOffset, PVOID Buffer, ULONG inLength) -> ULONG #DISPATCH_LEVEL
NdisReleaseReadWriteLock(PNDIS_RW_LOCK ioLock, PLOCK_STATE inLockState ) -> VOID #DISPATCH_LEVEL
NdisRequest(PNDIS_STATUS outStatus, NDIS_HANDLE inNdisBindingHandle, PNDIS_REQUEST inNdisRequest) -> PNDIS_REQUEST #DISPATCH_LEVEL
NdisReset(PNDIS_STATUS outStatus, NDIS_HANDLE inNdisBindingHandle) -> VOID #DISPATCH_LEVEL
NdisResetEvent(PNDIS_EVENT inEvent) -> VOID #DISPATCH_LEVEL
NdisRetreatNetBufferDataStart(PNET_BUFFER inNetBuffer, ULONG inDataOffsetDelta, ULONG inDataBackFill, NET_BUFFER_ALLOCATE_MDL_HANDLER inAllocateMdlHandler) -> NDIS_STATUS #DISPATCH_LEVEL
NdisRetreatNetBufferListDataStart(PNET_BUFFER_LIST inNetBufferList, ULONG inDataOffsetDelta, ULONG inDataBackFill, NET_BUFFER_ALLOCATE_MDL_HANDLER inAllocateMdlHandler, NET_BUFFER_FREE_MDL_HANDLER inFreeMdlHandler) -> NDIS_STATUS #DISPATCH_LEVEL
NdisReturnNetBufferLists(NDIS_HANDLE inNdisBindingHandle, PNET_BUFFER_LIST inNetBufferLists, ULONG inReturnFlags) -> VOID #DISPATCH_LEVEL
NdisReturnPackets(inPNDIS_PACKET * PacketsToReturn, UINT inNumberOfPackets) -> VOID #DISPATCH_LEVEL
NdisScheduleWorkItem(PNDIS_WORK_ITEM inWorkItem) -> NDIS_STATUS #DISPATCH_LEVEL
NdisSendNetBufferLists(NDIS_HANDLE inNdisBindingHandle, PNET_BUFFER_LIST inNetBufferLists, NDIS_PORT_NUMBER inPortNumber, ULONG inSendFlags) -> VOID #DISPATCH_LEVEL
NdisSetCoalescableTimerObject(NDIS_HANDLE inTimerObject, LARGE_INTEGER inDueTime, LONG inMillisecondsPeriod, PVOID inFunctionContext, ULONG inTolerance) -> BOOLEAN #DISPATCH_LEVEL
NdisSetEvent(PNDIS_EVENT inEvent) -> VOID #DISPATCH_LEVEL
NdisSetPacketPoolProtocolId(NDIS_HANDLE inPacketPoolHandle, UINT inProtocolId) -> VOID #DISPATCH_LEVEL
NdisSetPacketStatus(PNDIS_PACKET inPacket, NDIS_STATUS inStatus, NDIS_HANDLE inHandle, ULONG inCode) -> VOID #DISPATCH_LEVEL
NdisSetTimer(PNDIS_TIMER inTimer, UINT inMillisecondsToDelay) -> VOID #DISPATCH_LEVEL
NdisSetTimerEx(PNDIS_TIMER inNdisTimer, UINT inMillisecondsToDelay, PVOID inFunctionContext) -> VOID #DISPATCH_LEVEL
NdisSetTimerObject(NDIS_HANDLE inTimerObject, LARGE_INTEGER inDueTime, LONG inMillisecondsPeriod, PVOID inFunctionContext ) -> BOOLEAN #DISPATCH_LEVEL
NdisUnbindAdapter(NDIS_HANDLE inNdisBindingHandle) -> NDIS_STATUS #DISPATCH_LEVEL
NdisWriteErrorLogEntry(NDIS_HANDLE inNdisAdapterHandle, NDIS_ERROR_CODE inErrorCode, ULONG inNumberOfErrorValues, ...) -> __cdecl #DISPATCH_LEVEL
NdisWriteEventLogEntry(PVOID inLogHandle, NDIS_STATUS inEventCode, ULONG inUniqueEventValue, USHORT inNumStrings, PVOID inStringsList, ULONG inDataSize, PVOID inData ) -> NDIS_STATUS #DISPATCH_LEVEL
NdisWritePciSlotInformation(NDIS_HANDLE inNdisAdapterHandle, ULONG inSlotNumber, ULONG inOffset, PVOID Buffer, ULONG inLength) -> ULONG #DISPATCH_LEVEL
NdisWritePcmciaAttributeMemory(NDIS_HANDLE inNdisAdapterHandle, ULONG inOffset, PVOID Buffer, ULONG inLength) -> ULONG #DISPATCH_LEVEL
NewIrql(cl) -> UCHAR #HIGH_LEVEL
NtClose(HANDLE inHandle) -> NTSTATUS #PASSIVE_LEVEL
NtCommitComplete(HANDLE inEnlistmentHandle, PLARGE_INTEGER inTmVirtualClock) -> NTSTATUS #APC_LEVEL
NtCommitEnlistment(HANDLE inEnlistmentHandle, PLARGE_INTEGER inTmVirtualClock) -> NTSTATUS #APC_LEVEL
NtCommitTransaction(HANDLE inTransactionHandle, BOOLEAN inWait) -> NTSTATUS #APC_LEVEL
NtCreateEnlistment(PHANDLE outEnlistmentHandle, ACCESS_MASK inDesiredAccess, HANDLE inResourceManagerHandle, HANDLE inTransactionHandle, POBJECT_ATTRIBUTES inObjectAttributes, ULONG inCreateOptions, NOTIFICATION_MASK inNotificationMask, PVOID inEnlistmentKey) -> NTSTATUS #APC_LEVEL
NtCreateResourceManager(PHANDLE outResourceManagerHandle, ACCESS_MASK inDesiredAccess, HANDLE inTmHandle, LPGUID inRmGuid, POBJECT_ATTRIBUTES inObjectAttributes, ULONG inCreateOptions, PUNICODE_STRING inDescription) -> NTSTATUS #APC_LEVEL
NtCreateTransaction(PHANDLE outTransactionHandle, ACCESS_MASK inDesiredAccess, POBJECT_ATTRIBUTES inObjectAttributes, LPGUID inUow, HANDLE inTmHandle, ULONG inCreateOptions, ULONG inIsolationLevel, ULONG inIsolationFlags, PLARGE_INTEGER inTimeout, PUNICODE_STRING inDescription) -> NTSTATUS #APC_LEVEL
NtCreateTransactionManager(PHANDLE outTmHandle, ACCESS_MASK inDesiredAccess, POBJECT_ATTRIBUTES inObjectAttributes, PUNICODE_STRING inLogFileName, ULONG inCreateOptions, ULONG inCommitStrength) -> NTSTATUS #APC_LEVEL
NtEnumerateTransactionObject(HANDLE inRootObjectHandle, KTMOBJECT_TYPE inQueryType,  PKTMOBJECT_CURSOR ObjectCursor, ULONG inObjectCursorLength, PULONG outReturnLength) -> NTSTATUS #APC_LEVEL
NtGetDevicePowerState(HANDLE inDevice, PDEVICE_POWER_STATE outState) -> NTSTATUS #APC_LEVEL
NtGetNotificationResourceManager(HANDLE inResourceManagerHandle, PTRANSACTION_NOTIFICATION outTransactionNotification, ULONG inNotificationLength, PLARGE_INTEGER inTimeout, PULONG outReturnLength, ULONG inAsynchronous, ULONG_PTR inAsynchronousContext) -> NTSTATUS #APC_LEVEL
NtInitiatePowerAction(POWER_ACTION inSystemAction, SYSTEM_POWER_STATE inLightestSystemState, ULONG inFlags, # POWER_ACTION_xxx flags BOOLEAN inAsynchronous) -> NTSTATUS //APC_LEVEL
NtIsSystemResumeAutomatic(VOID) -> BOOLEAN #APC_LEVEL
NtOpenEnlistment(PHANDLE outEnlistmentHandle, ACCESS_MASK inDesiredAccess, HANDLE inResourceManagerHandle, LPGUID inEnlistmentGuid, POBJECT_ATTRIBUTES inObjectAttributes) -> NTSTATUS #APC_LEVEL
NtOpenResourceManager(PHANDLE outResourceManagerHandle, ACCESS_MASK inDesiredAccess, HANDLE inTmHandle, LPGUID inResourceManagerGuid, POBJECT_ATTRIBUTES inObjectAttributes) -> NTSTATUS #APC_LEVEL
NtOpenTransaction(PHANDLE outTransactionHandle, ACCESS_MASK inDesiredAccess, POBJECT_ATTRIBUTES inObjectAttributes, LPGUID inUow, HANDLE inTmHandle) -> NTSTATUS #APC_LEVEL
NtOpenTransactionManager(PHANDLE outTmHandle, ACCESS_MASK inDesiredAccess, POBJECT_ATTRIBUTES inObjectAttributes, PUNICODE_STRING inLogFileName, LPGUID inTmIdentity, ULONG inOpenOptions) -> NTSTATUS #APC_LEVEL
NtPowerInformation(POWER_INFORMATION_LEVEL inInformationLevel, PVOID inInputBuffer, ULONG inInputBufferLength, PVOID outOutputBuffer, ULONG inOutputBufferLength) -> NTSTATUS #APC_LEVEL
NtPrePrepareComplete(HANDLE inEnlistmentHandle, PLARGE_INTEGER inTmVirtualClock) -> NTSTATUS #APC_LEVEL
NtPrePrepareEnlistment(HANDLE inEnlistmentHandle, PLARGE_INTEGER inTmVirtualClock) -> NTSTATUS #APC_LEVEL
NtPrepareComplete(HANDLE inEnlistmentHandle, PLARGE_INTEGER inTmVirtualClock) -> NTSTATUS #APC_LEVEL
NtPrepareEnlistment(HANDLE inEnlistmentHandle, PLARGE_INTEGER inTmVirtualClock) -> NTSTATUS #APC_LEVEL
NtPropagationComplete(HANDLE inResourceManagerHandle, ULONG inRequestCookie, ULONG inBufferLength, PVOID inBuffer) -> NTSTATUS #APC_LEVEL
NtPropagationFailed(HANDLE inResourceManagerHandle, ULONG inRequestCookie, NTSTATUS inPropStatus) -> NTSTATUS #APC_LEVEL
NtQueryInformationEnlistment(HANDLE inEnlistmentHandle, ENLISTMENT_INFORMATION_CLASS inEnlistmentInformationClass, PVOID EnlistmentInformation, ULONG inEnlistmentInformationLength, PULONG outReturnLength) -> NTSTATUS #APC_LEVEL
NtQueryInformationResourceManager(HANDLE inResourceManagerHandle, RESOURCEMANAGER_INFORMATION_CLASS inResourceManagerInformationClass, PVOID ResourceManagerInformation, ULONG inResourceManagerInformationLength, PULONG outReturnLength) -> NTSTATUS #APC_LEVEL
NtQueryInformationTransaction(HANDLE inTransactionHandle, TRANSACTION_INFORMATION_CLASS inTransactionInformationClass, PVOID TransactionInformation, ULONG inTransactionInformationLength, PULONG outReturnLength) -> NTSTATUS #APC_LEVEL
NtQueryInformationTransactionManager(HANDLE inTransactionManagerHandle, TRANSACTIONMANAGER_INFORMATION_CLASS inTransactionManagerInformationClass, PVOID TransactionManagerInformation, ULONG inTransactionManagerInformationLength, PULONG outReturnLength) -> NTSTATUS #APC_LEVEL
NtQueryObject(HANDLE inHandle, OBJECT_INFORMATION_CLASS inObjectInformationClass, PVOID outObjectInformation, ULONG inObjectInformationLength, PULONG outReturnLength) -> NTSTATUS #PASSIVE_LEVEL
NtQuerySecurityObject(HANDLE inHandle, SECURITY_INFORMATION inSecurityInformation, PSECURITY_DESCRIPTOR outSecurityDescriptor, ULONG inLength, PULONG outLengthNeeded) -> NTSTATUS #PASSIVE_LEVEL
NtReadOnlyEnlistment(HANDLE inEnlistmentHandle, PLARGE_INTEGER inTmVirtualClock) -> NTSTATUS #APC_LEVEL
NtRecoverEnlistment(HANDLE inEnlistmentHandle, PVOID inEnlistmentKey) -> NTSTATUS #APC_LEVEL
NtRecoverResourceManager(HANDLE inResourceManagerHandle) -> NTSTATUS #APC_LEVEL
NtRecoverTransactionManager(HANDLE inTransactionManagerHandle) -> NTSTATUS #APC_LEVEL
NtRegisterProtocolAddressInformation(HANDLE inResourceManager, PCRM_PROTOCOL_ID inProtocolId, ULONG inProtocolInformationSize, PVOID inProtocolInformation, ULONG inCreateOptions) -> NTSTATUS #APC_LEVEL
NtRenameTransactionManager(PUNICODE_STRING inLogFileName, LPGUID inExistingTransactionManagerGuid) -> NTSTATUS #APC_LEVEL
NtRollbackComplete(HANDLE inEnlistmentHandle, PLARGE_INTEGER inTmVirtualClock) -> NTSTATUS #APC_LEVEL
NtRollbackEnlistment(HANDLE inEnlistmentHandle, PLARGE_INTEGER inTmVirtualClock) -> NTSTATUS #APC_LEVEL
NtRollbackTransaction(HANDLE inTransactionHandle, BOOLEAN inWait) -> NTSTATUS #APC_LEVEL
NtRollforwardTransactionManager(HANDLE inTransactionManagerHandle, PLARGE_INTEGER inTmVirtualClock) -> NTSTATUS #APC_LEVEL
NtSetInformationEnlistment(HANDLE inEnlistmentHandle, ENLISTMENT_INFORMATION_CLASS inEnlistmentInformationClass, PVOID EnlistmentInformation, ULONG inEnlistmentInformationLength) -> NTSTATUS #APC_LEVEL
NtSetInformationResourceManager(HANDLE inResourceManagerHandle, RESOURCEMANAGER_INFORMATION_CLASS inResourceManagerInformationClass, PVOID ResourceManagerInformation, ULONG inResourceManagerInformationLength) -> NTSTATUS #APC_LEVEL
NtSetInformationTransaction(HANDLE inTransactionHandle, TRANSACTION_INFORMATION_CLASS inTransactionInformationClass, PVOID TransactionInformation, ULONG inTransactionInformationLength) -> NTSTATUS #APC_LEVEL
NtSetInformationTransactionManager(HANDLE inTmHandle, TRANSACTIONMANAGER_INFORMATION_CLASS inTransactionManagerInformationClass, PVOID TransactionManagerInformation, ULONG inTransactionManagerInformationLength) -> NTSTATUS #APC_LEVEL
NtSetSecurityObject(HANDLE inHandle, SECURITY_INFORMATION inSecurityInformation, PSECURITY_DESCRIPTOR inSecurityDescriptor) -> NTSTATUS #PASSIVE_LEVEL
NtSetSystemPowerState(POWER_ACTION inSystemAction, SYSTEM_POWER_STATE inLightestSystemState, ULONG inFlags # POWER_ACTION_xxx flags) -> NTSTATUS //APC_LEVEL
NtSetThreadExecutionState(EXECUTION_STATE inNewFlags, # ES_xxx flags PEXECUTION_STATE outPreviousFlags) -> NTSTATUS //APC_LEVEL
NtSinglePhaseReject(HANDLE inEnlistmentHandle, PLARGE_INTEGER inTmVirtualClock) -> NTSTATUS #APC_LEVEL
ObGetObjectSecurity(PVOID inObject, PSECURITY_DESCRIPTOR out*SecurityDescriptor, PBOOLEAN outMemoryAllocated) -> NTSTATUS #APC_LEVEL
ObReferenceObjectByHandle(HANDLE inHandle, ACCESS_MASK inDesiredAccess, POBJECT_TYPE inObjectType, KPROCESSOR_MODE inAccessMode, PVOID out*Object, POBJECT_HANDLE_INFORMATION outHandleInformation) -> NTSTATUS #APC_LEVEL
ObReferenceObjectByHandleWithTag(HANDLE inHandle, ACCESS_MASK inDesiredAccess, POBJECT_TYPE inObjectType, KPROCESSOR_MODE inAccessMode, ULONG inTag, PVOID out*Object, POBJECT_HANDLE_INFORMATION outHandleInformation) -> NTSTATUS #APC_LEVEL
ObReferenceObjectByPointer(PVOID inObject, ACCESS_MASK inDesiredAccess, POBJECT_TYPE inObjectType, KPROCESSOR_MODE inAccessMode) -> NTSTATUS #DISPATCH_LEVEL
ObReferenceObjectByPointerWithTag(PVOID inObject, ACCESS_MASK inDesiredAccess, POBJECT_TYPE inObjectType, KPROCESSOR_MODE inAccessMode, ULONG inTag) -> NTSTATUS #DISPATCH_LEVEL
ObReleaseObjectSecurity(PSECURITY_DESCRIPTOR inSecurityDescriptor, BOOLEAN inMemoryAllocated) -> VOID #APC_LEVEL
ObfDereferenceObject(PVOID inObject) -> FASTCALL #DISPATCH_LEVEL
ObfDereferenceObjectWithTag(PVOID inObject, ULONG inTag) -> FASTCALL #DISPATCH_LEVEL
ObfReferenceObject(PVOID inObject) -> FASTCALL #DISPATCH_LEVEL
ObfReferenceObjectWithTag(PVOID inObject, ULONG inTag) -> FASTCALL #DISPATCH_LEVEL
PCI_EXPRESS_ENTER_LINK_QUIESCENT_MODE(PVOID ioContext) -> NTSTATUS #PASSIVE_LEVEL
PCI_EXPRESS_EXIT_LINK_QUIESCENT_MODE(PVOID ioContext) -> NTSTATUS #PASSIVE_LEVEL
PCI_IS_DEVICE_PRESENT(USHORT inVendorID, USHORT inDeviceID, UCHAR inRevisionID, USHORT inSubVendorID, USHORT inSubSystemID, ULONG inFlags) -> BOOLEAN #PASSIVE_LEVEL
PCI_IS_DEVICE_PRESENT_EX(PVOID inContext, PPCI_DEVICE_PRESENCE_PARAMETERS inParameters) -> BOOLEAN #PASSIVE_LEVEL
PcRegisterIoTimeout(PDEVICE_OBJECT inpDeviceObject, PIO_TIMER_ROUTINE inpTimerRoutine, PVOID inpContext) -> NTSTATUS #PASSIVE_LEVEL
PcwAddInstance(PPCW_BUFFER inBuffer, PCUNICODE_STRING inName, ULONG inId, ULONG inCount, PPCW_DATA Data) -> NTSTATUS #APC_LEVEL
PcwCloseInstance(PPCW_INSTANCE inInstance) -> VOID #APC_LEVEL
PcwCreateInstance(PPCW_INSTANCE *Instance, PPCW_REGISTRATION inRegistration, PCUNICODE_STRING inName, ULONG inCount, PPCW_DATA Data) -> NTSTATUS #APC_LEVEL
PcwRegister(PPCW_REGISTRATION *Registration, PPCW_REGISTRATION_INFORMATION inInfo) -> NTSTATUS #APC_LEVEL
PcwUnregister(PPCW_REGISTRATION inRegistration) -> VOID #APC_LEVEL
PfxFindPrefix(PPREFIX_TABLE inPrefixTable, PSTRING inFullName) -> PPREFIX_TABLE_ENTRY #PASSIVE_LEVEL
PfxInitialize(PPREFIX_TABLE outPrefixTable) -> VOID #PASSIVE_LEVEL
PfxInsertPrefix(PPREFIX_TABLE inPrefixTable, PSTRING inPrefix, PPREFIX_TABLE_ENTRY outPrefixTableEntry) -> BOOLEAN #PASSIVE_LEVEL
PfxRemovePrefix(PPREFIX_TABLE inPrefixTable, PPREFIX_TABLE_ENTRY inPrefixTableEntry) -> VOID #PASSIVE_LEVEL
PoCallDriver(PDEVICE_OBJECT inDeviceObject, PIRP ioIrp) -> NTSTATUS #DISPATCH_LEVEL
PoClearPowerRequest(PVOID ioPowerRequest, POWER_REQUEST_TYPE inType) -> NTSTATUS #DISPATCH_LEVEL
PoCreatePowerRequest(PVOID *PowerRequest, PDEVICE_OBJECT inDeviceObject, PCOUNTED_REASON_CONTEXT inContext) -> NTSTATUS #APC_LEVEL
PoDeletePowerRequest(PVOID ioPowerRequest) -> VOID #APC_LEVEL
PoGetSystemWake(PIRP inIrp) -> BOOLEAN #DISPATCH_LEVEL
PoQueryWatchdogTime(PDEVICE_OBJECT inPdo, PULONG outSecondsRemaining) -> BOOLEAN #DISPATCH_LEVEL
PoQueueShutdownWorkItem(PWORK_QUEUE_ITEM ioWorkItem) -> NTSTATUS #APC_LEVEL
PoRegisterDeviceForIdleDetection(PDEVICE_OBJECT inDeviceObject, ULONG inConservationIdleTime, ULONG inPerformanceIdleTime, DEVICE_POWER_STATE inState) -> PULONG #APC_LEVEL
PoRegisterPowerSettingCallback(PDEVICE_OBJECT inDeviceObject, LPCGUID inSettingGuid, PPOWER_SETTING_CALLBACK inCallback, PVOID inContext, PVOID *Handle) -> NTSTATUS #APC_LEVEL
PoRegisterSystemState(PVOID StateHandle, EXECUTION_STATE inFlags) -> PVOID #APC_LEVEL
PoRequestPowerIrp(PDEVICE_OBJECT inDeviceObject, UCHAR inMinorFunction, POWER_STATE inPowerState, PREQUEST_POWER_COMPLETE inCompletionFunction, PVOID inContext, PIRP *Irp) -> NTSTATUS #DISPATCH_LEVEL
PoSetPowerRequest(PVOID ioPowerRequest, POWER_REQUEST_TYPE inType) -> NTSTATUS #DISPATCH_LEVEL
PoSetPowerState(PDEVICE_OBJECT inDeviceObject, POWER_STATE_TYPE inType, POWER_STATE inState) -> POWER_STATE #APC_LEVEL
PoSetSystemState(EXECUTION_STATE inFlags) -> VOID #DISPATCH_LEVEL
PoSetSystemWake(PIRP ioIrp) -> VOID #DISPATCH_LEVEL
PoStartNextPowerIrp(PIRP ioIrp) -> VOID #DISPATCH_LEVEL
PoUnregisterPowerSettingCallback(PVOID ioHandle) -> NTSTATUS #APC_LEVEL
PoUnregisterSystemState(PVOID ioStateHandle) -> VOID #APC_LEVEL
ProbeForRead(PVOID Address, SIZE_T inLength, ULONG inAlignment) -> VOID #APC_LEVEL
ProbeForWrite( PVOID Address, SIZE_T inLength, ULONG inAlignment) -> VOID #APC_LEVEL
PsAssignImpersonationToken(PETHREAD inThread, HANDLE inToken) -> NTSTATUS #PASSIVE_LEVEL
PsChargePoolQuota(PEPROCESS inProcess, POOL_TYPE inPoolType, ULONG_PTR inAmount) -> VOID #APC_LEVEL
PsChargeProcessPoolQuota(PEPROCESS inProcess, POOL_TYPE inPoolType, ULONG_PTR inAmount) -> NTSTATUS #APC_LEVEL
PsCreateSystemThread(PHANDLE outThreadHandle, ULONG inDesiredAccess, POBJECT_ATTRIBUTES inObjectAttributes, HANDLE inProcessHandle, PCLIENT_ID outClientId, PKSTART_ROUTINE inStartRoutine, PVOID inStartContext) -> ) NTSTATUS #APC_LEVEL
PsDereferenceImpersonationToken(PACCESS_TOKEN inImpersonationToken) -> VOID #PASSIVE_LEVEL
PsDereferencePrimaryToken(PACCESS_TOKEN inPrimaryToken) -> VOID #PASSIVE_LEVEL
PsDisableImpersonation(PETHREAD ioThread, PSE_IMPERSONATION_STATE ioImpersonationState) -> BOOLEAN #PASSIVE_LEVEL
PsGetCurrentThread(VOID) -> PETHREAD #DISPATCH_LEVEL
PsGetCurrentThreadId(VOID) -> HANDLE #DISPATCH_LEVEL
PsGetProcessCreateTimeQuadPart(PEPROCESS inProcess) -> LONGLONG #DISPATCH_LEVEL
PsGetProcessExitTime(VOID) -> LARGE_INTEGER #APC_LEVEL
PsGetProcessId(PEPROCESS inProcess) -> HANDLE #DISPATCH_LEVEL
PsGetThreadId(PETHREAD inThread) -> HANDLE #DISPATCH_LEVEL
PsGetVersion(PULONG outMajorVersion, PULONG outMinorVersion, PULONG outBuildNumber, PUNICODE_STRING outCSDVersion) -> BOOLEAN #PASSIVE_LEVEL
PsImpersonateClient(PETHREAD ioThread, PACCESS_TOKEN inToken, BOOLEAN inCopyOnOpen, BOOLEAN inEffectiveOnly, SECURITY_IMPERSONATION_LEVEL inImpersonationLevel) -> NTSTATUS #PASSIVE_LEVEL
PsIsCurrentThreadPrefetching(VOID) -> BOOLEAN #APC_LEVEL
PsIsThreadTerminating(PETHREAD inThread) -> BOOLEAN #DISPATCH_LEVEL
PsLookupProcessByProcessId(HANDLE inProcessId, PEPROCESS *Process) -> NTSTATUS #APC_LEVEL
PsLookupThreadByThreadId(HANDLE inThreadId, PETHREAD *Thread) -> NTSTATUS #APC_LEVEL
PsReferenceImpersonationToken(PETHREAD ioThread, PBOOLEAN outCopyOnOpen, PBOOLEAN outEffectiveOnly, PSECURITY_IMPERSONATION_LEVEL outImpersonationLevel) -> PACCESS_TOKEN #APC_LEVEL
PsReferencePrimaryToken(PEPROCESS ioProcess) -> PACCESS_TOKEN #PASSIVE_LEVEL
PsRemoveLoadImageNotifyRoutine(PLOAD_IMAGE_NOTIFY_ROUTINE inNotifyRoutine) -> NTSTATUS #PASSIVE_LEVEL
PsRestoreImpersonation(PETHREAD ioThread, PSE_IMPERSONATION_STATE inImpersonationState) -> VOID #PASSIVE_LEVEL
PsReturnPoolQuota(PEPROCESS inProcess, POOL_TYPE inPoolType, ULONG_PTR inAmount) -> VOID #APC_LEVEL
PsRevertToSelf(VOID) -> VOID #PASSIVE_LEVEL
PsSetCreateProcessNotifyRoutine(PCREATE_PROCESS_NOTIFY_ROUTINE inNotifyRoutine, BOOLEAN inRemove) -> NTSTATUS #PASSIVE_LEVEL
PsSetCreateProcessNotifyRoutineEx(PCREATE_PROCESS_NOTIFY_ROUTINE_EX inNotifyRoutine, BOOLEAN inRemove) -> NTSTATUS #PASSIVE_LEVEL
PsSetCreateThreadNotifyRoutine(PCREATE_THREAD_NOTIFY_ROUTINE inNotifyRoutine) -> NTSTATUS #PASSIVE_LEVEL
PsSetCurrentThreadPrefetching(BOOLEAN inPrefetching) -> BOOLEAN #APC_LEVEL
PsSetLoadImageNotifyRoutine(PLOAD_IMAGE_NOTIFY_ROUTINE inNotifyRoutine) -> NTSTATUS #PASSIVE_LEVEL
PsTerminateSystemThread(NTSTATUS inExitStatus) -> NTSTATUS #PASSIVE_LEVEL
PshedAllocateMemory(ULONG inSize) -> PVOID #DISPATCH_LEVEL
PshedFreeMemory(PVOID inAddress) -> VOID #DISPATCH_LEVEL
PshedRegisterPlugin(PWHEA_PSHED_PLUGIN_REGISTRATION_PACKET ioPacket) -> NTSTATUS #PASSIVE_LEVEL
RTL_ALLOCATE_STRING_ROUTINE(SIZE_T inNumberOfBytes) -> PVOID #PASSIVE_LEVEL
RTL_FREE_STRING_ROUTINE(PVOID inBuffer) -> VOID #PASSIVE_LEVEL
RTL_QUERY_REGISTRY_ROUTINE(PWSTR inValueName, ULONG inValueType, PVOID inValueData, ULONG inValueLength, PVOID inContext, PVOID inEntryContext) -> NTSTATUS #PASSIVE_LEVEL
RTL_REALLOCATE_STRING_ROUTINE(SIZE_T inNumberOfBytes, PVOID inBuffer) -> PVOID #PASSIVE_LEVEL
RegisterOpRegionHandler(PDEVICE_OBJECT inDeviceObject, ULONG inAccessType, ULONG inRegionSpace, PACPI_OP_REGION_HANDLER inHandler, PVOID inContext, ULONG inFlags, PVOID out*OperationRegionObject) -> NTSTATUS #PASSIVE_LEVEL
RtlAbsoluteToSelfRelativeSD(PSECURITY_DESCRIPTOR inAbsoluteSecurityDescriptor, PSECURITY_DESCRIPTOR outSelfRelativeSecurityDescriptor, PULONG ioBufferLength) -> NTSTATUS #APC_LEVEL
RtlAddAccessAllowedAce(PACL ioAcl, ULONG inAceRevision, ACCESS_MASK inAccessMask, PSID inSid) -> NTSTATUS #APC_LEVEL
RtlAddAccessAllowedAceEx(PACL ioAcl, ULONG inAceRevision, ULONG inAceFlags, ACCESS_MASK inAccessMask, PSID inSid) -> NTSTATUS #APC_LEVEL
RtlAddAce(PACL ioAcl, ULONG inAceRevision, ULONG inStartingAceIndex, PVOID AceList, ULONG inAceListLength) -> NTSTATUS #APC_LEVEL
RtlAnsiStringToUnicodeString(PUNICODE_STRING DestinationString, PCANSI_STRING inSourceString, BOOLEAN inAllocateDestinationString) -> NTSTATUS #PASSIVE_LEVEL
RtlAppendStringToString(PSTRING ioDestination, const inSTRING * Source) -> NTSTATUS #APC_LEVEL
RtlCharToInteger(PCSZ inString, ULONG inBase, PULONG outValue) -> NTSTATUS #PASSIVE_LEVEL
RtlCheckRegistryKey(ULONG inRelativeTo, PWSTR inPath) -> NTSTATUS #PASSIVE_LEVEL
RtlCompareString(const inSTRING * String1, const inSTRING * String2, BOOLEAN inCaseInSensitive) -> LONG #PASSIVE_LEVEL
RtlCompareUnicodeString(PCUNICODE_STRING inString1, PCUNICODE_STRING inString2, BOOLEAN inCaseInSensitive) -> LONG #PASSIVE_LEVEL
RtlCompareUnicodeStrings(PCWCH String1, SIZE_T inString1Length, PCWCH String2, SIZE_T inString2Length, BOOLEAN inCaseInSensitive) -> LONG #PASSIVE_LEVEL
RtlCompressChunks(PUCHAR UncompressedBuffer, ULONG inUncompressedBufferSize, PUCHAR CompressedBuffer, ULONG CompressedBufferSize,  PCOMPRESSED_DATA_INFO CompressedDataInfo, ULONG CompressedDataInfoLength, PVOID inWorkSpace) -> NTSTATUS #APC_LEVEL
RtlConvertSidToUnicodeString(PUNICODE_STRING ioUnicodeString, PSID inSid, BOOLEAN inAllocateDestinationString) -> NTSTATUS #APC_LEVEL
RtlCopyLuid(PLUID outDestinationLuid, PLUID inSourceLuid) -> VOID #APC_LEVEL
RtlCopySid(ULONG inDestinationSidLength, PSID DestinationSid, PSID inSourceSid) -> NTSTATUS #APC_LEVEL
RtlCreateAcl(PACL Acl, ULONG inAclLength, ULONG inAclRevision) -> NTSTATUS #APC_LEVEL
RtlCreateRegistryKey(ULONG inRelativeTo, PWSTR inPath) -> NTSTATUS #PASSIVE_LEVEL
RtlCreateSecurityDescriptor(PSECURITY_DESCRIPTOR outSecurityDescriptor, ULONG inRevision) -> NTSTATUS #APC_LEVEL
RtlCreateSecurityDescriptorRelative(PISECURITY_DESCRIPTOR_RELATIVE outSecurityDescriptor, ULONG inRevision) -> NTSTATUS #APC_LEVEL
RtlCreateSystemVolumeInformationFolder(PCUNICODE_STRING inVolumeRootPath) -> NTSTATUS #PASSIVE_LEVEL
RtlCreateUnicodeString(PUNICODE_STRING outDestinationString, PCWSTR inSourceString) -> BOOLEAN #APC_LEVEL
RtlCustomCPToUnicodeN(PCPTABLEINFO inCustomCP, PWCH UnicodeString, ULONG inMaxBytesInUnicodeString, PULONG outBytesInUnicodeString, PCH CustomCPString, ULONG inBytesInCustomCPString) -> NTSTATUS #PASSIVE_LEVEL
RtlDecompressBuffer(USHORT inCompressionFormat, PUCHAR UncompressedBuffer, ULONG inUncompressedBufferSize, PUCHAR CompressedBuffer, ULONG inCompressedBufferSize, PULONG outFinalUncompressedSize) -> NTSTATUS #APC_LEVEL
RtlDecompressChunks(PUCHAR UncompressedBuffer, ULONG inUncompressedBufferSize, PUCHAR CompressedBuffer, ULONG inCompressedBufferSize, PUCHAR CompressedTail, ULONG inCompressedTailSize, PCOMPRESSED_DATA_INFO inCompressedDataInfo) -> NTSTATUS #APC_LEVEL
RtlDecompressFragment(USHORT inCompressionFormat, PUCHAR UncompressedFragment, ULONG inUncompressedFragmentSize, PUCHAR CompressedBuffer, ULONG inCompressedBufferSize, ULONG FragmentOffset, PULONG outFinalUncompressedSize, PVOID inWorkSpace) -> NTSTATUS #APC_LEVEL
RtlDeleteAce(PACL ioAcl, ULONG inAceIndex) -> NTSTATUS #APC_LEVEL
RtlDeleteRegistryValue(ULONG inRelativeTo, PCWSTR inPath, PCWSTR inValueName) -> NTSTATUS #PASSIVE_LEVEL
RtlDescribeChunk(USHORT inCompressionFormat, ioPUCHAR *CompressedBuffer, PUCHAR inEndOfCompressedBufferPlus1, PUCHAR out*ChunkBuffer, PULONG outChunkSize) -> NTSTATUS #APC_LEVEL
RtlDowncaseUnicodeChar(WCHAR inSourceCharacter) -> WCHAR #PASSIVE_LEVEL
RtlDowncaseUnicodeString(PUNICODE_STRING DestinationString, PCUNICODE_STRING inSourceString, BOOLEAN inAllocateDestinationString) -> NTSTATUS #PASSIVE_LEVEL
RtlDuplicateUnicodeString(ULONG inFlags, PCUNICODE_STRING inStringIn, PUNICODE_STRING outStringOut) -> NTSTATUS #PASSIVE_LEVEL
RtlEqualPrefixSid(PSID inSid1, PSID inSid2) -> BOOLEAN #APC_LEVEL
RtlEqualString(const inSTRING * String1, const inSTRING * String2, BOOLEAN inCaseInSensitive) -> BOOLEAN #PASSIVE_LEVEL
RtlEqualUnicodeString(PCUNICODE_STRING inString1, PCUNICODE_STRING inString2, BOOLEAN inCaseInSensitive) -> BOOLEAN #PASSIVE_LEVEL
RtlFindUnicodePrefix(PUNICODE_PREFIX_TABLE inPrefixTable, PCUNICODE_STRING inFullName, ULONG inCaseInsensitiveIndex) -> PUNICODE_PREFIX_TABLE_ENTRY #PASSIVE_LEVEL
RtlFreeAnsiString(PANSI_STRING ioAnsiString) -> VOID #PASSIVE_LEVEL
RtlFreeOemString(POEM_STRING ioOemString) -> VOID #PASSIVE_LEVEL
RtlFreeUnicodeString(PUNICODE_STRING ioUnicodeString) -> VOID #PASSIVE_LEVEL
RtlGUIDFromString(PCUNICODE_STRING inGuidString, GUIDout* Guid) -> NTSTATUS #PASSIVE_LEVEL
RtlGenerate8dot3Name(PCUNICODE_STRING inName, BOOLEAN inAllowExtendedCharacters, PGENERATE_NAME_CONTEXT ioContext, PUNICODE_STRING ioName8dot3) -> NTSTATUS #PASSIVE_LEVEL
RtlGetGroupSecurityDescriptor(PSECURITY_DESCRIPTOR inSecurityDescriptor, PSID out*Group, PBOOLEAN outGroupDefaulted) -> NTSTATUS #APC_LEVEL
RtlGetOwnerSecurityDescriptor(PSECURITY_DESCRIPTOR inSecurityDescriptor, PSID out*Owner, PBOOLEAN outOwnerDefaulted) -> NTSTATUS #APC_LEVEL
RtlGetSaclSecurityDescriptor(PSECURITY_DESCRIPTOR inSecurityDescriptor, PBOOLEAN outSaclPresent, PACL out*Sacl, PBOOLEAN outSaclDefaulted) -> NTSTATUS #APC_LEVEL
RtlGetVersion(PRTL_OSVERSIONINFOW outlpVersionInformation) -> NTSTATUS #PASSIVE_LEVEL
RtlHashUnicodeString(PCUNICODE_STRING inString, BOOLEAN inCaseInSensitive, ULONG inHashAlgorithm, PULONG outHashValue) -> NTSTATUS #PASSIVE_LEVEL
RtlIdentifierAuthoritySid(PSID inSid) -> PSID_IDENTIFIER_AUTHORITY #APC_LEVEL
RtlInitAnsiString(PANSI_STRING outDestinationString, PCSZ inSourceString) -> VOID #DISPATCH_LEVEL
RtlInitAnsiStringEx(PANSI_STRING outDestinationString, PCSZ inSourceString) -> NTSTATUS #DISPATCH_LEVEL
RtlInitCodePageTable(PUSHORT inTableBase, PCPTABLEINFO ioCodePageTable) -> VOID #PASSIVE_LEVEL
RtlInitString(PSTRING outDestinationString, PCSZ inSourceString) -> VOID #DISPATCH_LEVEL
RtlInitUnicodeString(PUNICODE_STRING outDestinationString, PCWSTR inSourceString) -> VOID #DISPATCH_LEVEL
RtlInitUnicodeStringEx(PUNICODE_STRING outDestinationString, PCWSTR SourceString) -> NTSTATUS #DISPATCH_LEVEL
RtlInitializeBitMap(PRTL_BITMAP outBitMapHeader, PULONG inBitMapBuffer, ULONG inSizeOfBitMap) -> VOID #APC_LEVEL
RtlInitializeSid(PSID outSid, PSID_IDENTIFIER_AUTHORITY inIdentifierAuthority, UCHAR inSubAuthorityCount) -> NTSTATUS #APC_LEVEL
RtlInitializeUnicodePrefix(PUNICODE_PREFIX_TABLE outPrefixTable) -> VOID #PASSIVE_LEVEL
RtlInsertUnicodePrefix(PUNICODE_PREFIX_TABLE inPrefixTable, PUNICODE_STRING inPrefix, PUNICODE_PREFIX_TABLE_ENTRY outPrefixTableEntry) -> BOOLEAN #PASSIVE_LEVEL
RtlInt64ToUnicodeString(ULONGLONG inValue, ULONG inBase, PUNICODE_STRING ioString) -> NTSTATUS #PASSIVE_LEVEL
RtlIntegerToUnicodeString(ULONG inValue, ULONG inBase, PUNICODE_STRING ioString) -> NTSTATUS #PASSIVE_LEVEL
RtlIsNameLegalDOS8Dot3(PCUNICODE_STRING inName, POEM_STRING OemName, PBOOLEAN outNameContainsSpaces) -> BOOLEAN #PASSIVE_LEVEL
RtlIsValidOemCharacter(PWCHAR ioChar) -> BOOLEAN #PASSIVE_LEVEL
RtlLengthRequiredSid(ULONG inSubAuthorityCount) -> ULONG #APC_LEVEL
RtlLengthSecurityDescriptor(PSECURITY_DESCRIPTOR inSecurityDescriptor) -> ULONG #APC_LEVEL
RtlMapGenericMask(PACCESS_MASK ioAccessMask, PGENERIC_MAPPING inGenericMapping) -> VOID #APC_LEVEL
RtlMultiByteToUnicodeN(PWCH UnicodeString, ULONG inMaxBytesInUnicodeString, PULONG outBytesInUnicodeString, const CHAR *MultiByteString, ULONG inBytesInMultiByteString) -> NTSTATUS #PASSIVE_LEVEL
RtlMultiByteToUnicodeSize(PULONG outBytesInUnicodeString, const CHAR *MultiByteString, ULONG inBytesInMultiByteString) -> NTSTATUS #PASSIVE_LEVEL
RtlNextUnicodePrefix(PUNICODE_PREFIX_TABLE inPrefixTable, BOOLEAN inRestart) -> PUNICODE_PREFIX_TABLE_ENTRY #PASSIVE_LEVEL
RtlNtStatusToDosError(NTSTATUS inStatus) -> ULONG #APC_LEVEL
RtlOemStringToCountedUnicodeString(PUNICODE_STRING DestinationString, PCOEM_STRING inSourceString, BOOLEAN inAllocateDestinationString) -> NTSTATUS #PASSIVE_LEVEL
RtlOemStringToUnicodeString(PUNICODE_STRING DestinationString, PCOEM_STRING inSourceString, BOOLEAN inAllocateDestinationString) -> NTSTATUS #PASSIVE_LEVEL
RtlOemToUnicodeN(PWCH UnicodeString, ULONG inMaxBytesInUnicodeString, PULONG outBytesInUnicodeString, PCCH OemString, ULONG inBytesInOemString) -> NTSTATUS #PASSIVE_LEVEL
RtlPrefixUnicodeString(PCUNICODE_STRING inString1, PCUNICODE_STRING inString2, BOOLEAN inCaseInSensitive) -> BOOLEAN #PASSIVE_LEVEL
RtlQueryRegistryValues(ULONG inRelativeTo, PCWSTR inPath, PRTL_QUERY_REGISTRY_TABLE ioQueryTable, PVOID inContext, PVOID inEnvironment) -> NTSTATUS #PASSIVE_LEVEL
RtlRemoveUnicodePrefix(PUNICODE_PREFIX_TABLE inPrefixTable, PUNICODE_PREFIX_TABLE_ENTRY inPrefixTableEntry) -> VOID #PASSIVE_LEVEL
RtlReplaceSidInSd(PSECURITY_DESCRIPTOR ioSecurityDescriptor, PSID inOldSid, PSID inNewSid, ULONG out*NumChanges) -> NTSTATUS #APC_LEVEL
RtlReserveChunk(USHORT inCompressionFormat, ioPUCHAR *CompressedBuffer, PUCHAR inEndOfCompressedBufferPlus1, PUCHAR out*ChunkBuffer, ULONG inChunkSize) -> NTSTATUS #APC_LEVEL
RtlRunOnceBeginInitialize(PRTL_RUN_ONCE ioRunOnce, ULONG inFlags, PVOID *Context) -> NTSTATUS #APC_LEVEL
RtlRunOnceComplete(PRTL_RUN_ONCE ioRunOnce, ULONG inFlags, PVOID inContext) -> NTSTATUS #APC_LEVEL
RtlRunOnceExecuteOnce(PRTL_RUN_ONCE ioRunOnce, PRTL_RUN_ONCE_INIT_FN inInitFn, PVOID Parameter, PVOID *Context) -> NTSTATUS #APC_LEVEL
RtlRunOnceInitialize(PRTL_RUN_ONCE outRunOnce) -> VOID #APC_LEVEL
RtlSelfRelativeToAbsoluteSD(PSECURITY_DESCRIPTOR inSelfRelativeSecurityDescriptor, PSECURITY_DESCRIPTOR outAbsoluteSecurityDescriptor, PULONG ioAbsoluteSecurityDescriptorSize, PACL outDacl, PULONG ioDaclSize, PACL outSacl, PULONG ioSaclSize, PSID outOwner, PULONG ioOwnerSize, PSID outPrimaryGroup, PULONG ioPrimaryGroupSize) -> NTSTATUS #APC_LEVEL
RtlSetDaclSecurityDescriptor(PSECURITY_DESCRIPTOR ioSecurityDescriptor, BOOLEAN inDaclPresent, PACL inDacl, BOOLEAN inDaclDefaulted) -> NTSTATUS #APC_LEVEL
RtlSetGroupSecurityDescriptor(PSECURITY_DESCRIPTOR ioSecurityDescriptor, PSID inGroup, BOOLEAN inGroupDefaulted) -> NTSTATUS #APC_LEVEL
RtlSetOwnerSecurityDescriptor(PSECURITY_DESCRIPTOR ioSecurityDescriptor, PSID inOwner, BOOLEAN inOwnerDefaulted) -> NTSTATUS #APC_LEVEL
RtlStringFromGUID(REFGUID inGuid, PUNICODE_STRING outGuidString) -> NTSTATUS #PASSIVE_LEVEL
RtlUTF8ToUnicodeN(PWSTR UnicodeStringDestination, ULONG inUnicodeStringMaxByteCount, PULONG outUnicodeStringActualByteCount, PCCH UTF8StringSource, ULONG inUTF8StringByteCount) -> NTSTATUS #PASSIVE_LEVEL
RtlUnicodeStringToAnsiString(PANSI_STRING DestinationString, PCUNICODE_STRING inSourceString, BOOLEAN inAllocateDestinationString) -> NTSTATUS #PASSIVE_LEVEL
RtlUnicodeStringToCountedOemString(POEM_STRING DestinationString, PCUNICODE_STRING inSourceString, BOOLEAN inAllocateDestinationString) -> NTSTATUS #PASSIVE_LEVEL
RtlUnicodeStringToInteger(PCUNICODE_STRING inString, ULONG inBase, PULONG outValue) -> NTSTATUS #PASSIVE_LEVEL
RtlUnicodeStringToOemString(POEM_STRING DestinationString, PCUNICODE_STRING inSourceString, BOOLEAN inAllocateDestinationString) -> NTSTATUS #PASSIVE_LEVEL
RtlUnicodeToCustomCPN(PCPTABLEINFO inCustomCP, PCH CustomCPString, ULONG inMaxBytesInCustomCPString, PULONG outBytesInCustomCPString, PWCH UnicodeString, ULONG inBytesInUnicodeString) -> NTSTATUS #PASSIVE_LEVEL
RtlUnicodeToMultiByteN(PCHAR MultiByteString, ULONG inMaxBytesInMultiByteString, PULONG outBytesInMultiByteString, PCWCH UnicodeString, ULONG inBytesInUnicodeString) -> NTSTATUS #PASSIVE_LEVEL
RtlUnicodeToMultiByteSize(PULONG outBytesInMultiByteString, PCWCH UnicodeString, ULONG inBytesInUnicodeString) -> NTSTATUS #PASSIVE_LEVEL
RtlUnicodeToOemN(PCHAR OemString, ULONG inMaxBytesInOemString, PULONG outBytesInOemString, PCWCH UnicodeString, ULONG inBytesInUnicodeString) -> NTSTATUS #PASSIVE_LEVEL
RtlUnicodeToUTF8N(PCHAR UTF8StringDestination, ULONG inUTF8StringMaxByteCount, PULONG outUTF8StringActualByteCount, PCWCH UnicodeStringSource, ULONG inUnicodeStringByteCount) -> NTSTATUS #PASSIVE_LEVEL
RtlUpcaseUnicodeChar(WCHAR inSourceCharacter) -> WCHAR #PASSIVE_LEVEL
RtlUpcaseUnicodeString(PUNICODE_STRING DestinationString, PCUNICODE_STRING inSourceString, BOOLEAN inAllocateDestinationString) -> NTSTATUS #PASSIVE_LEVEL
RtlUpcaseUnicodeStringToCountedOemString(POEM_STRING DestinationString, PCUNICODE_STRING inSourceString, BOOLEAN inAllocateDestinationString) -> NTSTATUS #PASSIVE_LEVEL
RtlUpcaseUnicodeStringToOemString(POEM_STRING DestinationString, PCUNICODE_STRING inSourceString, BOOLEAN inAllocateDestinationString) -> NTSTATUS #PASSIVE_LEVEL
RtlUpcaseUnicodeToCustomCPN(PCPTABLEINFO inCustomCP, PCH CustomCPString, ULONG inMaxBytesInCustomCPString, PULONG outBytesInCustomCPString, PWCH UnicodeString, ULONG inBytesInUnicodeString) -> NTSTATUS #PASSIVE_LEVEL
RtlUpcaseUnicodeToMultiByteN(PCHAR MultiByteString, ULONG inMaxBytesInMultiByteString, PULONG outBytesInMultiByteString, PCWCH UnicodeString, ULONG inBytesInUnicodeString) -> NTSTATUS #PASSIVE_LEVEL
RtlUpcaseUnicodeToOemN(PCHAR OemString, ULONG inMaxBytesInOemString, PULONG outBytesInOemString, PCWCH UnicodeString, ULONG inBytesInUnicodeString) -> NTSTATUS #PASSIVE_LEVEL
RtlUpperChar(CHAR inCharacter) -> CHAR #PASSIVE_LEVEL
RtlUpperString(PSTRING ioDestinationString, const inSTRING * SourceString) -> VOID #PASSIVE_LEVEL
RtlValidRelativeSecurityDescriptor(PSECURITY_DESCRIPTOR SecurityDescriptorInput, ULONG inSecurityDescriptorLength, SECURITY_INFORMATION inRequiredInformation) -> BOOLEAN #APC_LEVEL
RtlValidSecurityDescriptor(PSECURITY_DESCRIPTOR inSecurityDescriptor) -> BOOLEAN #APC_LEVEL
RtlValidSid(PSID inSid) -> BOOLEAN #APC_LEVEL
RtlVerifyVersionInfo(PRTL_OSVERSIONINFOEXW inVersionInfo, ULONG inTypeMask, ULONGLONG inConditionMask) -> NTSTATUS #PASSIVE_LEVEL
RtlVolumeDeviceToDosName(PVOID inVolumeDeviceObject, PUNICODE_STRING outDosName) -> NTSTATUS #PASSIVE_LEVEL
RtlWriteRegistryValue(ULONG inRelativeTo, PCWSTR inPath, PCWSTR inValueName, ULONG inValueType, PVOID inValueData, ULONG inValueLength) -> NTSTATUS #PASSIVE_LEVEL
RtlxAnsiStringToUnicodeSize(PCANSI_STRING inAnsiString) -> ULONG #PASSIVE_LEVEL
RtlxOemStringToUnicodeSize(PCOEM_STRING inOemString) -> ULONG #PASSIVE_LEVEL
RtlxUnicodeStringToAnsiSize(PCUNICODE_STRING inUnicodeString) -> ULONG #PASSIVE_LEVEL
RtlxUnicodeStringToOemSize(PCUNICODE_STRING inUnicodeString) -> ULONG #PASSIVE_LEVEL
SDBUS_CALLBACK_ROUTINE(PVOID inCallbackRoutineContext, ULONG inInterruptType) -> VOID #DISPATCH_LEVEL
ScsiPortInitialize(PVOID inArgument1, PVOID inArgument2, struct in_HW_INITIALIZATION_DATA *HwInitializationData, PVOID inHwContext) -> SCSIPORT_ULONG #PASSIVE_LEVEL
SdBusOpenInterface(PDEVICE_OBJECT inPdo, PSDBUS_INTERFACE_STANDARD outInterfaceStandard, USHORT inSize, USHORT inVersion) -> NTSTATUS #APC_LEVEL
SdBusSubmitRequest(PVOID inInterfaceContext, PSDBUS_REQUEST_PACKET inPacket) -> NTSTATUS #APC_LEVEL
SdBusSubmitRequestAsync(PVOID inInterfaceContext, PSDBUS_REQUEST_PACKET inPacket, PIRP inIrp, PIO_COMPLETION_ROUTINE inCompletionRoutine, PVOID inUserContext) -> NTSTATUS #DISPATCH_LEVEL
SeAccessCheck(PSECURITY_DESCRIPTOR inSecurityDescriptor, PSECURITY_SUBJECT_CONTEXT inSubjectSecurityContext, BOOLEAN inSubjectContextLocked, ACCESS_MASK inDesiredAccess, ACCESS_MASK inPreviouslyGrantedAccess, PPRIVILEGE_SET *Privileges, PGENERIC_MAPPING inGenericMapping, KPROCESSOR_MODE inAccessMode, PACCESS_MASK outGrantedAccess, PNTSTATUS outAccessStatus) -> BOOLEAN #PASSIVE_LEVEL
SeAssignSecurity(PSECURITY_DESCRIPTOR inParentDescriptor, PSECURITY_DESCRIPTOR inExplicitDescriptor, PSECURITY_DESCRIPTOR out*NewDescriptor, BOOLEAN inIsDirectoryObject, PSECURITY_SUBJECT_CONTEXT inSubjectContext, PGENERIC_MAPPING inGenericMapping, POOL_TYPE inPoolType) -> NTSTATUS #PASSIVE_LEVEL
SeDeassignSecurity(PSECURITY_DESCRIPTOR *SecurityDescriptor) -> NTSTATUS #PASSIVE_LEVEL
SeSinglePrivilegeCheck(LUID inPrivilegeValue, KPROCESSOR_MODE inPreviousMode) -> BOOLEAN #PASSIVE_LEVEL
SeValidSecurityDescriptor(ULONG inLength, PSECURITY_DESCRIPTOR SecurityDescriptor) -> BOOLEAN #PASSIVE_LEVEL
StorPortAllocateContiguousMemorySpecifyCacheNode(PVOID inHwDeviceExtension, SIZE_T inNumberOfBytes, PHYSICAL_ADDRESS inLowestAcceptableAddress, PHYSICAL_ADDRESS inHighestAcceptableAddress, PHYSICAL_ADDRESS inBoundaryAddressMultiple, MEMORY_CACHING_TYPE inCacheType, NODE_REQUIREMENT inPreferredNode, PVOIDout* BufferPointer) -> FORCEINLINE #DISPATCH_LEVEL
StorPortGetLogicalProcessorRelationship(PVOID inHwDeviceExtension, PPROCESSOR_NUMBER inProcessorNumber, LOGICAL_PROCESSOR_RELATIONSHIP inRelationshipType, PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX Information, PULONG ioLength) -> FORCEINLINE #DISPATCH_LEVEL
StreamClassQueryMasterClockSync(HANDLE inMasterClockHandle, PHW_TIME_CONTEXT ioTimeContext) -> VOID #DISPATCH_LEVEL
StreamClassReadWriteConfig(PVOID inHwDeviceExtension, BOOLEAN inRead,  PVOID Buffer, ULONG inOffset, ULONG inLength) -> BOOLEAN #PASSIVE_LEVEL
StreamClassRegisterAdapter(PVOID inArgument1, PVOID inArgument2, PHW_INITIALIZATION_DATA inHwInitializationData) -> NTSTATUS #PASSIVE_LEVEL
StreamClassRegisterFilterWithNoKSPins(PDEVICE_OBJECT inDeviceObject, const inGUID * InterfaceClassGUID, ULONG inPinCount, BOOL * PinDirection, KSPIN_MEDIUM * MediumList, inGUID * CategoryList) -> NTSTATUS #APC_LEVEL
TdiCopyBufferToMdl(PVOID inSourceBuffer, ULONG inSourceOffset, ULONG inSourceBytesToCopy, PMDL inDestinationMdlChain, ULONG inDestinationOffset, PULONG outBytesCopied) -> NTSTATUS #DISPATCH_LEVEL
TdiCopyMdlChainToMdlChain(PMDL inSourceMdlChain, ULONG inSourceOffset, PMDL inDestinationMdlChain, ULONG inDestinationOffset, PULONG outBytesCopied) -> NTSTATUS #DISPATCH_LEVEL
TdiCopyMdlToBuffer(PMDL inSourceMdlChain, ULONG inSourceOffset, PVOID DestinationBuffer, ULONG inDestinationOffset, ULONG inDestinationBufferSize, PULONG outBytesCopied) -> NTSTATUS #DISPATCH_LEVEL
TdiDeregisterDeviceObject(HANDLE inRegistrationHandle) -> NTSTATUS #APC_LEVEL
TdiDeregisterNetAddress(HANDLE inRegistrationHandle) -> NTSTATUS #APC_LEVEL
TdiDeregisterPnPHandlers(HANDLE inBindingHandle) -> NTSTATUS #APC_LEVEL
TdiDeregisterProvider(HANDLE inProviderHandle) -> NTSTATUS #APC_LEVEL
TdiEnumerateAddresses(HANDLE inBindingHandle) -> NTSTATUS #APC_LEVEL
TdiInitialize(VOID) -> VOID #PASSIVE_LEVEL
TdiMapUserRequest(PDEVICE_OBJECT inDeviceObject, PIRP inIrp, PIO_STACK_LOCATION inIrpSp) -> NTSTATUS #PASSIVE_LEVEL
TdiPnPPowerComplete(HANDLE inBindingHandle, PNET_PNP_EVENT inPowerEvent, NTSTATUS inStatus) -> VOID #APC_LEVEL
TdiPnPPowerRequest(PUNICODE_STRING inDeviceName, PNET_PNP_EVENT inPowerEvent, PTDI_PNP_CONTEXT inContext1, PTDI_PNP_CONTEXT inContext2, ProviderPnPPowerComplete inProtocolCompletionHandler) -> NTSTATUS #APC_LEVEL
TdiProviderReady(HANDLE inProviderHandle) -> NTSTATUS #APC_LEVEL
TdiRegisterDeviceObject(PUNICODE_STRING inDeviceName, HANDLE out*RegistrationHandle) -> NTSTATUS #APC_LEVEL
TdiRegisterNetAddress(PTA_ADDRESS inAddress, PUNICODE_STRING inDeviceName, PTDI_PNP_CONTEXT inContext, HANDLE out*RegistrationHandle) -> NTSTATUS #APC_LEVEL
TdiRegisterPnPHandlers(PTDI_CLIENT_INTERFACE_INFO ClientInterfaceInfo, ULONG inInterfaceInfoSize, HANDLE out*BindingHandle) -> NTSTATUS #APC_LEVEL
TdiRegisterProvider(PUNICODE_STRING inProviderName, HANDLE out*ProviderHandle) -> NTSTATUS #APC_LEVEL
TdiReturnChainedReceives(inPVOID *TsduDescriptors, ULONG inNumberOfTsdus) -> VOID #DISPATCH_LEVEL
TmCommitComplete(PKENLISTMENT inEnlistment, PLARGE_INTEGER inTmVirtualClock) -> NTSTATUS #APC_LEVEL
TmCommitEnlistment(PKENLISTMENT inEnlistment, PLARGE_INTEGER inTmVirtualClock) -> NTSTATUS #APC_LEVEL
TmCommitTransaction(PKTRANSACTION inTransaction, BOOLEAN inWait) -> NTSTATUS #APC_LEVEL
TmCreateEnlistment(PHANDLE outEnlistmentHandle, KPROCESSOR_MODE inPreviousMode, ACCESS_MASK inDesiredAccess, POBJECT_ATTRIBUTES inObjectAttributes, PRKRESOURCEMANAGER inResourceManager, PKTRANSACTION inTransaction, ULONG inCreateOptions, NOTIFICATION_MASK inNotificationMask, PVOID inEnlistmentKey) -> NTSTATUS #APC_LEVEL
TmDereferenceEnlistmentKey(PKENLISTMENT inEnlistment, PBOOLEAN outLastReference) -> NTSTATUS #APC_LEVEL
TmEnableCallbacks(PKRESOURCEMANAGER inResourceManager, PTM_RM_NOTIFICATION inCallbackRoutine, PVOID inRMKey) -> NTSTATUS #APC_LEVEL
TmGetTransactionId(PKTRANSACTION inTransaction, PUOW outTransactionId) -> VOID #APC_LEVEL
TmInitializeTransactionManager(PRKTM inTransactionManager, PCUNICODE_STRING inLogFileName, PGUID inTmId, ULONG inCreateOptions) -> NTSTATUS #APC_LEVEL
TmIsTransactionActive(PKTRANSACTION inTransaction) -> BOOLEAN #APC_LEVEL
TmPrePrepareComplete(PKENLISTMENT inEnlistment, PLARGE_INTEGER inTmVirtualClock) -> NTSTATUS #APC_LEVEL
TmPrePrepareEnlistment(PKENLISTMENT inEnlistment, PLARGE_INTEGER inTmVirtualClock) -> NTSTATUS #APC_LEVEL
TmPrepareComplete(PKENLISTMENT inEnlistment, PLARGE_INTEGER inTmVirtualClock) -> NTSTATUS #APC_LEVEL
TmPrepareEnlistment(PKENLISTMENT inEnlistment, PLARGE_INTEGER inTmVirtualClock) -> NTSTATUS #APC_LEVEL
TmPropagationComplete(PKRESOURCEMANAGER inResourceManager, ULONG inRequestCookie, ULONG inBufferLength, PVOID inBuffer) -> NTSTATUS #APC_LEVEL
TmPropagationFailed(PKRESOURCEMANAGER inResourceManager, ULONG inRequestCookie, NTSTATUS inStatus) -> NTSTATUS #APC_LEVEL
TmReadOnlyEnlistment(PKENLISTMENT inEnlistment, PLARGE_INTEGER inTmVirtualClock) -> NTSTATUS #APC_LEVEL
TmRecoverEnlistment(PKENLISTMENT inEnlistment, PVOID inEnlistmentKey) -> NTSTATUS #APC_LEVEL
TmRecoverResourceManager(PKRESOURCEMANAGER inResourceManager) -> NTSTATUS #APC_LEVEL
TmRecoverTransactionManager(PKTM inTm, PLARGE_INTEGER inTargetVirtualClock) -> NTSTATUS #APC_LEVEL
TmReferenceEnlistmentKey(PKENLISTMENT inEnlistment, PVOID out*Key) -> NTSTATUS #APC_LEVEL
TmRegisterProtocolAddressInformation(PKRESOURCEMANAGER inResourceManager, PKCRM_PROTOCOL_ID inProtocolId, ULONG inProtocolInformationSize, PVOID inProtocolInformation) -> NTSTATUS #APC_LEVEL
TmRenameTransactionManager(PUNICODE_STRING inLogFileName, LPGUID inExistingTransactionManagerGuid) -> NTSTATUS #APC_LEVEL
TmRequestOutcomeEnlistment(PKENLISTMENT inEnlistment, PLARGE_INTEGER inTmVirtualClock) -> NTSTATUS #APC_LEVEL
TmRollbackComplete(PKENLISTMENT inEnlistment, PLARGE_INTEGER inTmVirtualClock) -> NTSTATUS #APC_LEVEL
TmRollbackEnlistment(PKENLISTMENT inEnlistment, PLARGE_INTEGER inTmVirtualClock) -> NTSTATUS #APC_LEVEL
TmRollbackTransaction(PKTRANSACTION inTransaction, BOOLEAN inWait) -> NTSTATUS #APC_LEVEL
TmSinglePhaseReject(PKENLISTMENT inEnlistment, PLARGE_INTEGER inTmVirtualClock) -> NTSTATUS #APC_LEVEL
USBD_CalculateUsbBandwidth(ULONG inMaxPacketSize, UCHAR inEndpointType, BOOLEAN inLowSpeed) -> ULONG #DISPATCH_LEVEL
USBD_CreateConfigurationRequestEx(PUSB_CONFIGURATION_DESCRIPTOR inConfigurationDescriptor, PUSBD_INTERFACE_LIST_ENTRY inInterfaceList) -> PURB #DISPATCH_LEVEL
USBD_GetInterfaceLength(PUSB_INTERFACE_DESCRIPTOR inInterfaceDescriptor, PUCHAR inBufferEnd) -> ULONG #PASSIVE_LEVEL
USBD_GetPdoRegistryParameter(PDEVICE_OBJECT inPhysicalDeviceObject,  PVOID Parameter, ULONG inParameterLength, PWSTR KeyName, ULONG inKeyNameLength) -> NTSTATUS #APC_LEVEL
USBD_GetUSBDIVersion(PUSBD_VERSION_INFORMATION outVersionInformation) -> VOID #DISPATCH_LEVEL
USBD_ParseConfigurationDescriptorEx(PUSB_CONFIGURATION_DESCRIPTOR inConfigurationDescriptor, PVOID inStartPosition, LONG inInterfaceNumber, LONG inAlternateSetting, LONG inInterfaceClass, LONG inInterfaceSubClass, LONG inInterfaceProtocol) -> PUSB_INTERFACE_DESCRIPTOR #APC_LEVEL
USBD_ParseDescriptors(PVOID inDescriptorBuffer, ULONG inTotalLength, PVOID inStartPosition, LONG inDescriptorType) -> PUSB_COMMON_DESCRIPTOR #APC_LEVEL
USBD_RegisterHcFilter(PDEVICE_OBJECT inDeviceObject, PDEVICE_OBJECT inFilterDeviceObject) -> VOID #PASSIVE_LEVEL
VideoPortAcquireDeviceLock(IN PVOID HwDeviceExtension) -> VIDEOPORT_VOID #PASSIVE_LEVEL
VideoPortAcquireSpinLock(PVOID ioHwDeviceExtension, PSPIN_LOCK inSpinLock, PUCHAR outOldIrql ) -> VIDEOPORT_VOID #DISPATCH_LEVEL
VideoPortAcquireSpinLockAtDpcLevel(PVOID ioHwDeviceExtension, PSPIN_LOCK inSpinLock) -> VIDEOPORT_VOID #DISPATCH_LEVEL
VideoPortAllocateBuffer(IN PVOID HwDeviceExtension, IN ULONG Size, OUT PVOID *Buffer) -> VIDEOPORT_VP_STATUS #PASSIVE_LEVEL
VideoPortAllocateCommonBuffer(IN PVOID HwDeviceExtension, IN PVP_DMA_ADAPTER VpDmaAdapter, IN ULONG DesiredLength, OUT PPHYSICAL_ADDRESS LogicalAddress, IN BOOLEAN CacheEnabled, OUT PVOID Reserved) -> (" #PASSIVE_LEVEL
VideoPortAllocateContiguousMemory(IN PVOID HwDeviceExtension, IN ULONG NumberOfBytes, IN PHYSICAL_ADDRESS HighestAcceptableAddress) -> VIDEOPORT_PVOID #PASSIVE_LEVEL
VideoPortAllocatePool(IN PVOID HwDeviceExtension, IN VP_POOL_TYPE PoolType, IN SIZE_T NumberOfBytes, IN ULONG Tag) -> VIDEOPORT_PVOID #DISPATCH_LEVEL
VideoPortCheckForDeviceExistence(IN PVOID HwDeviceExtension, IN USHORT VendorId, IN USHORT DeviceId, IN UCHAR RevisionId, IN USHORT SubVendorId, IN USHORT SubSystemId, IN ULONG Flags) -> VIDEOPORT_BOOLEAN #PASSIVE_LEVEL
VideoPortClearEvent(IN PVOID HwDeviceExtension, IN PEVENT pEvent) -> VIDEOPORT_VOID #DISPATCH_LEVEL
VideoPortCompleteDma(IN PVOID HwDeviceExtension, IN PVP_DMA_ADAPTER VpDmaAdapter, IN PVP_SCATTER_GATHER_LIST VpScatterGather, IN BOOLEAN WriteToDevice) -> VIDEOPORT_VP_STATUS #DISPATCH_LEVEL
VideoPortCreateEvent(IN PVOID HwDeviceExtension, IN ULONG EventFlag, IN PVOID Unused, OUT PEVENT *ppEvent) -> VIDEOPORT_VP_STATUS #PASSIVE_LEVEL
VideoPortCreateSecondaryDisplay(IN PVOID HwDeviceExtension, IN OUT PVOID *SecondaryDeviceExtension, IN ULONG ulFlag) -> VIDEOPORT_VP_STATUS #PASSIVE_LEVEL
VideoPortCreateSpinLock(IN PVOID HwDeviceExtension, OUT PSPIN_LOCK *SpinLock) -> VIDEOPORT_VP_STATUS #PASSIVE_LEVEL
VideoPortDDCMonitorHelper(IN PVOID HwDeviceExtension, IN PVOID DDCControl, IN OUT  PUCHAR EdidBuffer, IN ULONG EdidBufferSize) -> VIDEOPORT_BOOLEAN #PASSIVE_LEVEL
VideoPortDeleteEvent(IN PVOID HwDeviceExtension, IN PEVENT pEvent) -> VIDEOPORT_VP_STATUS #DISPATCH_LEVEL
VideoPortDeleteSpinLock(IN PVOID HwDeviceExtension, IN PSPIN_LOCK SpinLock) -> VIDEOPORT_VP_STATUS #DISPATCH_LEVEL
VideoPortEnumerateChildren(IN PVOID HwDeviceExtension, IN PVOID Reserved) -> VIDEOPORT_VP_STATUS #DISPATCH_LEVEL
VideoPortFlushRegistry(PVOID HwDeviceExtension) -> VIDEOPORT_VP_STATUS #PASSIVE_LEVEL
VideoPortFreeCommonBuffer(IN PVOID HwDeviceExtension, IN ULONG Length, IN PVOID VirtualAddress, IN PHYSICAL_ADDRESS LogicalAddress, IN BOOLEAN CacheEnabled) -> VIDEOPORT_VOID #PASSIVE_LEVEL
VideoPortFreeDeviceBase(PVOID HwDeviceExtension, PVOID MappedAddress) -> VIDEOPORT_VOID #PASSIVE_LEVEL
VideoPortFreePool(IN PVOID HwDeviceExtension, IN PVOID Ptr) -> (" #DISPATCH_LEVEL
VideoPortGetAccessRanges(PVOID HwDeviceExtension, ULONG NumRequestedResources, PIO_RESOURCE_DESCRIPTOR inRequestedResources OPTIONAL, ULONG NumAccessRanges, PVIDEO_ACCESS_RANGE AccessRanges, PVOID VendorId, PVOID DeviceId, PULONG Slot) -> VIDEOPORT_VP_STATUS #PASSIVE_LEVEL
VideoPortGetAgpServices(IN PVOID HwDeviceExtension, IN PVIDEO_PORT_AGP_SERVICES AgpServices) -> STDAPICALLTYPE #PASSIVE_LEVEL
VideoPortGetAssociatedDeviceExtension(IN PVOID DeviceObject) -> VIDEOPORT_PVOID #PASSIVE_LEVEL
VideoPortGetAssociatedDeviceID(IN PVOID DeviceObject) -> VIDEOPORT_ULONG #PASSIVE_LEVEL
VideoPortGetBusData(PVOID HwDeviceExtension, BUS_DATA_TYPE BusDataType, ULONG SlotNumber, PVOID Buffer, ULONG Offset, ULONG Length) -> VIDEOPORT_ULONG #PASSIVE_LEVEL
VideoPortGetCommonBuffer(IN PVOID HwDeviceExtension, IN ULONG DesiredLength, IN ULONG Alignment, OUT PPHYSICAL_ADDRESS LogicalAddress, OUT PULONG pActualLength, IN BOOLEAN CacheEnabled) -> VIDEOPORT_PVOID #PASSIVE_LEVEL
VideoPortGetDeviceData(PVOID HwDeviceExtension, VIDEO_DEVICE_DATA_TYPE DeviceDataType, PMINIPORT_QUERY_DEVICE_ROUTINE CallbackRoutine, PVOID Context) -> VIDEOPORT_VP_STATUS #PASSIVE_LEVEL
VideoPortGetDmaAdapter(IN PVOID HwDeviceExtension, IN PVP_DEVICE_DESCRIPTION VpDeviceDescription) -> VIDEOPORT_PVP_DMA_ADAPTER #PASSIVE_LEVEL
VideoPortGetRegistryParameters(PVOID HwDeviceExtension, PWSTR inParameterName, UCHAR IsParameterFileName, PMINIPORT_GET_REGISTRY_ROUTINE GetRegistryRoutine, PVOID Context) -> VIDEOPORT_VP_STATUS #PASSIVE_LEVEL
VideoPortGetRomImage(IN PVOID HwDeviceExtension, IN PVOID Unused1, IN ULONG Unused2, IN ULONG Length) -> PVOID #PASSIVE_LEVEL
VideoPortGetVersion(IN PVOID HwDeviceExtension, IN OUT PVPOSVERSIONINFO pVpOsVersionInfo) -> VIDEOPORT_VP_STATUS #PASSIVE_LEVEL
VideoPortGetVgaStatus(PVOID HwDeviceExtension, OUT PULONG VgaStatus) -> VIDEOPORT_VP_STATUS #PASSIVE_LEVEL
VideoPortInitialize(PVOID Argument1, PVOID Argument2, PVIDEO_HW_INITIALIZATION_DATA HwInitializationData, PVOID HwContext) -> VIDEOPORT_ULONG #PASSIVE_LEVEL
VideoPortInt10(PVOID HwDeviceExtension, PVIDEO_X86_BIOS_ARGUMENTS BiosArguments) -> VIDEOPORT_VP_STATUS #PASSIVE_LEVEL
VideoPortLockBuffer(IN PVOID HwDeviceExtension, IN PVOID BaseAddress, IN ULONG Length, IN VP_LOCK_OPERATION Operation) -> VIDEOPORT_PVOID #PASSIVE_LEVEL
VideoPortLogError(PVOID HwDeviceExtension, PVIDEO_REQUEST_PACKET Vrp OPTIONAL, VP_STATUS ErrorCode, ULONG UniqueId) -> VIDEOPORT_VOID #HIGH_LEVEL
VideoPortMapBankedMemory(PVOID HwDeviceExtension, PHYSICAL_ADDRESS PhysicalAddress, PULONG Length, PULONG InIoSpace, PVOID *VirtualAddress, ULONG BankLength, UCHAR ReadWriteBank, PBANKED_SECTION_ROUTINE BankRoutine, PVOID Context) -> VIDEOPORT_VP_STATUS #PASSIVE_LEVEL
VideoPortMapMemory(PVOID HwDeviceExtension, PHYSICAL_ADDRESS PhysicalAddress, PULONG Length, PULONG InIoSpace, PVOID *VirtualAddress) -> VIDEOPORT_VP_STATUS #PASSIVE_LEVEL
VideoPortPutDmaAdapter(IN PVOID HwDeviceExtension, IN PVP_DMA_ADAPTER VpDmaAdapter) -> VIDEOPORT_VOID #PASSIVE_LEVEL
VideoPortQueryServices(IN PVOID HwDeviceExtension, IN VIDEO_PORT_SERVICES ServicesType, IN OUT PINTERFACE Interface) -> (" #PASSIVE_LEVEL
VideoPortQueueDpc(IN PVOID HwDeviceExtension, IN PMINIPORT_DPC_ROUTINE CallbackRoutine, IN PVOID Context) -> VIDEOPORT_BOOLEAN #HIGH_LEVEL
VideoPortReadStateEvent(IN PVOID HwDeviceExtension, IN PEVENT pEvent) -> VIDEOPORT_LONG #DISPATCH_LEVEL
VideoPortRegisterBugcheckCallback(IN PVOID HwDeviceExtension, IN ULONG BugcheckCode, IN PVIDEO_BUGCHECK_CALLBACK Callback, IN ULONG BugcheckDataSize) -> VIDEOPORT_VP_STATUS #PASSIVE_LEVEL
VideoPortReleaseBuffer(IN PVOID HwDeviceExtension, IN PVOID Buffer) -> VIDEOPORT_VOID #PASSIVE_LEVEL
VideoPortReleaseCommonBuffer(IN PVOID HwDeviceExtension, IN PVP_DMA_ADAPTER VpDmaAdapter, IN ULONG Length, IN PHYSICAL_ADDRESS LogicalAddress, IN PVOID VirtualAddress, IN BOOLEAN CacheEnabled) -> (" #PASSIVE_LEVEL
VideoPortReleaseDeviceLock(IN PVOID HwDeviceExtension) -> VIDEOPORT_VOID #PASSIVE_LEVEL
VideoPortReleaseSpinLock(PVOID inHwDeviceExtension, PSPIN_LOCK ioSpinLock, UCHAR inNewIrql) -> VIDEOPORT_VOID #DISPATCH_LEVEL
VideoPortReleaseSpinLockFromDpcLevel(PVOID inHwDeviceExtension, PSPIN_LOCK ioSpinLock ) -> VIDEOPORT_VOID #DISPATCH_LEVEL
VideoPortScanRom(PVOID HwDeviceExtension, PUCHAR RomBase, ULONG RomLength, PUCHAR String) -> VIDEOPORT_BOOLEAN #PASSIVE_LEVEL
VideoPortSetBusData(PVOID HwDeviceExtension, BUS_DATA_TYPE BusDataType, ULONG SlotNumber, PVOID Buffer, ULONG Offset, ULONG Length) -> VIDEOPORT_ULONG #PASSIVE_LEVEL
VideoPortSetEvent(IN PVOID HwDeviceExtension, IN PEVENT pEvent) -> VIDEOPORT_LONG #DISPATCH_LEVEL
VideoPortSetRegistryParameters(PVOID HwDeviceExtension, PWSTR inValueName, PVOID ValueData, ULONG ValueLength) -> VIDEOPORT_VP_STATUS #PASSIVE_LEVEL
VideoPortSetTrappedEmulatorPorts(PVOID HwDeviceExtension, ULONG NumAccessRanges, PVIDEO_ACCESS_RANGE AccessRange) -> VIDEOPORT_VP_STATUS #PASSIVE_LEVEL
VideoPortStartDma(IN PVOID HwDeviceExtension, IN PVP_DMA_ADAPTER VpDmaAdapter, IN PVOID Mdl, IN ULONG Offset, IN OUT PULONG pLength, IN PEXECUTE_DMA ExecuteDmaRoutine, IN PVOID Context, IN BOOLEAN WriteToDevice) -> VIDEOPORT_VP_STATUS #DISPATCH_LEVEL
VideoPortStartTimer(PVOID HwDeviceExtension) -> VIDEOPORT_VOID #DISPATCH_LEVEL
VideoPortStopTimer(PVOID HwDeviceExtension) -> VIDEOPORT_VOID #DISPATCH_LEVEL
VideoPortSynchronizeExecution(PVOID HwDeviceExtension, VIDEO_SYNCHRONIZE_PRIORITY Priority, PMINIPORT_SYNCHRONIZE_ROUTINE SynchronizeRoutine, PVOID Context) -> ) VIDEOPORT_VOID #HIGH_LEVEL
VideoPortUnlockBuffer(IN PVOID HwDeviceExtension, IN PVOID Mdl) -> VIDEOPORT_VOID #DISPATCH_LEVEL
VideoPortUnmapMemory(PVOID HwDeviceExtension, PVOID VirtualAddress, HANDLE ProcessHandle) -> VIDEOPORT_VP_STATUS #PASSIVE_LEVEL
VideoPortVerifyAccessRanges(PVOID HwDeviceExtension, ULONG NumAccessRanges, PVIDEO_ACCESS_RANGE inAccessRanges) -> VIDEOPORT_VP_STATUS #PASSIVE_LEVEL
VideoPortWaitForSingleObject(IN PVOID HwDeviceExtension, IN PVOID Object, IN PLARGE_INTEGER Timeout) -> VIDEOPORT_VP_STATUS #DISPATCH_LEVEL
WdmlibIoCreateDeviceSecure(PDRIVER_OBJECT inDriverObject, ULONG inDeviceExtensionSize, PUNICODE_STRING inDeviceName, DEVICE_TYPE inDeviceType, ULONG inDeviceCharacteristics, BOOLEAN inExclusive, PCUNICODE_STRING inDefaultSDDLString, LPCGUID inDeviceClassGuid, PDEVICE_OBJECT out*DeviceObject) -> ) VIDEOPORT_VP_STATUS #PASSIVE_LEVEL
WmiCompleteRequest(PDEVICE_OBJECT inDeviceObject, PIRP ioIrp, NTSTATUS inStatus, ULONG inBufferUsed, CCHAR inPriorityBoost) -> NTSTATUS #DISPATCH_LEVEL
WmiFireEvent(PDEVICE_OBJECT inDeviceObject, LPCGUID inGuid, ULONG inInstanceIndex, ULONG inEventDataSize, PVOID inEventData) -> NTSTATUS #DISPATCH_LEVEL
WmiQueryTraceInformation(TRACE_INFORMATION_CLASS inTraceInformationClass, PVOID TraceInformation, ULONG inTraceInformationLength, PULONG outRequiredLength, PVOID inBuffer) -> NTSTATUS #APC_LEVEL
WmiSystemControl(PWMILIB_CONTEXT inWmiLibInfo, PDEVICE_OBJECT inDeviceObject, PIRP ioIrp, PSYSCTL_IRP_DISPOSITION outIrpDisposition) -> NTSTATUS #PASSIVE_LEVEL
WmiTraceMessage(TRACEHANDLE inLoggerHandle, ULONG inMessageFlags, LPCGUID inMessageGuid, USHORT inMessageNumber, ...) -> NTSTATUS #HIGH_LEVEL
WmiTraceMessageVa(TRACEHANDLE inLoggerHandle, ULONG inMessageFlags, LPCGUID inMessageGuid, USHORT inMessageNumber, va_list inMessageArgList) -> NTSTATUS #HIGH_LEVEL
WRITE_REGISTER_BUFFER_UCHAR(PUCHAR inRegister,PUCHAR_Buffer,ULONG inCount -> ) NTSTATUS # DISPATCH_LEVEL
WRITE_REGISTER_BUFFER_ULONG(PULONG inRegister,PULONG_Buffer,ULONG inCount -> HIGH_LEVEL # DISPATCH_LEVEL
WRITE_REGISTER_BUFFER_USHORT(PUSHORT inRegister,PUSHORT_Buffer,ULONG inCount -> (HIGH_LEVEL # DISPATCH_LEVEL
WRITE_REGISTER_UCHAR(PUCHAR inRegister,UCHAR inValue -> __drv_maxIRQL # DISPATCH_LEVEL
WRITE_REGISTER_ULONG(PULONG inRegister,ULONG inValue -> ...) # DISPATCH_LEVEL
WRITE_REGISTER_USHORT(PUSHORT inRegister,USHORT inValue -> , ...) # DISPATCH_LEVEL
ZwAllocateLocallyUniqueId(PLUID outLuid) -> NTSTATUS #PASSIVE_LEVEL
ZwAllocateVirtualMemory(HANDLE inProcessHandle, ioPVOID *BaseAddress, ULONG_PTR inZeroBits, PSIZE_T ioRegionSize, ULONG inAllocationType, ULONG inProtect) -> NTSTATUS #PASSIVE_LEVEL
ZwCancelTimer(HANDLE inTimerHandle, PBOOLEAN outCurrentState) -> NTSTATUS #PASSIVE_LEVEL
ZwClose(HANDLE inHandle) -> NTSTATUS #PASSIVE_LEVEL
ZwCommitComplete(HANDLE inEnlistmentHandle, PLARGE_INTEGER inTmVirtualClock) -> NTSTATUS #PASSIVE_LEVEL
ZwCommitEnlistment(HANDLE inEnlistmentHandle, PLARGE_INTEGER inTmVirtualClock) -> NTSTATUS #PASSIVE_LEVEL
ZwCommitTransaction(HANDLE inTransactionHandle, BOOLEAN inWait) -> NTSTATUS #PASSIVE_LEVEL
ZwCreateDirectoryObject(PHANDLE outDirectoryHandle, ACCESS_MASK inDesiredAccess, POBJECT_ATTRIBUTES inObjectAttributes) -> NTSTATUS #PASSIVE_LEVEL
ZwCreateEnlistment(PHANDLE outEnlistmentHandle, ACCESS_MASK inDesiredAccess, HANDLE inResourceManagerHandle, HANDLE inTransactionHandle, POBJECT_ATTRIBUTES inObjectAttributes, ULONG inCreateOptions, NOTIFICATION_MASK inNotificationMask, PVOID inEnlistmentKey) -> NTSTATUS #PASSIVE_LEVEL
ZwCreateEvent(PHANDLE outEventHandle, ACCESS_MASK inDesiredAccess, POBJECT_ATTRIBUTES inObjectAttributes, EVENT_TYPE inEventType, BOOLEAN inInitialState) -> NTSTATUS #PASSIVE_LEVEL
ZwCreateFile(PHANDLE outFileHandle, ACCESS_MASK inDesiredAccess, POBJECT_ATTRIBUTES inObjectAttributes, PIO_STATUS_BLOCK outIoStatusBlock, PLARGE_INTEGER inAllocationSize, ULONG inFileAttributes, ULONG inShareAccess, ULONG inCreateDisposition, ULONG inCreateOptions, PVOID inEaBuffer, ULONG inEaLength) -> NTSTATUS #PASSIVE_LEVEL
ZwCreateKey(PHANDLE outKeyHandle, ACCESS_MASK inDesiredAccess, POBJECT_ATTRIBUTES inObjectAttributes, ULONG TitleIndex, PUNICODE_STRING inClass, ULONG inCreateOptions, PULONG outDisposition) -> NTSTATUS #PASSIVE_LEVEL
ZwCreateKeyTransacted(PHANDLE outKeyHandle, ACCESS_MASK inDesiredAccess, POBJECT_ATTRIBUTES inObjectAttributes, ULONG TitleIndex, PUNICODE_STRING inClass, ULONG inCreateOptions, HANDLE inTransactionHandle, PULONG outDisposition) -> NTSTATUS #PASSIVE_LEVEL
ZwCreateResourceManager(PHANDLE outResourceManagerHandle, ACCESS_MASK inDesiredAccess, HANDLE inTmHandle, LPGUID inResourceManagerGuid, POBJECT_ATTRIBUTES inObjectAttributes, ULONG inCreateOptions, PUNICODE_STRING inDescription) -> NTSTATUS #PASSIVE_LEVEL
ZwCreateSection(PHANDLE outSectionHandle, ACCESS_MASK inDesiredAccess, POBJECT_ATTRIBUTES inObjectAttributes, PLARGE_INTEGER inMaximumSize, ULONG inSectionPageProtection, ULONG inAllocationAttributes, HANDLE inFileHandle) -> NTSTATUS #APC_LEVEL
ZwCreateTimer(PHANDLE outTimerHandle, ACCESS_MASK inDesiredAccess, POBJECT_ATTRIBUTES inObjectAttributes, TIMER_TYPE inTimerType) -> NTSTATUS #PASSIVE_LEVEL
ZwCreateTransaction(PHANDLE outTransactionHandle, ACCESS_MASK inDesiredAccess, POBJECT_ATTRIBUTES inObjectAttributes, LPGUID inUow, HANDLE inTmHandle, ULONG inCreateOptions, ULONG inIsolationLevel, ULONG inIsolationFlags, PLARGE_INTEGER inTimeout, PUNICODE_STRING inDescription) -> NTSTATUS #PASSIVE_LEVEL
ZwCreateTransactionManager(PHANDLE outTmHandle, ACCESS_MASK inDesiredAccess, POBJECT_ATTRIBUTES inObjectAttributes, PUNICODE_STRING inLogFileName, ULONG inCreateOptions, ULONG inCommitStrength) -> NTSTATUS #PASSIVE_LEVEL
ZwDeleteFile(POBJECT_ATTRIBUTES inObjectAttributes) -> NTSTATUS #PASSIVE_LEVEL
ZwDeleteKey(HANDLE inKeyHandle) -> NTSTATUS #PASSIVE_LEVEL
ZwDeleteValueKey(HANDLE inKeyHandle, PUNICODE_STRING inValueName) -> NTSTATUS #PASSIVE_LEVEL
ZwDeviceIoControlFile(HANDLE inFileHandle, HANDLE inEvent, PIO_APC_ROUTINE inApcRoutine, PVOID inApcContext, PIO_STATUS_BLOCK outIoStatusBlock, ULONG inIoControlCode, PVOID inInputBuffer, ULONG inInputBufferLength, PVOID outOutputBuffer, ULONG inOutputBufferLength) -> NTSTATUS #PASSIVE_LEVEL
ZwDisplayString(PUNICODE_STRING inString) -> NTSTATUS #PASSIVE_LEVEL
ZwDuplicateObject(HANDLE inSourceProcessHandle, HANDLE inSourceHandle, HANDLE inTargetProcessHandle, PHANDLE outTargetHandle, ACCESS_MASK inDesiredAccess, ULONG inHandleAttributes, ULONG inOptions) -> NTSTATUS #PASSIVE_LEVEL
ZwDuplicateToken(HANDLE inExistingTokenHandle, ACCESS_MASK inDesiredAccess, POBJECT_ATTRIBUTES inObjectAttributes, BOOLEAN inEffectiveOnly, TOKEN_TYPE inTokenType, PHANDLE outNewTokenHandle) -> NTSTATUS #PASSIVE_LEVEL
ZwEnumerateKey(HANDLE inKeyHandle, ULONG inIndex, KEY_INFORMATION_CLASS inKeyInformationClass, PVOID outKeyInformation, ULONG inLength, PULONG outResultLength) -> ) NTSTATUS #PASSIVE_LEVEL
ZwEnumerateTransactionObject(HANDLE inRootObjectHandle, KTMOBJECT_TYPE inQueryType,  PKTMOBJECT_CURSOR ObjectCursor, ULONG inObjectCursorLength, PULONG outReturnLength) -> NTSTATUS #PASSIVE_LEVEL
ZwEnumerateValueKey(HANDLE inKeyHandle, ULONG inIndex, KEY_VALUE_INFORMATION_CLASS inKeyValueInformationClass, PVOID outKeyValueInformation, ULONG inLength, PULONG outResultLength) -> ) NTSTATUS #PASSIVE_LEVEL
ZwFlushBuffersFile(HANDLE inFileHandle, PIO_STATUS_BLOCK outIoStatusBlock) -> NTSTATUS #PASSIVE_LEVEL
ZwFlushKey(HANDLE inKeyHandle) -> NTSTATUS #PASSIVE_LEVEL
ZwFlushVirtualMemory(HANDLE inProcessHandle, ioPVOID *BaseAddress, PSIZE_T ioRegionSize, PIO_STATUS_BLOCK outIoStatus) -> NTSTATUS #APC_LEVEL
ZwFreeVirtualMemory(HANDLE inProcessHandle, ioPVOID *BaseAddress, PSIZE_T ioRegionSize, ULONG inFreeType) -> NTSTATUS #PASSIVE_LEVEL
ZwFsControlFile(HANDLE inFileHandle, HANDLE inEvent, PIO_APC_ROUTINE inApcRoutine, PVOID inApcContext, PIO_STATUS_BLOCK outIoStatusBlock, ULONG inFsControlCode, PVOID inInputBuffer, ULONG inInputBufferLength, PVOID outOutputBuffer, ULONG inOutputBufferLength) -> NTSTATUS #PASSIVE_LEVEL
ZwGetNotificationResourceManager(HANDLE inResourceManagerHandle, PTRANSACTION_NOTIFICATION outTransactionNotification, ULONG inNotificationLength, PLARGE_INTEGER inTimeout, PULONG outReturnLength, ULONG inAsynchronous, ULONG_PTR inAsynchronousContext) -> NTSTATUS #PASSIVE_LEVEL
ZwLoadDriver(PUNICODE_STRING inDriverServiceName) -> NTSTATUS #PASSIVE_LEVEL
ZwLockFile(HANDLE inFileHandle, HANDLE inEvent, PIO_APC_ROUTINE inApcRoutine, PVOID inApcContext, PIO_STATUS_BLOCK outIoStatusBlock, PLARGE_INTEGER inByteOffset, PLARGE_INTEGER inLength, ULONG inKey, BOOLEAN inFailImmediately, BOOLEAN inExclusiveLock) -> NTSTATUS #PASSIVE_LEVEL
ZwMakeTemporaryObject(HANDLE inHandle) -> NTSTATUS #PASSIVE_LEVEL
ZwMapViewOfSection(HANDLE inSectionHandle, HANDLE inProcessHandle, ioPVOID *BaseAddress, ULONG_PTR inZeroBits, SIZE_T inCommitSize, PLARGE_INTEGER SectionOffset, PSIZE_T ioViewSize, SECTION_INHERIT inInheritDisposition, ULONG inAllocationType, ULONG inWin32Protect) -> NTSTATUS #PASSIVE_LEVEL
ZwNotifyChangeKey(HANDLE inKeyHandle, HANDLE inEvent, PIO_APC_ROUTINE inApcRoutine, PVOID inApcContext, PIO_STATUS_BLOCK outIoStatusBlock, ULONG inCompletionFilter, BOOLEAN inWatchTree, PVOID outBuffer, ULONG inBufferSize, BOOLEAN inAsynchronous) -> NTSTATUS #PASSIVE_LEVEL
ZwNotifyChangeMultipleKeys(HANDLE inMasterKeyHandle, ULONG inCount, OBJECT_ATTRIBUTES inSubordinateObjects[], HANDLE inEvent, PIO_APC_ROUTINE inApcRoutine, PVOID inApcContext, PIO_STATUS_BLOCK outIoStatusBlock, ULONG inCompletionFilter, BOOLEAN inWatchTree, PVOID outBuffer, ULONG inBufferSize, BOOLEAN inAsynchronous) -> NTSTATUS #PASSIVE_LEVEL
ZwOpenDirectoryObject(PHANDLE outDirectoryHandle, ACCESS_MASK inDesiredAccess, POBJECT_ATTRIBUTES inObjectAttributes) -> NTSTATUS #PASSIVE_LEVEL
ZwOpenEnlistment(PHANDLE outEnlistmentHandle, ACCESS_MASK inDesiredAccess, HANDLE inRmHandle, LPGUID inEnlistmentGuid, POBJECT_ATTRIBUTES inObjectAttributes) -> NTSTATUS #PASSIVE_LEVEL
ZwOpenEvent(PHANDLE outEventHandle, ACCESS_MASK inDesiredAccess, POBJECT_ATTRIBUTES inObjectAttributes) -> NTSTATUS #PASSIVE_LEVEL
ZwOpenFile(PHANDLE outFileHandle, ACCESS_MASK inDesiredAccess, POBJECT_ATTRIBUTES inObjectAttributes, PIO_STATUS_BLOCK outIoStatusBlock, ULONG inShareAccess, ULONG inOpenOptions) -> NTSTATUS #PASSIVE_LEVEL
ZwOpenKey(PHANDLE outKeyHandle, ACCESS_MASK inDesiredAccess, POBJECT_ATTRIBUTES inObjectAttributes) -> NTSTATUS #PASSIVE_LEVEL
ZwOpenKeyEx(PHANDLE outKeyHandle, ACCESS_MASK inDesiredAccess, POBJECT_ATTRIBUTES inObjectAttributes, ULONG inOpenOptions) -> NTSTATUS #PASSIVE_LEVEL
ZwOpenKeyTransacted(PHANDLE outKeyHandle, ACCESS_MASK inDesiredAccess, POBJECT_ATTRIBUTES inObjectAttributes, HANDLE inTransactionHandle) -> NTSTATUS #PASSIVE_LEVEL
ZwOpenKeyTransactedEx(PHANDLE outKeyHandle, ACCESS_MASK inDesiredAccess, POBJECT_ATTRIBUTES inObjectAttributes, ULONG inOpenOptions, HANDLE inTransactionHandle) -> NTSTATUS #PASSIVE_LEVEL
ZwOpenProcess(PHANDLE outProcessHandle, ACCESS_MASK inDesiredAccess, POBJECT_ATTRIBUTES inObjectAttributes, PCLIENT_ID inClientId) -> NTSTATUS #PASSIVE_LEVEL
ZwOpenProcessTokenEx(HANDLE inProcessHandle, ACCESS_MASK inDesiredAccess, ULONG inHandleAttributes, PHANDLE outTokenHandle) -> NTSTATUS #PASSIVE_LEVEL
ZwOpenResourceManager(PHANDLE outResourceManagerHandle, ACCESS_MASK inDesiredAccess, HANDLE inTmHandle, LPGUID inResourceManagerGuid, POBJECT_ATTRIBUTES inObjectAttributes) -> NTSTATUS #PASSIVE_LEVEL
ZwOpenSection(PHANDLE outSectionHandle, ACCESS_MASK inDesiredAccess, POBJECT_ATTRIBUTES inObjectAttributes) -> NTSTATUS #PASSIVE_LEVEL
ZwOpenSymbolicLinkObject(PHANDLE outLinkHandle, ACCESS_MASK inDesiredAccess, POBJECT_ATTRIBUTES inObjectAttributes) -> NTSTATUS #PASSIVE_LEVEL
ZwOpenThreadTokenEx(HANDLE inThreadHandle, ACCESS_MASK inDesiredAccess, BOOLEAN inOpenAsSelf, ULONG inHandleAttributes, PHANDLE outTokenHandle) -> NTSTATUS #PASSIVE_LEVEL
ZwOpenTimer(PHANDLE outTimerHandle, ACCESS_MASK inDesiredAccess, POBJECT_ATTRIBUTES inObjectAttributes) -> NTSTATUS #PASSIVE_LEVEL
ZwOpenTransaction(PHANDLE outTransactionHandle, ACCESS_MASK inDesiredAccess, POBJECT_ATTRIBUTES inObjectAttributes, LPGUID inUow, HANDLE inTmHandle) -> NTSTATUS #PASSIVE_LEVEL
ZwOpenTransactionManager(PHANDLE outTmHandle, ACCESS_MASK inDesiredAccess, POBJECT_ATTRIBUTES inObjectAttributes, PUNICODE_STRING inLogFileName, LPGUID inTmIdentity, ULONG inOpenOptions) -> NTSTATUS #PASSIVE_LEVEL
ZwPowerInformation(POWER_INFORMATION_LEVEL inInformationLevel, PVOID inInputBuffer, ULONG inInputBufferLength, PVOID outOutputBuffer, ULONG inOutputBufferLength) -> NTSTATUS #PASSIVE_LEVEL
ZwPrePrepareComplete(HANDLE inEnlistmentHandle, PLARGE_INTEGER inTmVirtualClock) -> NTSTATUS #PASSIVE_LEVEL
ZwPrePrepareEnlistment(HANDLE inEnlistmentHandle, PLARGE_INTEGER inTmVirtualClock) -> NTSTATUS #PASSIVE_LEVEL
ZwPrepareComplete(HANDLE inEnlistmentHandle, PLARGE_INTEGER inTmVirtualClock) -> NTSTATUS #PASSIVE_LEVEL
ZwPrepareEnlistment(HANDLE inEnlistmentHandle, PLARGE_INTEGER inTmVirtualClock) -> NTSTATUS #PASSIVE_LEVEL
ZwQueryDirectoryFile(HANDLE inFileHandle, HANDLE inEvent, PIO_APC_ROUTINE inApcRoutine, PVOID inApcContext, PIO_STATUS_BLOCK outIoStatusBlock, PVOID FileInformation, ULONG inLength, FILE_INFORMATION_CLASS inFileInformationClass, BOOLEAN inReturnSingleEntry, PUNICODE_STRING inFileName, BOOLEAN inRestartScan) -> NTSTATUS #PASSIVE_LEVEL
ZwQueryEaFile(HANDLE inFileHandle, PIO_STATUS_BLOCK outIoStatusBlock, PVOID Buffer, ULONG inLength, BOOLEAN inReturnSingleEntry, PVOID inEaList, ULONG inEaListLength, PULONG inEaIndex, BOOLEAN inRestartScan) -> NTSTATUS #PASSIVE_LEVEL
ZwQueryFullAttributesFile(POBJECT_ATTRIBUTES inObjectAttributes, PFILE_NETWORK_OPEN_INFORMATION outFileInformation) -> NTSTATUS #PASSIVE_LEVEL
ZwQueryInformationEnlistment(HANDLE inEnlistmentHandle, ENLISTMENT_INFORMATION_CLASS inEnlistmentInformationClass, PVOID EnlistmentInformation, ULONG inEnlistmentInformationLength, PULONG outReturnLength) -> NTSTATUS #PASSIVE_LEVEL
ZwQueryInformationFile(HANDLE inFileHandle, PIO_STATUS_BLOCK outIoStatusBlock, PVOID FileInformation, ULONG inLength, FILE_INFORMATION_CLASS inFileInformationClass) -> NTSTATUS #PASSIVE_LEVEL
ZwQueryInformationResourceManager(HANDLE inResourceManagerHandle, RESOURCEMANAGER_INFORMATION_CLASS inResourceManagerInformationClass, PVOID ResourceManagerInformation, ULONG inResourceManagerInformationLength, PULONG outReturnLength) -> NTSTATUS #PASSIVE_LEVEL
ZwQueryInformationToken(HANDLE inTokenHandle, TOKEN_INFORMATION_CLASS inTokenInformationClass, PVOID outTokenInformation, ULONG inTokenInformationLength, PULONG outReturnLength) -> NTSTATUS #PASSIVE_LEVEL
ZwQueryInformationTransaction(HANDLE inTransactionHandle, TRANSACTION_INFORMATION_CLASS inTransactionInformationClass, PVOID TransactionInformation, ULONG inTransactionInformationLength, PULONG outReturnLength) -> NTSTATUS #PASSIVE_LEVEL
ZwQueryInformationTransactionManager(HANDLE inTransactionManagerHandle, TRANSACTIONMANAGER_INFORMATION_CLASS inTransactionManagerInformationClass, PVOID TransactionManagerInformation, ULONG inTransactionManagerInformationLength, PULONG outReturnLength) -> NTSTATUS #PASSIVE_LEVEL
ZwQueryKey(HANDLE inKeyHandle, KEY_INFORMATION_CLASS inKeyInformationClass, PVOID outKeyInformation, ULONG inLength, PULONG outResultLength) -> ) NTSTATUS #PASSIVE_LEVEL
ZwQueryMultipleValueKey(HANDLE inKeyHandle,  PKEY_VALUE_ENTRY ValueEntries, ULONG inEntryCount, PVOID ValueBuffer, PULONG ioBufferLength, PULONG outRequiredBufferLength) -> NTSTATUS #PASSIVE_LEVEL
ZwQueryObject(HANDLE inHandle, OBJECT_INFORMATION_CLASS inObjectInformationClass, PVOID outObjectInformation, ULONG inObjectInformationLength, PULONG outReturnLength) -> NTSTATUS #PASSIVE_LEVEL
ZwQueryQuotaInformationFile(HANDLE inFileHandle, PIO_STATUS_BLOCK outIoStatusBlock, PVOID Buffer, ULONG inLength, BOOLEAN inReturnSingleEntry, PVOID inSidList, ULONG inSidListLength, PSID inStartSid, BOOLEAN inRestartScan) -> NTSTATUS #PASSIVE_LEVEL
ZwQuerySecurityObject(HANDLE inHandle, SECURITY_INFORMATION inSecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor, ULONG inLength, PULONG outLengthNeeded) -> NTSTATUS #PASSIVE_LEVEL
ZwQuerySymbolicLinkObject(HANDLE inLinkHandle, PUNICODE_STRING ioLinkTarget, PULONG outReturnedLength) -> NTSTATUS #PASSIVE_LEVEL
ZwQueryValueKey(HANDLE inKeyHandle, PUNICODE_STRING inValueName, KEY_VALUE_INFORMATION_CLASS inKeyValueInformationClass, PVOID outKeyValueInformation, ULONG inLength, PULONG outResultLength) -> ) NTSTATUS #PASSIVE_LEVEL
ZwQueryVolumeInformationFile(HANDLE inFileHandle, PIO_STATUS_BLOCK outIoStatusBlock, PVOID FsInformation, ULONG inLength, FS_INFORMATION_CLASS inFsInformationClass) -> NTSTATUS #PASSIVE_LEVEL
ZwReadFile(HANDLE inFileHandle, HANDLE inEvent, PIO_APC_ROUTINE inApcRoutine, PVOID inApcContext, PIO_STATUS_BLOCK outIoStatusBlock, PVOID Buffer, ULONG inLength, PLARGE_INTEGER inByteOffset, PULONG inKey) -> NTSTATUS #PASSIVE_LEVEL
ZwReadOnlyEnlistment(HANDLE inEnlistmentHandle, PLARGE_INTEGER inTmVirtualClock) -> NTSTATUS #PASSIVE_LEVEL
ZwRecoverEnlistment(HANDLE inEnlistmentHandle, PVOID inEnlistmentKey) -> NTSTATUS #PASSIVE_LEVEL
ZwRecoverResourceManager(HANDLE inResourceManagerHandle) -> NTSTATUS #PASSIVE_LEVEL
ZwRecoverTransactionManager(HANDLE inTransactionManagerHandle) -> NTSTATUS #PASSIVE_LEVEL
ZwRenameKey(HANDLE inKeyHandle, PUNICODE_STRING inNewName) -> NTSTATUS #PASSIVE_LEVEL
ZwRollbackEnlistment(HANDLE inEnlistmentHandle, PLARGE_INTEGER inTmVirtualClock) -> NTSTATUS #PASSIVE_LEVEL
ZwRollbackTransaction(HANDLE inTransactionHandle, BOOLEAN inWait) -> NTSTATUS #PASSIVE_LEVEL
ZwRollforwardTransactionManager(HANDLE inTransactionManagerHandle, PLARGE_INTEGER inTmVirtualClock) -> NTSTATUS #PASSIVE_LEVEL
ZwSetEaFile(HANDLE inFileHandle, PIO_STATUS_BLOCK outIoStatusBlock, PVOID Buffer, ULONG inLength) -> NTSTATUS #PASSIVE_LEVEL
ZwSetEvent(HANDLE inEventHandle, PLONG outPreviousState) -> NTSTATUS #DISPATCH_LEVEL
ZwSetInformationEnlistment(HANDLE inEnlistmentHandle, ENLISTMENT_INFORMATION_CLASS inEnlistmentInformationClass, PVOID EnlistmentInformation, ULONG inEnlistmentInformationLength) -> NTSTATUS #PASSIVE_LEVEL
ZwSetInformationFile(HANDLE inFileHandle, PIO_STATUS_BLOCK outIoStatusBlock, PVOID FileInformation, ULONG inLength, FILE_INFORMATION_CLASS inFileInformationClass) -> NTSTATUS #PASSIVE_LEVEL
ZwSetInformationKey(HANDLE inKeyHandle, KEY_SET_INFORMATION_CLASS inKeySetInformationClass, PVOID KeySetInformation, ULONG inKeySetInformationLength) -> NTSTATUS #PASSIVE_LEVEL
ZwSetInformationResourceManager(HANDLE inResourceManagerHandle, RESOURCEMANAGER_INFORMATION_CLASS inResourceManagerInformationClass, PVOID ResourceManagerInformation, ULONG inResourceManagerInformationLength) -> NTSTATUS #PASSIVE_LEVEL
ZwSetInformationThread(HANDLE inThreadHandle, THREADINFOCLASS inThreadInformationClass, PVOID ThreadInformation, ULONG inThreadInformationLength) -> NTSTATUS #PASSIVE_LEVEL
ZwSetInformationToken(HANDLE inTokenHandle, TOKEN_INFORMATION_CLASS inTokenInformationClass, PVOID TokenInformation, ULONG inTokenInformationLength) -> NTSTATUS #PASSIVE_LEVEL
ZwSetInformationTransaction(HANDLE inTransactionHandle, TRANSACTION_INFORMATION_CLASS inTransactionInformationClass, PVOID inTransactionInformation, ULONG inTransactionInformationLength) -> NTSTATUS #PASSIVE_LEVEL
ZwSetInformationTransactionManager(HANDLE inTmHandle, TRANSACTIONMANAGER_INFORMATION_CLASS inTransactionManagerInformationClass, PVOID inTransactionManagerInformation, ULONG inTransactionManagerInformationLength) -> NTSTATUS #PASSIVE_LEVEL
ZwSetQuotaInformationFile(HANDLE inFileHandle, PIO_STATUS_BLOCK outIoStatusBlock, PVOID Buffer, ULONG inLength) -> NTSTATUS #PASSIVE_LEVEL
ZwSetSecurityObject(HANDLE inHandle, SECURITY_INFORMATION inSecurityInformation, PSECURITY_DESCRIPTOR inSecurityDescriptor) -> NTSTATUS #PASSIVE_LEVEL
ZwSetTimer(HANDLE inTimerHandle, PLARGE_INTEGER inDueTime, PTIMER_APC_ROUTINE inTimerApcRoutine, PVOID inTimerContext, BOOLEAN inResumeTimer, LONG inPeriod, PBOOLEAN outPreviousState) -> NTSTATUS #PASSIVE_LEVEL
ZwSetTimerEx(HANDLE inTimerHandle, TIMER_SET_INFORMATION_CLASS inTimerSetInformationClass, PVOID ioTimerSetInformation, ULONG inTimerSetInformationLength) -> NTSTATUS #PASSIVE_LEVEL
ZwSetValueKey(HANDLE inKeyHandle, PUNICODE_STRING inValueName, ULONG inTitleIndex, ULONG inType, PVOID inData, ULONG inDataSize) -> NTSTATUS #PASSIVE_LEVEL
ZwSetVolumeInformationFile(HANDLE inFileHandle, PIO_STATUS_BLOCK outIoStatusBlock, PVOID FsInformation, ULONG inLength, FS_INFORMATION_CLASS inFsInformationClass) -> NTSTATUS #PASSIVE_LEVEL
ZwSinglePhaseReject(HANDLE inEnlistmentHandle, PLARGE_INTEGER inTmVirtualClock) -> NTSTATUS #PASSIVE_LEVEL
ZwTerminateProcess(HANDLE inProcessHandle, NTSTATUS inExitStatus) -> NTSTATUS #PASSIVE_LEVEL
ZwUnloadDriver(PUNICODE_STRING inDriverServiceName) -> NTSTATUS #PASSIVE_LEVEL
ZwUnlockFile(HANDLE inFileHandle, PIO_STATUS_BLOCK outIoStatusBlock, PLARGE_INTEGER inByteOffset, PLARGE_INTEGER inLength, ULONG inKey) -> NTSTATUS #PASSIVE_LEVEL
ZwUnmapViewOfSection(HANDLE inProcessHandle, PVOID inBaseAddress) -> NTSTATUS #PASSIVE_LEVEL
ZwWaitForSingleObject(HANDLE inHandle, BOOLEAN inAlertable, PLARGE_INTEGER inTimeout) -> NTSTATUS #(QuadPart!=0)APC_LEVEL, (QuadPart==0)DISPATCH_LEVEL
ZwWriteFile(HANDLE inFileHandle, HANDLE inEvent, PIO_APC_ROUTINE inApcRoutine, PVOID inApcContext, PIO_STATUS_BLOCK outIoStatusBlock, PVOID Buffer, ULONG inLength, PLARGE_INTEGER inByteOffset, PULONG inKey) -> #PASSIVE_LEVEL

STATUS_SUCCESS #NTSTATUS
FACILITY_DEBUGGER #NTSTATUS
FACILITY_RPC_RUNTIME #NTSTATUS
FACILITY_RPC_STUBS #NTSTATUS
FACILITY_IO_ERROR_CODE #NTSTATUS
FACILITY_TERMINAL_SERVER #NTSTATUS
FACILITY_USB_ERROR_CODE #NTSTATUS
FACILITY_HID_ERROR_CODE #NTSTATUS
FACILITY_FIREWIRE_ERROR_CODE #NTSTATUS
FACILITY_CLUSTER_ERROR_CODE #NTSTATUS
FACILITY_ACPI_ERROR_CODE #NTSTATUS
FACILITY_SXS_ERROR_CODE #NTSTATUS
STATUS_SEVERITY_SUCCESS #NTSTATUS
STATUS_SEVERITY_INFORMATIONAL #NTSTATUS
STATUS_SEVERITY_WARNING #NTSTATUS
STATUS_SEVERITY_ERROR #NTSTATUS
STATUS_WAIT_0 #NTSTATUS
STATUS_WAIT_1 #NTSTATUS
STATUS_WAIT_2 #NTSTATUS
STATUS_WAIT_3 #NTSTATUS
STATUS_WAIT_63 #NTSTATUS
STATUS_ABANDONED #NTSTATUS
STATUS_ABANDONED_WAIT_0 #NTSTATUS
STATUS_ABANDONED_WAIT_63 #NTSTATUS
STATUS_USER_APC #NTSTATUS
STATUS_KERNEL_APC #NTSTATUS
STATUS_ALERTED #NTSTATUS
STATUS_TIMEOUT #NTSTATUS
STATUS_PENDING #NTSTATUS
STATUS_REPARSE #NTSTATUS
STATUS_MORE_ENTRIES #NTSTATUS
STATUS_NOT_ALL_ASSIGNED #NTSTATUS
STATUS_SOME_NOT_MAPPED #NTSTATUS
STATUS_OPLOCK_BREAK_IN_PROGRESS #NTSTATUS
STATUS_VOLUME_MOUNTED #NTSTATUS
STATUS_RXACT_COMMITTED #NTSTATUS
STATUS_NOTIFY_CLEANUP #NTSTATUS
STATUS_NOTIFY_ENUM_DIR #NTSTATUS
STATUS_NO_QUOTAS_FOR_ACCOUNT #NTSTATUS
STATUS_PRIMARY_TRANSPORT_CONNECT_FAILE #NTSTATUSD
STATUS_PAGE_FAULT_TRANSITION #NTSTATUS
STATUS_PAGE_FAULT_DEMAND_ZERO #NTSTATUS
STATUS_PAGE_FAULT_COPY_ON_WRITE #NTSTATUS
STATUS_PAGE_FAULT_GUARD_PAGE #NTSTATUS
STATUS_PAGE_FAULT_PAGING_FILE #NTSTATUS
STATUS_CACHE_PAGE_LOCKED #NTSTATUS
STATUS_CRASH_DUMP #NTSTATUS
STATUS_BUFFER_ALL_ZEROS #NTSTATUS
STATUS_REPARSE_OBJECT #NTSTATUS
STATUS_RESOURCE_REQUIREMENTS_CH #NTSTATUSANGED
STATUS_TRANSLATION_COMPLETE #NTSTATUS
STATUS_DS_MEMBERSHIP_EVALUATED_LOCALL #NTSTATUSY
STATUS_NOTHING_TO_TERMINATE #NTSTATUS
STATUS_PROCESS_NOT_IN_JOB #NTSTATUS
STATUS_PROCESS_IN_JOB #NTSTATUS
STATUS_OBJECT_NAME_EXISTS #NTSTATUS
STATUS_THREAD_WAS_SUSPENDED #NTSTATUS
STATUS_WORKING_SET_LIMIT_RANGE #NTSTATUS
STATUS_IMAGE_NOT_AT_BASE #NTSTATUS
STATUS_RXACT_STATE_CREATED #NTSTATUS
STATUS_SEGMENT_NOTIFICATION #NTSTATUS
STATUS_LOCAL_USER_SESSION_KEY #NTSTATUS
STATUS_BAD_CURRENT_DIRECTORY #NTSTATUS
STATUS_SERIAL_MORE_WRITES #NTSTATUS
STATUS_REGISTRY_RECOVERED #NTSTATUS
STATUS_FT_READ_RECOVERY_FROM_BACKUP #NTSTATUS
STATUS_FT_WRITE_RECOVERY #NTSTATUS
STATUS_SERIAL_COUNTER_TIMEOUT #NTSTATUS
STATUS_NULL_LM_PASSWORD #NTSTATUS
STATUS_IMAGE_MACHINE_TYPE_MISMATC #NTSTATUSH
STATUS_RECEIVE_PARTIAL #NTSTATUS
STATUS_RECEIVE_EXPEDITED #NTSTATUS
STATUS_RECEIVE_PARTIAL_EXPEDITED #NTSTATUS
STATUS_EVENT_DONE #NTSTATUS
STATUS_EVENT_PENDING #NTSTATUS
STATUS_CHECKING_FILE_SYSTEM #NTSTATUS
STATUS_FATAL_APP_EXIT #NTSTATUS
STATUS_PREDEFINED_HANDLE #NTSTATUS
STATUS_WAS_UNLOCKED #NTSTATUS
STATUS_SERVICE_NOTIFICATION #NTSTATUS
STATUS_WAS_LOCKED #NTSTATUS
STATUS_LOG_HARD_ERROR #NTSTATUS
STATUS_ALREADY_WIN32 #NTSTATUS
STATUS_WX86_UNSIMULATE #NTSTATUS
STATUS_WX86_CONTINUE #NTSTATUS
STATUS_WX86_SINGLE_STEP #NTSTATUS
STATUS_WX86_BREAKPOINT #NTSTATUS
STATUS_WX86_EXCEPTION_CONTINUE #NTSTATUS
STATUS_WX86_EXCEPTION_LASTCHANCE #NTSTATUS
STATUS_WX86_EXCEPTION_CHAIN #NTSTATUS
STATUS_IMAGE_MACHINE_TYPE_MISMATCH_EX #NTSTATUSE
STATUS_NO_YIELD_PERFORMED #NTSTATUS
STATUS_TIMER_RESUME_IGNORED #NTSTATUS
STATUS_ARBITRATION_UNHANDLED #NTSTATUS
STATUS_CARDBUS_NOT_SUPPORTED #NTSTATUS
STATUS_WX86_CREATEWX86TIB #NTSTATUS
STATUS_MP_PROCESSOR_MISMATCH #NTSTATUS
STATUS_HIBERNATED #NTSTATUS
STATUS_RESUME_HIBERNATION #NTSTATUS
STATUS_GUARD_PAGE_VIOLATION #NTSTATUS
STATUS_DATATYPE_MISALIGNMENT #NTSTATUS
STATUS_BREAKPOINT #NTSTATUS
STATUS_SINGLE_STEP #NTSTATUS
STATUS_BUFFER_OVERFLOW #NTSTATUS
STATUS_NO_MORE_FILES #NTSTATUS
STATUS_WAKE_SYSTEM_DEBUGGER #NTSTATUS
STATUS_HANDLES_CLOSED #NTSTATUS
STATUS_NO_INHERITANCE #NTSTATUS
STATUS_GUID_SUBSTITUTION_MADE #NTSTATUS
STATUS_PARTIAL_COPY #NTSTATUS
STATUS_DEVICE_PAPER_EMPTY #NTSTATUS
STATUS_DEVICE_POWERED_OFF #NTSTATUS
STATUS_DEVICE_OFF_LINE #NTSTATUS
STATUS_DEVICE_BUSY #NTSTATUS
STATUS_NO_MORE_EAS #NTSTATUS
STATUS_INVALID_EA_NAME #NTSTATUS
STATUS_EA_LIST_INCONSISTENT #NTSTATUS
STATUS_INVALID_EA_FLAG #NTSTATUS
STATUS_VERIFY_REQUIRED #NTSTATUS
STATUS_EXTRANEOUS_INFORMATION #NTSTATUS
STATUS_RXACT_COMMIT_NECESSARY #NTSTATUS
STATUS_NO_MORE_ENTRIES #NTSTATUS
STATUS_FILEMARK_DETECTED #NTSTATUS
STATUS_MEDIA_CHANGED #NTSTATUS
STATUS_BUS_RESET #NTSTATUS
STATUS_END_OF_MEDIA #NTSTATUS
STATUS_BEGINNING_OF_MEDIA #NTSTATUS
STATUS_MEDIA_CHECK #NTSTATUS
STATUS_SETMARK_DETECTED #NTSTATUS
STATUS_NO_DATA_DETECTED #NTSTATUS
STATUS_REDIRECTOR_HAS_OPEN_HANDLE #NTSTATUSS
STATUS_SERVER_HAS_OPEN_HANDLES #NTSTATUS
STATUS_ALREADY_DISCONNECTED #NTSTATUS
STATUS_LONGJUMP #NTSTATUS
STATUS_CLEANER_CARTRIDGE_ #NTSTATUSINSTALLED
STATUS_PLUGPLAY_QUERY_VETOED #NTSTATUS
STATUS_UNWIND_CONSOLIDATE #NTSTATUS
STATUS_CLUSTER_NODE_ALREADY_UP #NTSTATUS
STATUS_CLUSTER_NODE_ALREADY_DOWN #NTSTATUS
STATUS_CLUSTER_NETWORK_ALREADY_ONLINE #NTSTATUS
STATUS_CLUSTER_NETWORK_ALREADY_OFFLINE #NTSTATUS
STATUS_CLUSTER_NODE_ALREADY_MEMBER #NTSTATUS
STATUS_UNSUCCESSFUL #NTSTATUS
STATUS_NOT_IMPLEMENTED #NTSTATUS
STATUS_INVALID_INFO_CLASS #NTSTATUS
STATUS_INFO_LENGTH_MISMATCH #NTSTATUS
STATUS_ACCESS_VIOLATION #NTSTATUS
STATUS_IN_PAGE_ERROR #NTSTATUS
STATUS_PAGEFILE_QUOTA #NTSTATUS
STATUS_INVALID_HANDLE #NTSTATUS
STATUS_BAD_INITIAL_STACK #NTSTATUS
STATUS_BAD_INITIAL_PC #NTSTATUS
STATUS_INVALID_CID #NTSTATUS
STATUS_TIMER_NOT_CANCELED #NTSTATUS
STATUS_INVALID_PARAMETER #NTSTATUS
STATUS_NO_SUCH_DEVICE #NTSTATUS
STATUS_NO_SUCH_FILE #NTSTATUS
STATUS_INVALID_DEVICE_REQUEST #NTSTATUS
STATUS_END_OF_FILE #NTSTATUS
STATUS_WRONG_VOLUME #NTSTATUS
STATUS_NO_MEDIA_IN_DEVICE #NTSTATUS
STATUS_UNRECOGNIZED_MEDIA #NTSTATUS
STATUS_NONEXISTENT_SECTOR #NTSTATUS
STATUS_MORE_PROCESSING_REQUIRED #NTSTATUS
STATUS_NO_MEMORY #NTSTATUS
STATUS_CONFLICTING_ADDRESS #NTSTATUSES
STATUS_NOT_MAPPED_VIEW #NTSTATUS
STATUS_UNABLE_TO_FREE_VM #NTSTATUS
STATUS_UNABLE_TO_DELETE_SECTION #NTSTATUS
STATUS_INVALID_SYSTEM_SERVICE #NTSTATUS
STATUS_ILLEGAL_INSTRUCTION #NTSTATUS
STATUS_INVALID_LOCK_SEQUENCE #NTSTATUS
STATUS_INVALID_VIEW_SIZE #NTSTATUS
STATUS_INVALID_FILE_FOR_SECTION #NTSTATUS
STATUS_ALREADY_COMMITTED #NTSTATUS
STATUS_ACCESS_DENIED #NTSTATUS
STATUS_BUFFER_TOO_SMALL #NTSTATUS
STATUS_OBJECT_TYPE_MISMATCH #NTSTATUS
STATUS_NONCONTINUABLE_EXCEPTION #NTSTATUS
STATUS_INVALID_DISPOSITION #NTSTATUS
STATUS_UNWIND #NTSTATUS
STATUS_BAD_STACK #NTSTATUS
STATUS_INVALID_UNWIND_TARG #NTSTATUSET
STATUS_NOT_LOCKED #NTSTATUS
STATUS_PARITY_ERROR #NTSTATUS
STATUS_UNABLE_TO_DECOMMIT_VM #NTSTATUS
STATUS_NOT_COMMITTED #NTSTATUS
STATUS_INVALID_PORT_ATTRIBUTES #NTSTATUS
STATUS_PORT_MESSAGE_TOO_LONG #NTSTATUS
STATUS_INVALID_PARAMETER_MIX #NTSTATUS
STATUS_INVALID_QUOTA_LOWER #NTSTATUS
STATUS_DISK_CORRUPT_ERROR #NTSTATUS
STATUS_OBJECT_NAME_INVALID #NTSTATUS
STATUS_OBJECT_NAME_NOT_FOUND #NTSTATUS
STATUS_OBJECT_NAME_COLLISION #NTSTATUS
STATUS_PORT_DISCONNECTED #NTSTATUS
STATUS_DEVICE_ALREADY_ATTACHED #NTSTATUS
STATUS_OBJECT_PATH_INVALID #NTSTATUS
STATUS_OBJECT_PATH_NOT_FOUND #NTSTATUS
STATUS_OBJECT_PATH_SYNTAX_BAD #NTSTATUS
STATUS_DATA_OVERRUN #NTSTATUS
STATUS_DATA_LATE_ERROR #NTSTATUS
STATUS_DATA_ERROR #NTSTATUS
STATUS_CRC_ERROR #NTSTATUS
STATUS_SECTION_TOO_BIG #NTSTATUS
STATUS_PORT_CONNECTION_REFUSED #NTSTATUS
STATUS_INVALID_PORT_HANDLE #NTSTATUS
STATUS_SHARING_VIOLATION #NTSTATUS
STATUS_QUOTA_EXCEEDED #NTSTATUS
STATUS_INVALID_PAGE_PROTECTION #NTSTATUS
STATUS_MUTANT_NOT_OWNED #NTSTATUS
STATUS_SEMAPHORE_LIMIT_EXCEEDED #NTSTATUS
STATUS_PORT_ALREADY_SET #NTSTATUS
STATUS_SECTION_NOT_IMAGE #NTSTATUS
STATUS_SUSPEND_COUNT_EXCEEDED #NTSTATUS
STATUS_THREAD_IS_TERMINATING #NTSTATUS
STATUS_BAD_WORKING_SET_LIMIT #NTSTATUS
STATUS_INCOMPATIBLE_FILE_MAP #NTSTATUS
STATUS_SECTION_PROTECTION #NTSTATUS
STATUS_EAS_NOT_SUPPORTED #NTSTATUS
STATUS_EA_TOO_LARGE #NTSTATUS
STATUS_NONEXISTENT_EA_ENTRY #NTSTATUS
STATUS_NO_EAS_ON_FILE #NTSTATUS
STATUS_EA_CORRUPT_ERROR #NTSTATUS
STATUS_FILE_LOCK_CONFLICT #NTSTATUS
STATUS_LOCK_NOT_GRANTED #NTSTATUS
STATUS_DELETE_PENDING #NTSTATUS
STATUS_CTL_FILE_NOT_SUPPORTED #NTSTATUS
STATUS_UNKNOWN_REVISION #NTSTATUS
STATUS_REVISION_MISMATCH #NTSTATUS
STATUS_INVALID_OWNER #NTSTATUS
STATUS_INVALID_PRIMARY_GROUP #NTSTATUS
STATUS_NO_IMPERSONATION_TOKEN #NTSTATUS
STATUS_CANT_DISABLE_MANDATORY #NTSTATUS
STATUS_NO_LOGON_SERVERS #NTSTATUS
STATUS_NO_SUCH_LOGON_SESSION #NTSTATUS
STATUS_NO_SUCH_PRIVILEGE #NTSTATUS
STATUS_PRIVILEGE_NOT_HELD #NTSTATUS
STATUS_INVALID_ACCOUNT_NAME #NTSTATUS
STATUS_USER_EXISTS #NTSTATUS
STATUS_NO_SUCH_USER #NTSTATUS
STATUS_GROUP_EXISTS #NTSTATUS
STATUS_NO_SUCH_GROUP #NTSTATUS
STATUS_MEMBER_IN_GROUP #NTSTATUS
STATUS_MEMBER_NOT_IN_GROUP #NTSTATUS
STATUS_LAST_ADMIN #NTSTATUS
STATUS_WRONG_PASSWORD #NTSTATUS
STATUS_ILL_FORMED_PASSWORD #NTSTATUS
STATUS_PASSWORD_RESTRICTION #NTSTATUS
STATUS_LOGON_FAILURE #NTSTATUS
STATUS_ACCOUNT_RESTRICTION #NTSTATUS
STATUS_INVALID_LOGON_HOURS #NTSTATUS
STATUS_INVALID_WORKSTATION #NTSTATUS
STATUS_PASSWORD_EXPIRED #NTSTATUS
STATUS_ACCOUNT_DISABLED #NTSTATUS
STATUS_NONE_MAPPED #NTSTATUS
STATUS_TOO_MANY_LUIDS_REQUES #NTSTATUSTED
STATUS_LUIDS_EXHAUSTED #NTSTATUS
STATUS_INVALID_SUB_AUTHORITY #NTSTATUS
STATUS_INVALID_ACL #NTSTATUS
STATUS_INVALID_SID #NTSTATUS
STATUS_INVALID_SECURITY_DESC #NTSTATUSR
STATUS_PROCEDURE_NOT_FOUND #NTSTATUS
STATUS_INVALID_IMAGE_FORMAT #NTSTATUS
STATUS_NO_TOKEN #NTSTATUS
STATUS_BAD_INHERITANCE_AC #NTSTATUSL
STATUS_RANGE_NOT_LOCKED #NTSTATUS
STATUS_DISK_FULL #NTSTATUS
STATUS_SERVER_DISABLED #NTSTATUS
STATUS_SERVER_NOT_DISABLED #NTSTATUS
STATUS_TOO_MANY_GUIDS_REQUESTED #NTSTATUS
STATUS_GUIDS_EXHAUSTED #NTSTATUS
STATUS_INVALID_ID_AUTHORITY #NTSTATUS
STATUS_AGENTS_EXHAUSTED #NTSTATUS
STATUS_INVALID_VOLUME_LABEL #NTSTATUS
STATUS_SECTION_NOT_EXTENDED #NTSTATUS
STATUS_NOT_MAPPED_DATA #NTSTATUS
STATUS_RESOURCE_DATA_NOT_FOUND #NTSTATUS
STATUS_RESOURCE_TYPE_NOT_FOUND #NTSTATUS
STATUS_RESOURCE_NAME_NOT_FOUND #NTSTATUS
STATUS_ARRAY_BOUNDS_EXCEEDED #NTSTATUS
STATUS_FLOAT_DENORMAL_OPERAND #NTSTATUS
STATUS_FLOAT_DIVIDE_BY_ZERO #NTSTATUS
STATUS_FLOAT_INEXACT_RESULT #NTSTATUS
STATUS_FLOAT_INVALID_OPERATION #NTSTATUS
STATUS_FLOAT_OVERFLOW #NTSTATUS
STATUS_FLOAT_STACK_CHECK #NTSTATUS
STATUS_FLOAT_UNDERFLOW #NTSTATUS
STATUS_INTEGER_DIVIDE_BY_ZERO #NTSTATUS
STATUS_INTEGER_OVERFLOW #NTSTATUS
STATUS_PRIVILEGED_INSTRUCTION #NTSTATUS
STATUS_TOO_MANY_PAGING_FILES #NTSTATUS
STATUS_FILE_INVALID #NTSTATUS
STATUS_ALLOTTED_SPACE_EXCEEDE #NTSTATUSD
STATUS_INSUFFICIENT_RESOURCES #NTSTATUS
STATUS_DFS_EXIT_PATH_FOUND #NTSTATUS
STATUS_DEVICE_DATA_ERROR #NTSTATUS
STATUS_DEVICE_NOT_CONNECTED #NTSTATUS
STATUS_DEVICE_POWER_FAILURE #NTSTATUS
STATUS_FREE_VM_NOT_AT_BASE #NTSTATUS
STATUS_MEMORY_NOT_ALLOCATED #NTSTATUS
STATUS_WORKING_SET_QUOTA #NTSTATUS
STATUS_MEDIA_WRITE_PROTECTED #NTSTATUS
STATUS_DEVICE_NOT_READY #NTSTATUS
STATUS_INVALID_GROUP_ATTRIBUTES #NTSTATUS
STATUS_BAD_IMPERSONATION_LEVEL #NTSTATUS
STATUS_CANT_OPEN_ANONYMOUS #NTSTATUS
STATUS_BAD_VALIDATION_CLASS #NTSTATUS
STATUS_BAD_TOKEN_TYPE #NTSTATUS
STATUS_BAD_MASTER_BOOT_RECORD #NTSTATUS
STATUS_INSTRUCTION_MISALIGNMENT #NTSTATUS
STATUS_INSTANCE_NOT_AVAILABLE #NTSTATUS
STATUS_PIPE_NOT_AVAILABLE #NTSTATUS
STATUS_INVALID_PIPE_STATE #NTSTATUS
STATUS_PIPE_BUSY #NTSTATUS
STATUS_ILLEGAL_FUNCTION #NTSTATUS
STATUS_PIPE_DISCONNECTED #NTSTATUS
STATUS_PIPE_CLOSING #NTSTATUS
STATUS_PIPE_CONNECTED #NTSTATUS
STATUS_PIPE_LISTENING #NTSTATUS
STATUS_INVALID_READ_MODE #NTSTATUS
STATUS_IO_TIMEOUT #NTSTATUS
STATUS_FILE_FORCED_CLOSED #NTSTATUS
STATUS_PROFILING_NOT_STARTED #NTSTATUS
STATUS_PROFILING_NOT_STOPPED #NTSTATUS
STATUS_COULD_NOT_INTERPRET #NTSTATUS
STATUS_FILE_IS_A_DIRECTORY #NTSTATUS
STATUS_NOT_SUPPORTED #NTSTATUS
STATUS_REMOTE_NOT_LISTENING #NTSTATUS
STATUS_DUPLICATE_NAME #NTSTATUS
STATUS_BAD_NETWORK_PATH #NTSTATUS
STATUS_NETWORK_BUSY #NTSTATUS
STATUS_DEVICE_DOES_NOT_EXIST #NTSTATUS
STATUS_TOO_MANY_COMMANDS #NTSTATUS
STATUS_ADAPTER_HARDWARE_ERROR #NTSTATUS
STATUS_INVALID_NETWORK_RESPONSE #NTSTATUS
STATUS_UNEXPECTED_NETWORK_ERROR #NTSTATUS
STATUS_BAD_REMOTE_ADAPTER #NTSTATUS
STATUS_PRINT_QUEUE_FULL #NTSTATUS
STATUS_NO_SPOOL_SPACE #NTSTATUS
STATUS_PRINT_CANCELLED #NTSTATUS
STATUS_NETWORK_NAME_DELETED #NTSTATUS
STATUS_NETWORK_ACCESS_DENIED #NTSTATUS
STATUS_BAD_DEVICE_TYPE #NTSTATUS
STATUS_BAD_NETWORK_NAME #NTSTATUS
STATUS_TOO_MANY_NAMES #NTSTATUS
STATUS_TOO_MANY_SESSIONS #NTSTATUS
STATUS_SHARING_PAUSED #NTSTATUS
STATUS_REQUEST_NOT_ACCEPTED #NTSTATUS
STATUS_REDIRECTOR_PAUSED #NTSTATUS
STATUS_NET_WRITE_FAULT #NTSTATUS
STATUS_PROFILING_AT_LIMIT #NTSTATUS
STATUS_NOT_SAME_DEVICE #NTSTATUS
STATUS_FILE_RENAMED #NTSTATUS
STATUS_VIRTUAL_CIRCUIT_CLOSED #NTSTATUS
STATUS_NO_SECURITY_ON_OBJECT #NTSTATUS
STATUS_CANT_WAIT #NTSTATUS
STATUS_PIPE_EMPTY #NTSTATUS
STATUS_CANT_ACCESS_DOMAIN_I #NTSTATUSNFO
STATUS_CANT_TERMINATE_SELF #NTSTATUS
STATUS_INVALID_SERVER_STATE #NTSTATUS
STATUS_INVALID_DOMAIN_STATE #NTSTATUS
STATUS_INVALID_DOMAIN_ROLE #NTSTATUS
STATUS_NO_SUCH_DOMAIN #NTSTATUS
STATUS_DOMAIN_EXISTS #NTSTATUS
STATUS_DOMAIN_LIMIT_EXCEEDED #NTSTATUS
STATUS_OPLOCK_NOT_GRANTED #NTSTATUS
STATUS_INVALID_OPLOCK_PROTOCOL #NTSTATUS
STATUS_INTERNAL_DB_CORRUPTION #NTSTATUS
STATUS_INTERNAL_ERROR #NTSTATUS
STATUS_GENERIC_NOT_MAPPED #NTSTATUS
STATUS_BAD_DESCRIPTOR_FORMAT #NTSTATUS
STATUS_INVALID_USER_BUFFER #NTSTATUS
STATUS_UNEXPECTED_IO_ERROR #NTSTATUS
STATUS_UNEXPECTED_MM_CREATE_ERR #NTSTATUS
STATUS_UNEXPECTED_MM_MAP_ERROR #NTSTATUS
STATUS_UNEXPECTED_MM_EXTEND_ERR #NTSTATUS
STATUS_NOT_LOGON_PROCESS #NTSTATUS
STATUS_LOGON_SESSION_EXISTS #NTSTATUS
STATUS_INVALID_PARAMETER_1 #NTSTATUS
STATUS_INVALID_PARAMETER_2 #NTSTATUS
STATUS_INVALID_PARAMETER_3 #NTSTATUS
STATUS_INVALID_PARAMETER_4 #NTSTATUS
STATUS_INVALID_PARAMETER_5 #NTSTATUS
STATUS_INVALID_PARAMETER_6 #NTSTATUS
STATUS_INVALID_PARAMETER_7 #NTSTATUS
STATUS_INVALID_PARAMETER_8 #NTSTATUS
STATUS_INVALID_PARAMETER_9 #NTSTATUS
STATUS_INVALID_PARAMETER_10 #NTSTATUS
STATUS_INVALID_PARAMETER_11 #NTSTATUS
STATUS_INVALID_PARAMETER_12 #NTSTATUS
STATUS_REDIRECTOR_NOT_STARTED #NTSTATUS
STATUS_REDIRECTOR_STARTED #NTSTATUS
STATUS_STACK_OVERFLOW #NTSTATUS
STATUS_NO_SUCH_PACKAGE #NTSTATUS
STATUS_BAD_FUNCTION_TABLE #NTSTATUS
STATUS_VARIABLE_NOT_FOUND #NTSTATUS
STATUS_DIRECTORY_NOT_EMPTY #NTSTATUS
STATUS_FILE_CORRUPT_ERROR #NTSTATUS
STATUS_NOT_A_DIRECTORY #NTSTATUS
STATUS_BAD_LOGON_SESSION_STATE #NTSTATUS
STATUS_LOGON_SESSION_COLLISION #NTSTATUS
STATUS_NAME_TOO_LONG #NTSTATUS
STATUS_FILES_OPEN #NTSTATUS
STATUS_CONNECTION_IN_USE #NTSTATUS
STATUS_MESSAGE_NOT_FOUND #NTSTATUS
STATUS_PROCESS_IS_TERMINATING #NTSTATUS
STATUS_INVALID_LOGON_TYPE #NTSTATUS
STATUS_NO_GUID_TRANSLATION #NTSTATUS
STATUS_CANNOT_IMPERSONATE #NTSTATUS
STATUS_IMAGE_ALREADY_LOADED #NTSTATUS
STATUS_ABIOS_NOT_PRESENT #NTSTATUS
STATUS_ABIOS_LID_NOT_EXIST #NTSTATUS
STATUS_ABIOS_LID_ALREADY_OWNED #NTSTATUS
STATUS_ABIOS_NOT_LID_OWNER #NTSTATUS
STATUS_ABIOS_INVALID_COMMAND #NTSTATUS
STATUS_ABIOS_INVALID_LID #NTSTATUS
STATUS_ABIOS_SELECTOR_NOT_AVAILABL #NTSTATUSE
STATUS_ABIOS_INVALID_SELECTOR #NTSTATUS
STATUS_NO_LDT #NTSTATUS
STATUS_INVALID_LDT_SIZE #NTSTATUS
STATUS_INVALID_LDT_OFFSET #NTSTATUS
STATUS_INVALID_LDT_DESCRIPTOR #NTSTATUS
STATUS_INVALID_IMAGE_NE_FORMAT #NTSTATUS
STATUS_RXACT_INVALID_STATE #NTSTATUS
STATUS_RXACT_COMMIT_FAILURE #NTSTATUS
STATUS_MAPPED_FILE_SIZE_ZERO #NTSTATUS
STATUS_TOO_MANY_OPENED_FILES #NTSTATUS
STATUS_CANCELLED #NTSTATUS
STATUS_CANNOT_DELETE #NTSTATUS
STATUS_INVALID_COMPUTER_NAME #NTSTATUS
STATUS_FILE_DELETED #NTSTATUS
STATUS_SPECIAL_ACCOUNT #NTSTATUS
STATUS_SPECIAL_GROUP #NTSTATUS
STATUS_SPECIAL_USER #NTSTATUS
STATUS_MEMBERS_PRIMARY_GROUP #NTSTATUS
STATUS_FILE_CLOSED #NTSTATUS
STATUS_TOO_MANY_THREADS #NTSTATUS
STATUS_THREAD_NOT_IN_PROCESS #NTSTATUS
STATUS_TOKEN_ALREADY_IN_USE #NTSTATUS
STATUS_PAGEFILE_QUOTA_EXCEEDED #NTSTATUS
STATUS_COMMITMENT_LIMIT #NTSTATUS
STATUS_INVALID_IMAGE_LE_FORMAT #NTSTATUS
STATUS_INVALID_IMAGE_NOT_MZ #NTSTATUS
STATUS_INVALID_IMAGE_PROTECT #NTSTATUS
STATUS_INVALID_IMAGE_WIN_16 #NTSTATUS
STATUS_LOGON_SERVER_CONFLICT #NTSTATUS
STATUS_TIME_DIFFERENCE_AT_DC #NTSTATUS
STATUS_SYNCHRONIZATION_REQUIRED #NTSTATUS
STATUS_DLL_NOT_FOUND #NTSTATUS
STATUS_OPEN_FAILED #NTSTATUS
STATUS_IO_PRIVILEGE_FAILED #NTSTATUS
STATUS_ORDINAL_NOT_FOUND #NTSTATUS
STATUS_ENTRYPOINT_NOT_FOUND #NTSTATUS
STATUS_CONTROL_C_EXIT #NTSTATUS
STATUS_LOCAL_DISCONNECT #NTSTATUS
STATUS_REMOTE_DISCONNECT #NTSTATUS
STATUS_REMOTE_RESOURCES #NTSTATUS
STATUS_LINK_FAILED #NTSTATUS
STATUS_LINK_TIMEOUT #NTSTATUS
STATUS_INVALID_CONNECTION #NTSTATUS
STATUS_INVALID_ADDRESS #NTSTATUS
STATUS_DLL_INIT_FAILED #NTSTATUS
STATUS_MISSING_SYSTEMFILE #NTSTATUS
STATUS_UNHANDLED_EXCEPTION #NTSTATUS
STATUS_APP_INIT_FAILURE #NTSTATUS
STATUS_PAGEFILE_CREATE_FAILED #NTSTATUS
STATUS_NO_PAGEFILE #NTSTATUS
STATUS_INVALID_LEVEL #NTSTATUS
STATUS_WRONG_PASSWORD_CORE #NTSTATUS
STATUS_ILLEGAL_FLOAT_CONTEXT #NTSTATUS
STATUS_PIPE_BROKEN #NTSTATUS
STATUS_REGISTRY_CORRUPT #NTSTATUS
STATUS_REGISTRY_IO_FAILED #NTSTATUS
STATUS_NO_EVENT_PAIR #NTSTATUS
STATUS_UNRECOGNIZED_VOLUME #NTSTATUS
STATUS_SERIAL_NO_DEVICE_INITED #NTSTATUS
STATUS_NO_SUCH_ALIAS #NTSTATUS
STATUS_MEMBER_NOT_IN_ALIAS #NTSTATUS
STATUS_MEMBER_IN_ALIAS #NTSTATUS
STATUS_ALIAS_EXISTS #NTSTATUS
STATUS_LOGON_NOT_GRANTED #NTSTATUS
STATUS_TOO_MANY_SECRETS #NTSTATUS
STATUS_SECRET_TOO_LONG #NTSTATUS
STATUS_INTERNAL_DB_ERROR #NTSTATUS
STATUS_FULLSCREEN_MODE #NTSTATUS
STATUS_TOO_MANY_CONTEXT_IDS #NTSTATUS
STATUS_LOGON_TYPE_NOT_GRANTED #NTSTATUS
STATUS_NOT_REGISTRY_FILE #NTSTATUS
STATUS_NT_CROSS_ENCRYPTION_REQUIRE #NTSTATUSD
STATUS_DOMAIN_CTRLR_CONFIG_ERROR #NTSTATUS
STATUS_FT_MISSING_MEMBER #NTSTATUS
STATUS_ILL_FORMED_SERVICE_ENTRY #NTSTATUS
STATUS_ILLEGAL_CHARACTER #NTSTATUS
STATUS_UNMAPPABLE_CHARACTER #NTSTATUS
STATUS_UNDEFINED_CHARACTER #NTSTATUS
STATUS_FLOPPY_VOLUME #NTSTATUS
STATUS_FLOPPY_ID_MARK_NOT_FOUN #NTSTATUSD
STATUS_FLOPPY_WRONG_CYLINDER #NTSTATUS
STATUS_FLOPPY_UNKNOWN_ERROR #NTSTATUS
STATUS_FLOPPY_BAD_REGISTERS #NTSTATUS
STATUS_DISK_RECALIBRATE_FAILED #NTSTATUS
STATUS_DISK_OPERATION_FAILED #NTSTATUS
STATUS_DISK_RESET_FAILED #NTSTATUS
STATUS_SHARED_IRQ_BUSY #NTSTATUS
STATUS_FT_ORPHANING #NTSTATUS
STATUS_BIOS_FAILED_TO_CONNECT #NTSTATUS_INTERRUPT
STATUS_PARTITION_FAILURE #NTSTATUS
STATUS_INVALID_BLOCK_LENGTH #NTSTATUS
STATUS_DEVICE_NOT_PARTITIONED #NTSTATUS
STATUS_UNABLE_TO_LOCK_MEDIA #NTSTATUS
STATUS_UNABLE_TO_UNLOAD_MEDIA #NTSTATUS
STATUS_EOM_OVERFLOW #NTSTATUS
STATUS_NO_MEDIA #NTSTATUS
STATUS_NO_SUCH_MEMBER #NTSTATUS
STATUS_INVALID_MEMBER #NTSTATUS
STATUS_KEY_DELETED #NTSTATUS
STATUS_NO_LOG_SPACE #NTSTATUS
STATUS_TOO_MANY_SIDS #NTSTATUS
STATUS_LM_CROSS_ENCRYPTION_REQ #NTSTATUSUIRED
STATUS_KEY_HAS_CHILDREN #NTSTATUS
STATUS_CHILD_MUST_BE_VOLATILE #NTSTATUS
STATUS_DEVICE_CONFIGURATION_ERROR #NTSTATUS
STATUS_DRIVER_INTERNAL_ERROR #NTSTATUS
STATUS_INVALID_DEVICE_STATE #NTSTATUS
STATUS_IO_DEVICE_ERROR #NTSTATUS
STATUS_DEVICE_PROTOCOL_ERROR #NTSTATUS
STATUS_BACKUP_CONTROLLER #NTSTATUS
STATUS_LOG_FILE_FULL #NTSTATUS
STATUS_TOO_LATE #NTSTATUS
STATUS_NO_TRUST_LSA_SECRE #NTSTATUST
STATUS_NO_TRUST_SAM_ACCOUNT #NTSTATUS
STATUS_TRUSTED_DOMAIN_FAILURE #NTSTATUS
STATUS_TRUSTED_RELATIONSHIP_FAILURE #NTSTATUS
STATUS_EVENTLOG_FILE_CORRUPT #NTSTATUS
STATUS_EVENTLOG_CANT_START #NTSTATUS
STATUS_TRUST_FAILURE #NTSTATUS
STATUS_MUTANT_LIMIT_EXCEEDED #NTSTATUS
STATUS_NETLOGON_NOT_STARTED #NTSTATUS
STATUS_ACCOUNT_EXPIRED #NTSTATUS
STATUS_POSSIBLE_DEADLOCK #NTSTATUS
STATUS_NETWORK_CREDENTIAL_CONFLICT #NTSTATUS
STATUS_REMOTE_SESSION_LIMIT #NTSTATUS
STATUS_EVENTLOG_FILE_CHANGED #NTSTATUS
STATUS_NOLOGON_INTERDOMAIN_TRUST_ACCOU #NTSTATUSNT
STATUS_NOLOGON_WORKSTATION_TRUST_ACCOUNT #NTSTATUS
STATUS_NOLOGON_SERVER_TRUST_ACCOUNT #NTSTATUS
STATUS_DOMAIN_TRUST_INCONSISTENT #NTSTATUS
STATUS_FS_DRIVER_REQUIRED #NTSTATUS
STATUS_NO_USER_SESSION_KEY #NTSTATUS
STATUS_USER_SESSION_DELETED #NTSTATUS
STATUS_RESOURCE_LANG_NOT_FOUND #NTSTATUS
STATUS_INSUFF_SERVER_RESOURCES #NTSTATUS
STATUS_INVALID_BUFFER_SIZE #NTSTATUS
STATUS_INVALID_ADDRESS_COMPONENT #NTSTATUS
STATUS_INVALID_ADDRESS_WILDCARD #NTSTATUS
STATUS_TOO_MANY_ADDRESSES #NTSTATUS
STATUS_ADDRESS_ALREADY_EXISTS #NTSTATUS
STATUS_ADDRESS_CLOSED #NTSTATUS
STATUS_CONNECTION_DISCONNECTED #NTSTATUS
STATUS_CONNECTION_RESET #NTSTATUS
STATUS_TOO_MANY_NODES #NTSTATUS
STATUS_TRANSACTION_ABORTED #NTSTATUS
STATUS_TRANSACTION_TIMED_OUT #NTSTATUS
STATUS_TRANSACTION_NO_RELEASE #NTSTATUS
STATUS_TRANSACTION_NO_MATCH #NTSTATUS
STATUS_TRANSACTION_RESPONDED #NTSTATUS
STATUS_TRANSACTION_INVALID_ID #NTSTATUS
STATUS_TRANSACTION_INVALID_TYPE #NTSTATUS
STATUS_NOT_SERVER_SESSION #NTSTATUS
STATUS_NOT_CLIENT_SESSION #NTSTATUS
STATUS_CANNOT_LOAD_REGISTRY_FILE #NTSTATUS
STATUS_DEBUG_ATTACH_FAILED #NTSTATUS
STATUS_SYSTEM_PROCESS_TERMINATED #NTSTATUS
STATUS_DATA_NOT_ACCEPTED #NTSTATUS
STATUS_NO_BROWSER_SERVERS_FOUND #NTSTATUS
STATUS_VDM_HARD_ERROR #NTSTATUS
STATUS_DRIVER_CANCEL_TIMEOUT #NTSTATUS
STATUS_REPLY_MESSAGE_MISMATCH #NTSTATUS
STATUS_MAPPED_ALIGNMENT #NTSTATUS
STATUS_IMAGE_CHECKSUM_MISMATCH #NTSTATUS
STATUS_LOST_WRITEBEHIND_DATA #NTSTATUS
STATUS_CLIENT_SERVER_PARAMETERS_INVALI #NTSTATUSD
STATUS_PASSWORD_MUST_CHANGE #NTSTATUS
STATUS_NOT_FOUND #NTSTATUS
STATUS_NOT_TINY_STREAM #NTSTATUS
STATUS_RECOVERY_FAILURE #NTSTATUS
STATUS_STACK_OVERFLOW_READ #NTSTATUS
STATUS_FAIL_CHECK #NTSTATUS
STATUS_DUPLICATE_OBJECTID #NTSTATUS
STATUS_OBJECTID_EXISTS #NTSTATUS
STATUS_CONVERT_TO_LARGE #NTSTATUS
STATUS_RETRY #NTSTATUS
STATUS_FOUND_OUT_OF_SC #NTSTATUSOPE
STATUS_ALLOCATE_BUCKET #NTSTATUS
STATUS_PROPSET_NOT_FOUND #NTSTATUS
STATUS_MARSHALL_OVERFLOW #NTSTATUS
STATUS_INVALID_VARIANT #NTSTATUS
STATUS_DOMAIN_CONTROLLER_NOT_FOU #NTSTATUSND
STATUS_ACCOUNT_LOCKED_OUT #NTSTATUS
STATUS_HANDLE_NOT_CLOSABLE #NTSTATUS
STATUS_CONNECTION_REFUSED #NTSTATUS
STATUS_GRACEFUL_DISCONNECT #NTSTATUS
STATUS_ADDRESS_ALREADY_ASSOCIATED #NTSTATUS
STATUS_ADDRESS_NOT_ASSOCIATED #NTSTATUS
STATUS_CONNECTION_INVALID #NTSTATUS
STATUS_CONNECTION_ACTIVE #NTSTATUS
STATUS_NETWORK_UNREACHABLE #NTSTATUS
STATUS_HOST_UNREACHABLE #NTSTATUS
STATUS_PROTOCOL_UNREACHABLE #NTSTATUS
STATUS_PORT_UNREACHABLE #NTSTATUS
STATUS_REQUEST_ABORTED #NTSTATUS
STATUS_CONNECTION_ABORTED #NTSTATUS
STATUS_BAD_COMPRESSION_BUFFER #NTSTATUS
STATUS_USER_MAPPED_FILE #NTSTATUS
STATUS_AUDIT_FAILED #NTSTATUS
STATUS_TIMER_RESOLUTION_NOT_S #NTSTATUSET
STATUS_CONNECTION_COUNT_LIMIT #NTSTATUS
STATUS_LOGIN_TIME_RESTRICTION #NTSTATUS
STATUS_LOGIN_WKSTA_RESTRICTION #NTSTATUS
STATUS_IMAGE_MP_UP_MISMATCH #NTSTATUS
STATUS_INSUFFICIENT_LOGON_INFO #NTSTATUS
STATUS_BAD_DLL_ENTRYPOINT #NTSTATUS
STATUS_BAD_SERVICE_ENTRYPOINT #NTSTATUS
STATUS_LPC_REPLY_LOST #NTSTATUS
STATUS_IP_ADDRESS_CONFLICT1 #NTSTATUS
STATUS_IP_ADDRESS_CONFLICT2 #NTSTATUS
STATUS_REGISTRY_QUOTA_LIMIT #NTSTATUS
STATUS_PATH_NOT_COVERED #NTSTATUS
STATUS_NO_CALLBACK_ACTIVE #NTSTATUS
STATUS_LICENSE_QUOTA_EXCEEDED #NTSTATUS
STATUS_PWD_TOO_SHORT #NTSTATUS
STATUS_PWD_TOO_RECENT #NTSTATUS
STATUS_PWD_HISTORY_CONFLICT #NTSTATUS
STATUS_PLUGPLAY_NO_DEVICE #NTSTATUS
STATUS_UNSUPPORTED_COMPRESSION #NTSTATUS
STATUS_INVALID_HW_PROFILE #NTSTATUS
STATUS_INVALID_PLUGPLAY_DEVICE_PATH #NTSTATUS
STATUS_DRIVER_ORDINAL_NOT_FOUND #NTSTATUS
STATUS_DRIVER_ENTRYPOINT_NOT_FOUND #NTSTATUS
STATUS_RESOURCE_NOT_OWNED #NTSTATUS
STATUS_TOO_MANY_LINKS #NTSTATUS
STATUS_QUOTA_LIST_INCONSISTENT #NTSTATUS
STATUS_FILE_IS_OFFLINE #NTSTATUS
STATUS_EVALUATION_EXPIRATION #NTSTATUS
STATUS_ILLEGAL_DLL_RELOCATION #NTSTATUS
STATUS_LICENSE_VIOLATION #NTSTATUS
STATUS_DLL_INIT_FAILED_LOGOFF #NTSTATUS
STATUS_DRIVER_UNABLE_TO_LOAD #NTSTATUS
STATUS_DFS_UNAVAILABLE #NTSTATUS
STATUS_VOLUME_DISMOUNTED #NTSTATUS
STATUS_WX86_INTERNAL_ERROR #NTSTATUS
STATUS_WX86_FLOAT_STACK_CHECK #NTSTATUS
STATUS_VALIDATE_CONTINUE #NTSTATUS
STATUS_NO_MATCH #NTSTATUS
STATUS_NO_MORE_MATCHES #NTSTATUS
STATUS_NOT_A_REPARSE_POINT #NTSTATUS
STATUS_IO_REPARSE_TAG_INVALID #NTSTATUS
STATUS_IO_REPARSE_TAG_MISMATCH #NTSTATUS
STATUS_IO_REPARSE_DATA_INVALID #NTSTATUS
STATUS_IO_REPARSE_TAG_NOT_HANDLED #NTSTATUS
STATUS_REPARSE_POINT_NOT_RESOLVED #NTSTATUS
STATUS_DIRECTORY_IS_A_REPARSE_POINT #NTSTATUS
STATUS_RANGE_LIST_CONFLICT #NTSTATUS
STATUS_SOURCE_ELEMENT_EMPTY #NTSTATUS
STATUS_DESTINATION_ELEMENT_FULL #NTSTATUS
STATUS_ILLEGAL_ELEMENT_ADDRESS #NTSTATUS
STATUS_MAGAZINE_NOT_PRESENT #NTSTATUS
STATUS_REINITIALIZATION_NEEDED #NTSTATUS
STATUS_DEVICE_REQUIRES_CLEANING #NTSTATUS
STATUS_DEVICE_DOOR_OPEN #NTSTATUS
STATUS_ENCRYPTION_FAILED #NTSTATUS
STATUS_DECRYPTION_FAILED #NTSTATUS
STATUS_RANGE_NOT_FOUND #NTSTATUS
STATUS_NO_RECOVERY_POLICY #NTSTATUS
STATUS_NO_EFS #NTSTATUS
STATUS_WRONG_EFS #NTSTATUS
STATUS_NO_USER_KEYS #NTSTATUS
STATUS_FILE_NOT_ENCRYPTED #NTSTATUS
STATUS_NOT_EXPORT_FORMAT #NTSTATUS
STATUS_FILE_ENCRYPTED #NTSTATUS
STATUS_WAKE_SYSTEM #NTSTATUS
STATUS_WMI_GUID_NOT_FOUND #NTSTATUS
STATUS_WMI_INSTANCE_NOT_FOUND #NTSTATUS
STATUS_WMI_ITEMID_NOT_FOUND #NTSTATUS
STATUS_WMI_TRY_AGAIN #NTSTATUS
STATUS_SHARED_POLICY #NTSTATUS
STATUS_POLICY_OBJECT_NOT_FOUND #NTSTATUS
STATUS_POLICY_ONLY_IN_DS #NTSTATUS
STATUS_VOLUME_NOT_UPGRADED #NTSTATUS
STATUS_REMOTE_STORAGE_NOT_ACTIVE #NTSTATUS
STATUS_REMOTE_STORAGE_MEDIA_ERROR #NTSTATUS
STATUS_NO_TRACKING_SERVICE #NTSTATUS
STATUS_SERVER_SID_MISMATCH #NTSTATUS
STATUS_DS_NO_ATTRIBUTE_OR_VALUE #NTSTATUS
STATUS_DS_INVALID_ATTRIBUTE_SYNTAX #NTSTATUS
STATUS_DS_ATTRIBUTE_TYPE_UNDEFINED #NTSTATUS
STATUS_DS_ATTRIBUTE_OR_VALUE_EXISTS #NTSTATUS
STATUS_DS_BUSY #NTSTATUS
STATUS_DS_UNAVAILABLE #NTSTATUS
STATUS_DS_NO_RIDS_ALLOCATED #NTSTATUS
STATUS_DS_NO_MORE_RIDS #NTSTATUS
STATUS_DS_INCORRECT_ROLE_OWNER #NTSTATUS
STATUS_DS_RIDMGR_INIT_ERROR #NTSTATUS
STATUS_DS_OBJ_CLASS_VIOLATION #NTSTATUS
STATUS_DS_CANT_ON_NON_LEAF #NTSTATUS
STATUS_DS_CANT_ON_RDN #NTSTATUS
STATUS_DS_CANT_MOD_OBJ_CLASS #NTSTATUS
STATUS_DS_CROSS_DOM_MOVE_FAILED #NTSTATUS
STATUS_DS_GC_NOT_AVAILABLE #NTSTATUS
STATUS_DIRECTORY_SERVICE_REQUIRED #NTSTATUS
STATUS_REPARSE_ATTRIBUTE_CONFLICT #NTSTATUS
STATUS_CANT_ENABLE_DENY_ONLY #NTSTATUS
STATUS_FLOAT_MULTIPLE_FAULTS #NTSTATUS
STATUS_FLOAT_MULTIPLE_TRAPS #NTSTATUS
STATUS_DEVICE_REMOVED #NTSTATUS
STATUS_JOURNAL_DELETE_IN_PROGRE #NTSTATUSSS
STATUS_JOURNAL_NOT_ACTIVE #NTSTATUS
STATUS_NOINTERFACE #NTSTATUS
STATUS_DS_ADMIN_LIMIT_EXCEED #NTSTATUSED
STATUS_DRIVER_FAILED_SLEEP #NTSTATUS
STATUS_MUTUAL_AUTHENTICATION_FAILED #NTSTATUS
STATUS_CORRUPT_SYSTEM_FILE #NTSTATUS
STATUS_DATATYPE_MISALIGNMENT_ERROR #NTSTATUS
STATUS_WMI_READ_ONLY #NTSTATUS
STATUS_WMI_SET_FAILURE #NTSTATUS
STATUS_COMMITMENT_MINIMUM #NTSTATUS
STATUS_REG_NAT_CONSUMPTION #NTSTATUS
STATUS_TRANSPORT_FULL #NTSTATUS
STATUS_DS_SAM_INIT_FAILURE #NTSTATUS
STATUS_ONLY_IF_CONNECTED #NTSTATUS
STATUS_DS_SENSITIVE_GROUP_VIOLATIO #NTSTATUSN
STATUS_PNP_RESTART_ENUMERATION #NTSTATUS
STATUS_JOURNAL_ENTRY_DELETED #NTSTATUS
STATUS_DS_CANT_MOD_PRIMARYGROUPID #NTSTATUS
STATUS_SYSTEM_IMAGE_BAD_SIGNATURE #NTSTATUS
STATUS_PNP_REBOOT_REQUIRED #NTSTATUS
STATUS_POWER_STATE_INVALID #NTSTATUS
STATUS_DS_INVALID_GROUP_TYPE #NTSTATUS
STATUS_DS_NO_NEST_GLOBALGROUP_IN_MIXED #NTSTATUSDOMAIN
STATUS_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN #NTSTATUS
STATUS_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER #NTSTATUS
STATUS_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER #NTSTATUS
STATUS_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER #NTSTATUS
STATUS_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER #NTSTATUS
STATUS_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER #NTSTATUS
STATUS_DS_HAVE_PRIMARY_MEMBERS #NTSTATUS
STATUS_WMI_NOT_SUPPORTED #NTSTATUS
STATUS_INSUFFICIENT_POWER #NTSTATUS
STATUS_SAM_NEED_BOOTKEY_PASSWORD #NTSTATUS
STATUS_SAM_NEED_BOOTKEY_FLOPPY #NTSTATUS
STATUS_DS_CANT_START #NTSTATUS
STATUS_DS_INIT_FAILURE #NTSTATUS
STATUS_SAM_INIT_FAILURE #NTSTATUS
STATUS_DS_GC_REQUIRED #NTSTATUS
STATUS_DS_LOCAL_MEMBER_OF_LOCAL #NTSTATUS_ONLY
STATUS_DS_NO_FPO_IN_UNIVERSAL_GROUPS #NTSTATUS
STATUS_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED #NTSTATUS
STATUS_MULTIPLE_FAULT_VIOLATION #NTSTATUS
STATUS_CURRENT_DOMAIN_NOT_ALLOWED #NTSTATUS
STATUS_CANNOT_MAKE #NTSTATUS
STATUS_SYSTEM_SHUTDOWN #NTSTATUS
STATUS_DS_INIT_FAILURE_CONSOLE #NTSTATUS
STATUS_DS_SAM_INIT_FAILURE_CONSOLE #NTSTATUS
STATUS_UNFINISHED_CONTEXT_DELETED #NTSTATUS
STATUS_NO_TGT_REPLY #NTSTATUS
STATUS_OBJECTID_NOT_FOUND #NTSTATUS
STATUS_NO_IP_ADDRESSES #NTSTATUS
STATUS_WRONG_CREDENTIAL_HANDLE #NTSTATUS
STATUS_CRYPTO_SYSTEM_INVALID #NTSTATUS
STATUS_MAX_REFERRALS_EXCEEDED #NTSTATUS
STATUS_MUST_BE_KDC #NTSTATUS
STATUS_STRONG_CRYPTO_NOT_SUP #NTSTATUSPORTED
STATUS_TOO_MANY_PRINCIPALS #NTSTATUS
STATUS_NO_PA_DATA #NTSTATUS
STATUS_PKINIT_NAME_MISMATCH #NTSTATUS
STATUS_SMARTCARD_LOGON_REQUIRED #NTSTATUS
STATUS_KDC_INVALID_REQUEST #NTSTATUS
STATUS_KDC_UNABLE_TO_REFER #NTSTATUS
STATUS_KDC_UNKNOWN_ETYPE #NTSTATUS
STATUS_SHUTDOWN_IN_PROGRESS #NTSTATUS
STATUS_SERVER_SHUTDOWN_IN_PROGRESS #NTSTATUS
STATUS_NOT_SUPPORTED_ON_SBS #NTSTATUS
STATUS_WMI_GUID_DISCONNECTED #NTSTATUS
STATUS_WMI_ALREADY_DISABLED #NTSTATUS
STATUS_WMI_ALREADY_ENABLED #NTSTATUS
STATUS_MFT_TOO_FRAGMENTED #NTSTATUS
STATUS_COPY_PROTECTION_FAILURE #NTSTATUS
STATUS_CSS_AUTHENTICATION_FAILURE #NTSTATUS
STATUS_CSS_KEY_NOT_PRESENT #NTSTATUS
STATUS_CSS_KEY_NOT_ESTABLISHED #NTSTATUS
STATUS_CSS_SCRAMBLED_SECTOR #NTSTATUS
STATUS_CSS_REGION_MISMATCH #NTSTATUS
STATUS_CSS_RESETS_EXHAUSTED #NTSTATUS
STATUS_PKINIT_FAILURE #NTSTATUS
STATUS_SMARTCARD_SUBSYSTEM_FAIL #NTSTATUSURE
STATUS_NO_KERB_KEY #NTSTATUS
STATUS_HOST_DOWN #NTSTATUS
STATUS_UNSUPPORTED_PREAUTH #NTSTATUS
STATUS_EFS_ALG_BLOB_TOO_BIG #NTSTATUS
STATUS_PORT_NOT_SET #NTSTATUS
STATUS_DEBUGGER_INACTIVE #NTSTATUS
STATUS_DS_VERSION_CHECK_FAILURE #NTSTATUS
STATUS_AUDITING_DISABLED #NTSTATUS
STATUS_PRENT4_MACHINE_ACCOUNT #NTSTATUS
STATUS_DS_AG_CANT_HAVE_UNIVERSAL_MEMBER #NTSTATUS
STATUS_INVALID_IMAGE_WIN_32 #NTSTATUS
STATUS_INVALID_IMAGE_WIN_64 #NTSTATUS
STATUS_BAD_BINDINGS #NTSTATUS
STATUS_NETWORK_SESSION_EXPIRE #NTSTATUSD
STATUS_APPHELP_BLOCK #NTSTATUS
STATUS_ALL_SIDS_FILTERED #NTSTATUS
STATUS_NOT_SAFE_MODE_DRIVER #NTSTATUS
STATUS_ACCESS_DISABLED_BY_POLICY_DEFA #NTSTATUSULT
STATUS_ACCESS_DISABLED_BY_POLICY_PATH #NTSTATUS
STATUS_ACCESS_DISABLED_BY_POLICY_PUBLISHER #NTSTATUS
STATUS_ACCESS_DISABLED_BY_POLICY_OTHER #NTSTATUS
STATUS_FAILED_DRIVER_ENTRY #NTSTATUS
STATUS_DEVICE_ENUMERATION_ERROR #NTSTATUS
STATUS_WAIT_FOR_OPLOCK #NTSTATUS
STATUS_MOUNT_POINT_NOT_RESOLVED #NTSTATUS
STATUS_INVALID_DEVICE_OBJECT_PARAMETER #NTSTATUS
STATUS_MCA_OCCURED #NTSTATUS
STATUS_DRIVER_BLOCKED_CRITIC #NTSTATUSAL
STATUS_DRIVER_BLOCKED #NTSTATUS
STATUS_DRIVER_DATABASE_ERROR #NTSTATUS
STATUS_SYSTEM_HIVE_TOO_LARGE #NTSTATUS
STATUS_INVALID_IMPORT_OF_NON_DLL #NTSTATUS
STATUS_DS_SHUTTING_DOWN #NTSTATUS
STATUS_SMARTCARD_WRONG_PIN #NTSTATUS
STATUS_SMARTCARD_CARD_BLOCKED #NTSTATUS
STATUS_SMARTCARD_CARD_NOT_AUTHENTICATED #NTSTATUS
STATUS_SMARTCARD_NO_CARD #NTSTATUS
STATUS_SMARTCARD_NO_KEY_CONTAINER #NTSTATUS
STATUS_SMARTCARD_NO_CERTIFICATE #NTSTATUS
STATUS_SMARTCARD_NO_KEYSET #NTSTATUS
STATUS_SMARTCARD_IO_ERROR #NTSTATUS
STATUS_DOWNGRADE_DETECTED #NTSTATUS
STATUS_SMARTCARD_CERT_REVOKED #NTSTATUS
STATUS_ISSUING_CA_UNTRUSTED #NTSTATUS
STATUS_REVOCATION_OFFLINE_C #NTSTATUS
STATUS_PKINIT_CLIENT_FAILURE #NTSTATUS
STATUS_SMARTCARD_CERT_EXPIRED #NTSTATUS
STATUS_DRIVER_FAILED_PRIOR_UNLOAD #NTSTATUS
STATUS_WOW_ASSERTION #NTSTATUS
RPC_NT_INVALID_STRING_BINDING #NTSTATUS
RPC_NT_WRONG_KIND_OF_BINDING #NTSTATUS
RPC_NT_INVALID_BINDING #NTSTATUS
RPC_NT_PROTSEQ_NOT_SUPPORTED #NTSTATUS
RPC_NT_INVALID_RPC_PROTSEQ #NTSTATUS
RPC_NT_INVALID_STRING_UUID #NTSTATUS
RPC_NT_INVALID_ENDPOINT_FORMAT #NTSTATUS
RPC_NT_INVALID_NET_ADDR #NTSTATUS
RPC_NT_NO_ENDPOINT_FOUND #NTSTATUS
RPC_NT_INVALID_TIMEOUT #NTSTATUS
RPC_NT_OBJECT_NOT_FOUND #NTSTATUS
RPC_NT_ALREADY_REGISTERED #NTSTATUS
RPC_NT_TYPE_ALREADY_REGISTERED #NTSTATUS
RPC_NT_ALREADY_LISTENING #NTSTATUS
RPC_NT_NO_PROTSEQS_REGISTERED #NTSTATUS
RPC_NT_NOT_LISTENING #NTSTATUS
RPC_NT_UNKNOWN_MGR_TYPE #NTSTATUS
RPC_NT_UNKNOWN_IF #NTSTATUS
RPC_NT_NO_BINDINGS #NTSTATUS
RPC_NT_NO_PROTSEQS #NTSTATUS
RPC_NT_CANT_CREATE_ENDPOINT #NTSTATUS
RPC_NT_OUT_OF_RESOURCES #NTSTATUS
RPC_NT_SERVER_UNAVAILABLE #NTSTATUS
RPC_NT_SERVER_TOO_BUSY #NTSTATUS
RPC_NT_INVALID_NETWORK_OPTIONS #NTSTATUS
RPC_NT_NO_CALL_ACTIVE #NTSTATUS
RPC_NT_CALL_FAILED #NTSTATUS
RPC_NT_CALL_FAILED_DNE #NTSTATUS
RPC_NT_PROTOCOL_ERROR #NTSTATUS
RPC_NT_UNSUPPORTED_TRANS_SYN #NTSTATUS
RPC_NT_UNSUPPORTED_TYPE #NTSTATUS
RPC_NT_INVALID_TAG #NTSTATUS
RPC_NT_INVALID_BOUND #NTSTATUS
RPC_NT_NO_ENTRY_NAME #NTSTATUS
RPC_NT_INVALID_NAME_SYNTAX #NTSTATUS
RPC_NT_UNSUPPORTED_NAME_SYNTAX #NTSTATUS
RPC_NT_UUID_NO_ADDRESS #NTSTATUS
RPC_NT_DUPLICATE_ENDPOINT #NTSTATUS
RPC_NT_UNKNOWN_AUTHN_TYPE #NTSTATUS
RPC_NT_MAX_CALLS_TOO_SMALL #NTSTATUS
RPC_NT_STRING_TOO_LONG #NTSTATUS
RPC_NT_PROTSEQ_NOT_FOUND #NTSTATUS
RPC_NT_PROCNUM_OUT_OF_RANGE #NTSTATUS
RPC_NT_BINDING_HAS_NO_AUTH #NTSTATUS
RPC_NT_UNKNOWN_AUTHN_SERVICE #NTSTATUS
RPC_NT_UNKNOWN_AUTHN_LEVEL #NTSTATUS
RPC_NT_INVALID_AUTH_IDENTITY #NTSTATUS
RPC_NT_UNKNOWN_AUTHZ_SERVICE #NTSTATUS
EPT_NT_INVALID_ENTRY #NTSTATUS
EPT_NT_CANT_PERFORM_OP #NTSTATUS
EPT_NT_NOT_REGISTERED #NTSTATUS
RPC_NT_NOTHING_TO_EXPORT #NTSTATUS
RPC_NT_INCOMPLETE_NAME #NTSTATUS
RPC_NT_INVALID_VERS_OPTION #NTSTATUS
RPC_NT_NO_MORE_MEMBERS #NTSTATUS
RPC_NT_NOT_ALL_OBJS_UNEXPORTED #NTSTATUS
RPC_NT_INTERFACE_NOT_FOUND #NTSTATUS
RPC_NT_ENTRY_ALREADY_EXISTS #NTSTATUS
RPC_NT_ENTRY_NOT_FOUND #NTSTATUS
RPC_NT_NAME_SERVICE_UNAVAILABLE #NTSTATUS
RPC_NT_INVALID_NAF_ID #NTSTATUS
RPC_NT_CANNOT_SUPPORT #NTSTATUS
RPC_NT_NO_CONTEXT_AVAILABLE #NTSTATUS
RPC_NT_INTERNAL_ERROR #NTSTATUS
RPC_NT_ZERO_DIVIDE #NTSTATUS
RPC_NT_ADDRESS_ERROR #NTSTATUS
RPC_NT_FP_DIV_ZERO #NTSTATUS
RPC_NT_FP_UNDERFLOW #NTSTATUS
RPC_NT_FP_OVERFLOW #NTSTATUS
RPC_NT_NO_MORE_ENTRIES #NTSTATUS
RPC_NT_SS_CHAR_TRANS_OPEN_FAIL #NTSTATUS
RPC_NT_SS_CHAR_TRANS_SHORT_FILE #NTSTATUS
RPC_NT_SS_IN_NULL_CONTEXT #NTSTATUS
RPC_NT_SS_CONTEXT_MISMATCH #NTSTATUS
RPC_NT_SS_CONTEXT_DAMAGED #NTSTATUS
RPC_NT_SS_HANDLES_MISMATCH #NTSTATUS
RPC_NT_SS_CANNOT_GET_CALL_HANDLE #NTSTATUS
RPC_NT_NULL_REF_POINTER #NTSTATUS
RPC_NT_ENUM_VALUE_OUT_OF_RANGE #NTSTATUS
RPC_NT_BYTE_COUNT_TOO_SMALL #NTSTATUS
RPC_NT_BAD_STUB_DATA #NTSTATUS
RPC_NT_CALL_IN_PROGRESS #NTSTATUS
RPC_NT_NO_MORE_BINDINGS #NTSTATUS
RPC_NT_GROUP_MEMBER_NOT_FOUND #NTSTATUS
EPT_NT_CANT_CREATE #NTSTATUS
RPC_NT_INVALID_OBJECT #NTSTATUS
RPC_NT_NO_INTERFACES #NTSTATUS
RPC_NT_CALL_CANCELLED #NTSTATUS
RPC_NT_BINDING_INCOMPLETE #NTSTATUS
RPC_NT_COMM_FAILURE #NTSTATUS
RPC_NT_UNSUPPORTED_AUTHN_LEVE #NTSTATUSL
RPC_NT_NO_PRINC_NAME #NTSTATUS
RPC_NT_NOT_RPC_ERROR #NTSTATUS
RPC_NT_UUID_LOCAL_ONLY #NTSTATUS
RPC_NT_SEC_PKG_ERROR #NTSTATUS
RPC_NT_NOT_CANCELLED #NTSTATUS
RPC_NT_INVALID_ES_ACTION #NTSTATUS
RPC_NT_WRONG_ES_VERSION #NTSTATUS
RPC_NT_WRONG_STUB_VERSION #NTSTATUS
RPC_NT_INVALID_PIPE_OBJECT #NTSTATUS
RPC_NT_INVALID_PIPE_OPERATION #NTSTATUS
RPC_NT_WRONG_PIPE_VERSION #NTSTATUS
RPC_NT_PIPE_CLOSED #NTSTATUS
RPC_NT_PIPE_DISCIPLINE_ERROR #NTSTATUS
RPC_NT_PIPE_EMPTY #NTSTATUS
RPC_NT_INVALID_ASYNC_HANDLE #NTSTATUS
RPC_NT_INVALID_ASYNC_CALL #NTSTATUS
RPC_NT_SEND_INCOMPLETE #NTSTATUS
STATUS_ACPI_INVALID_OPCODE #NTSTATUS
STATUS_ACPI_STACK_OVERFLOW #NTSTATUS
STATUS_ACPI_ASSERT_FAILED #NTSTATUS
STATUS_ACPI_INVALID_INDEX #NTSTATUS
STATUS_ACPI_INVALID_ARGUMENT #NTSTATUS
STATUS_ACPI_FATAL #NTSTATUS
STATUS_ACPI_INVALID_SUPERNA #NTSTATUSME
STATUS_ACPI_INVALID_ARGTYPE #NTSTATUS
STATUS_ACPI_INVALID_OBJTYPE #NTSTATUS
STATUS_ACPI_INVALID_TARGETTYPE #NTSTATUS
STATUS_ACPI_INCORRECT_ARGUMENT_COUNT #NTSTATUS
STATUS_ACPI_ADDRESS_NOT_MAPPED #NTSTATUS
STATUS_ACPI_INVALID_EVENTTYPE #NTSTATUS
STATUS_ACPI_HANDLER_COLLISION #NTSTATUS
STATUS_ACPI_INVALID_DATA #NTSTATUS
STATUS_ACPI_INVALID_REGION #NTSTATUS
STATUS_ACPI_INVALID_ACCESS_SIZE #NTSTATUS
STATUS_ACPI_ACQUIRE_GLOBAL_LOCK #NTSTATUS
STATUS_ACPI_ALREADY_INITIALIZED #NTSTATUS
STATUS_ACPI_NOT_INITIALIZED #NTSTATUS
STATUS_ACPI_INVALID_MUTEX_LEVEL #NTSTATUS
STATUS_ACPI_MUTEX_NOT_OWNED #NTSTATUS
STATUS_ACPI_MUTEX_NOT_OWNER #NTSTATUS
STATUS_ACPI_RS_ACCESS #NTSTATUS
STATUS_ACPI_INVALID_TABLE #NTSTATUS
STATUS_ACPI_REG_HANDLER_FAILED #NTSTATUS
STATUS_ACPI_POWER_REQUEST_FAILED #NTSTATUS
STATUS_CTX_WINSTATION_NAME_INVALID #NTSTATUS
STATUS_CTX_INVALID_PD #NTSTATUS
STATUS_CTX_PD_NOT_FOUND #NTSTATUS
STATUS_CTX_CDM_CONNECT #NTSTATUS
STATUS_CTX_CDM_DISCONNECT #NTSTATUS
STATUS_CTX_CLOSE_PENDING #NTSTATUS
STATUS_CTX_NO_OUTBUF #NTSTATUS
STATUS_CTX_MODEM_INF_NOT_FOUND #NTSTATUS
STATUS_CTX_INVALID_MODEMNAME #NTSTATUS
STATUS_CTX_RESPONSE_ERROR #NTSTATUS
STATUS_CTX_MODEM_RESPONSE_TIMEOUT #NTSTATUS
STATUS_CTX_MODEM_RESPONSE_NO_CARRIER #NTSTATUS
STATUS_CTX_MODEM_RESPONSE_NO_DIALTONE #NTSTATUS
STATUS_CTX_MODEM_RESPONSE_BUSY #NTSTATUS
STATUS_CTX_MODEM_RESPONSE_VOICE #NTSTATUS
STATUS_CTX_TD_ERROR #NTSTATUS
STATUS_CTX_LICENSE_CLIENT_INV #NTSTATUSALID
STATUS_CTX_LICENSE_NOT_AVAILABLE #NTSTATUS
STATUS_CTX_LICENSE_EXPIRED #NTSTATUS
STATUS_CTX_WINSTATION_NOT_FOUND #NTSTATUS
STATUS_CTX_WINSTATION_NAME_COLLISION #NTSTATUS
STATUS_CTX_WINSTATION_BUSY #NTSTATUS
STATUS_CTX_BAD_VIDEO_MODE #NTSTATUS
STATUS_CTX_GRAPHICS_INVALID #NTSTATUS
STATUS_CTX_NOT_CONSOLE #NTSTATUS
STATUS_CTX_CLIENT_QUERY_TIMEOUT #NTSTATUS
STATUS_CTX_CONSOLE_DISCONNECT #NTSTATUS
STATUS_CTX_CONSOLE_CONNECT #NTSTATUS
STATUS_CTX_SHADOW_DENIED #NTSTATUS
STATUS_CTX_WINSTATION_ACCESS_DENIE #NTSTATUSD
STATUS_CTX_INVALID_WD #NTSTATUS
STATUS_CTX_WD_NOT_FOUND #NTSTATUS
STATUS_CTX_SHADOW_INVALID #NTSTATUS
STATUS_CTX_SHADOW_DISABLED #NTSTATUS
STATUS_RDP_PROTOCOL_ERROR #NTSTATUS
STATUS_CTX_CLIENT_LICENSE_NOT_SET #NTSTATUS
STATUS_CTX_CLIENT_LICENSE_IN_USE #NTSTATUS
STATUS_CTX_SHADOW_ENDED_BY_MODE_CHANGE #NTSTATUS
STATUS_CTX_SHADOW_NOT_RUNNING #NTSTATUS
STATUS_PNP_BAD_MPS_TABLE #NTSTATUS
STATUS_PNP_TRANSLATION_FAILED #NTSTATUS
STATUS_PNP_IRQ_TRANSLATION_FAILED #NTSTATUS
STATUS_SXS_SECTION_NOT_FOUND #NTSTATUS
STATUS_SXS_CANT_GEN_ACTCTX #NTSTATUS
STATUS_SXS_INVALID_ACTCTXDATA_FORMAT #NTSTATUS
STATUS_SXS_ASSEMBLY_NOT_FOUND #NTSTATUS
STATUS_SXS_MANIFEST_FORMAT_ERROR #NTSTATUS
STATUS_SXS_MANIFEST_PARSE_ERROR #NTSTATUS
STATUS_SXS_ACTIVATION_CONTEXT_DISABLED #NTSTATUS
STATUS_SXS_KEY_NOT_FOUND #NTSTATUS
STATUS_SXS_VERSION_CONFLICT #NTSTATUS
STATUS_SXS_WRONG_SECTION_TYPE #NTSTATUS
STATUS_SXS_THREAD_QUERIES_DISABLED #NTSTATUS
STATUS_SXS_ASSEMBLY_MISSING #NTSTATUS
STATUS_SXS_RELEASE_ACTIVATION_CONTEXT #NTSTATUS
STATUS_SXS_PROCESS_DEFAULT_ALREADY_SET #NTSTATUS
STATUS_SXS_EARLY_DEACTIVATION #NTSTATUS
STATUS_SXS_INVALID_DEACTIVATION #NTSTATUS
STATUS_SXS_MULTIPLE_DEACTIVATION #NTSTATUS
STATUS_SXS_SYSTEM_DEFAULT_ACTIVATION_CONTE #NTSTATUSXT_EMPTY
STATUS_SXS_PROCESS_TERMINATION_REQUESTED #NTSTATUS
STATUS_CLUSTER_INVALID_NODE #NTSTATUS
STATUS_CLUSTER_NODE_EXISTS #NTSTATUS
STATUS_CLUSTER_JOIN_IN_PROGRESS #NTSTATUS
STATUS_CLUSTER_NODE_NOT_FOUND #NTSTATUS
STATUS_CLUSTER_LOCAL_NODE_NOT_FOUND #NTSTATUS
STATUS_CLUSTER_NETWORK_EXISTS #NTSTATUS
STATUS_CLUSTER_NETWORK_NOT_FOUND #NTSTATUS
STATUS_CLUSTER_NETINTERFACE_EXISTS #NTSTATUS
STATUS_CLUSTER_NETINTERFACE_NOT_FOUND #NTSTATUS
STATUS_CLUSTER_INVALID_REQUEST #NTSTATUS
STATUS_CLUSTER_INVALID_NETWORK_PROVIDER #NTSTATUS
STATUS_CLUSTER_NODE_DOWN #NTSTATUS
STATUS_CLUSTER_NODE_UNREACHABLE #NTSTATUS
STATUS_CLUSTER_NODE_NOT_MEMBER #NTSTATUS
STATUS_CLUSTER_JOIN_NOT_IN_PROGRESS #NTSTATUS
STATUS_CLUSTER_INVALID_NETWORK #NTSTATUS
STATUS_CLUSTER_NO_NET_ADAPTERS #NTSTATUS
STATUS_CLUSTER_NODE_UP #NTSTATUS
STATUS_CLUSTER_NODE_PAUSED #NTSTATUS
STATUS_CLUSTER_NODE_NOT_PAUSED #NTSTATUS
STATUS_CLUSTER_NO_SECURITY_CONTEXT #NTSTATUS
STATUS_CLUSTER_NETWORK_NOT_INTERNAL #NTSTATUS
STATUS_CLUSTER_POISONED #NTSTATUS
